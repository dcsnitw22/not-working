// Package asn1gen - ASN1C generated code package
/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (https://obj-sys.com).  Version: 7.7.2, Date: 05-Feb-2024.
 *
 * Copyright (c) 2020-2023 Objective Systems, Inc.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Objective Systems, Inc.
 *
 * PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not
 * indicate any actual or intended publication of such source code.
 *
 * Command:  asn1c /home/imgadmin/asn1c-v772/golang/sample_per/ngap/ngap.asn -i /home/imgadmin/asn1c-v772/golang/sample_per/ngap -o src -oh src -genprint -genprttostr -gentest -aper -go -genmake src/makefile -prjdir ../ngap
 *
 **************************************************************************/
package asn1gen

import (
	"w5gc.io/wipro5gcore/asn1gen/asn1rt"
)

/*
	InitiatingMessage ::= SEQUENCE {
		procedureCode [0] NGAP-ELEMENTARY-PROCEDURE.&procedureCode ({NGAP-ELEMENTARY-PROCEDURES}),
		criticality [1] NGAP-ELEMENTARY-PROCEDURE.&criticality ({NGAP-ELEMENTARY-PROCEDURES}{@procedureCode}),
		value [2] EXPLICIT NGAP-ELEMENTARY-PROCEDURE.&InitiatingMessage ({NGAP-ELEMENTARY-PROCEDURES}{@procedureCode})
	}
*/
type InitiatingMessage struct {
	ProcedureCode ProcedureCode
	Criticality   Criticality
	Value         asn1rt.OpenType
}

/*
	SuccessfulOutcome ::= SEQUENCE {
		procedureCode [0] NGAP-ELEMENTARY-PROCEDURE.&procedureCode ({NGAP-ELEMENTARY-PROCEDURES}),
		criticality [1] NGAP-ELEMENTARY-PROCEDURE.&criticality ({NGAP-ELEMENTARY-PROCEDURES}{@procedureCode}),
		value [2] EXPLICIT NGAP-ELEMENTARY-PROCEDURE.&SuccessfulOutcome ({NGAP-ELEMENTARY-PROCEDURES}{@procedureCode})
	}
*/
type SuccessfulOutcome struct {
	ProcedureCode ProcedureCode
	Criticality   Criticality
	Value         asn1rt.OpenType
}

/*
	UnsuccessfulOutcome ::= SEQUENCE {
		procedureCode [0] NGAP-ELEMENTARY-PROCEDURE.&procedureCode ({NGAP-ELEMENTARY-PROCEDURES}),
		criticality [1] NGAP-ELEMENTARY-PROCEDURE.&criticality ({NGAP-ELEMENTARY-PROCEDURES}{@procedureCode}),
		value [2] EXPLICIT NGAP-ELEMENTARY-PROCEDURE.&UnsuccessfulOutcome ({NGAP-ELEMENTARY-PROCEDURES}{@procedureCode})
	}
*/
type UnsuccessfulOutcome struct {
	ProcedureCode ProcedureCode
	Criticality   Criticality
	Value         asn1rt.OpenType
}

/*
NGAP-PDU ::= CHOICE {
	initiatingMessage [0] InitiatingMessage,
	successfulOutcome [1] SuccessfulOutcome,
	unsuccessfulOutcome [2] UnsuccessfulOutcome,
	...
}
*/
// Choice tag constants
const (
	NGAPPDUInitiatingMessageTAG   = 1
	NGAPPDUSuccessfulOutcomeTAG   = 2
	NGAPPDUUnsuccessfulOutcomeTAG = 3
	NGAPPDUExtElem1TAG            = 4
)

type NGAPPDU struct {
	T uint64
	U struct {
		InitiatingMessage   *InitiatingMessage
		SuccessfulOutcome   *SuccessfulOutcome
		UnsuccessfulOutcome *UnsuccessfulOutcome
		ExtElem1            *asn1rt.Asn1ChoiceExt
	}
}

// PerDecode method implementation
func (pvalue *InitiatingMessage) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	// decode procedureCode

	pctxt.PushElemName("procedureCode")

	pvalue.ProcedureCode, err = PerDecodeProcedureCode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode criticality

	pctxt.PushElemName("criticality")

	pvalue.Criticality, err = PerDecodeCriticality(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode value

	pctxt.PushElemName("value")

	pvalue.Value, err = pctxt.PerDecUnconsOctStr()

	pctxt.PopElemName()
	return
}

// PerEncode method implementation
func (pvalue *InitiatingMessage) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {

	// encode procedureCode

	pctxt.PushElemName("procedureCode")

	err = PerEncodeProcedureCode(pctxt, pvalue.ProcedureCode)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode criticality

	pctxt.PushElemName("criticality")

	err = PerEncodeCriticality(pctxt, pvalue.Criticality)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode value

	pctxt.PushElemName("value")

	err = pctxt.PerEncUnconsOctStr(pvalue.Value)

	pctxt.PopElemName()

	return
}

// PerDecode method implementation
func (pvalue *SuccessfulOutcome) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	// decode procedureCode

	pctxt.PushElemName("procedureCode")

	pvalue.ProcedureCode, err = PerDecodeProcedureCode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode criticality

	pctxt.PushElemName("criticality")

	pvalue.Criticality, err = PerDecodeCriticality(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode value

	pctxt.PushElemName("value")

	pvalue.Value, err = pctxt.PerDecUnconsOctStr()

	pctxt.PopElemName()
	return
}

// PerEncode method implementation
func (pvalue *SuccessfulOutcome) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {

	// encode procedureCode

	pctxt.PushElemName("procedureCode")

	err = PerEncodeProcedureCode(pctxt, pvalue.ProcedureCode)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode criticality

	pctxt.PushElemName("criticality")

	err = PerEncodeCriticality(pctxt, pvalue.Criticality)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode value

	pctxt.PushElemName("value")

	err = pctxt.PerEncUnconsOctStr(pvalue.Value)

	pctxt.PopElemName()

	return
}

// PerDecode method implementation
func (pvalue *UnsuccessfulOutcome) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	// decode procedureCode

	pctxt.PushElemName("procedureCode")

	pvalue.ProcedureCode, err = PerDecodeProcedureCode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode criticality

	pctxt.PushElemName("criticality")

	pvalue.Criticality, err = PerDecodeCriticality(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode value

	pctxt.PushElemName("value")

	pvalue.Value, err = pctxt.PerDecUnconsOctStr()

	pctxt.PopElemName()
	return
}

// PerEncode method implementation
func (pvalue *UnsuccessfulOutcome) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {

	// encode procedureCode

	pctxt.PushElemName("procedureCode")

	err = PerEncodeProcedureCode(pctxt, pvalue.ProcedureCode)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode criticality

	pctxt.PushElemName("criticality")

	err = PerEncodeCriticality(pctxt, pvalue.Criticality)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode value

	pctxt.PushElemName("value")

	err = pctxt.PerEncUnconsOctStr(pvalue.Value)

	pctxt.PopElemName()

	return
}

// PerDecode method implementation
func (pvalue *NGAPPDU) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if !extbit {
		idx, err = pctxt.PerDecBitsToUInt(2)
		switch idx {
		/* initiatingMessage */
		case 0:
			(*pvalue).T = NGAPPDUInitiatingMessageTAG
			// pvalue.T = NGAPPDUInitiatingMessageTAG
			pctxt.PushElemName("initiatingMessage")

			pvalue.U.InitiatingMessage = new(InitiatingMessage)
			err = pvalue.U.InitiatingMessage.PerDecode(pctxt)
			pctxt.PopElemName()

		/* successfulOutcome */
		case 1:
			(*pvalue).T = NGAPPDUSuccessfulOutcomeTAG
			pctxt.PushElemName("successfulOutcome")

			pvalue.U.SuccessfulOutcome = new(SuccessfulOutcome)
			err = pvalue.U.SuccessfulOutcome.PerDecode(pctxt)
			pctxt.PopElemName()

		/* unsuccessfulOutcome */
		case 2:
			(*pvalue).T = NGAPPDUUnsuccessfulOutcomeTAG
			pctxt.PushElemName("unsuccessfulOutcome")

			pvalue.U.UnsuccessfulOutcome = new(UnsuccessfulOutcome)
			err = pvalue.U.UnsuccessfulOutcome.PerDecode(pctxt)
			pctxt.PopElemName()

		default:
			err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
			return
		}
	} else {
		idx, err = pctxt.PerDecSmallNonNegWholeNumber()
		if err != nil {
			return
		}

		pctxt.AlignBuffer()

		pctxt.PushElemName("...")

		// ...
		var choiceExt asn1rt.Asn1ChoiceExt
		choiceExt.Index = idx
		choiceExt.Data, err = pctxt.PerDecUnconsOctStr()
		if err != nil {
			return
		}
		pvalue.U.ExtElem1 = &choiceExt
		pvalue.T = NGAPPDUExtElem1TAG
		pctxt.PopElemName()
	}
	return
}

// PerEncode method implementation
func (pvalue *NGAPPDU) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	var extbit bool
	switch (*pvalue).T {
	case NGAPPDUInitiatingMessageTAG:
		idx = 0
	case NGAPPDUSuccessfulOutcomeTAG:
		idx = 1
	case NGAPPDUUnsuccessfulOutcomeTAG:
		idx = 2
	case NGAPPDUExtElem1TAG:
		idx = pvalue.U.ExtElem1.Index
		extbit = true
	}
	err = pctxt.EncBit(extbit)
	if err != nil {
		return
	}
	if !extbit {
		/* Encode choice index value */

		err = pctxt.PerEncBitsFromUInt(idx, 2)
		if err != nil {
			return
		}

		/* Encode alternative data value */

		switch idx {
		case 0:
			// encode initiatingMessage

			if pvalue.U.InitiatingMessage == nil {
				return pctxt.ErrWithNoParam("Unexpected nil pointer")
			}
			pctxt.PushElemName("initiatingMessage")

			alt := InitiatingMessage((*pvalue.U.InitiatingMessage))
			err = alt.PerEncode(pctxt)

			pctxt.PopElemName()

		case 1:
			// encode successfulOutcome

			if pvalue.U.SuccessfulOutcome == nil {
				return pctxt.ErrWithNoParam("Unexpected nil pointer")
			}
			pctxt.PushElemName("successfulOutcome")

			alt := SuccessfulOutcome((*pvalue.U.SuccessfulOutcome))
			err = alt.PerEncode(pctxt)

			pctxt.PopElemName()

		case 2:
			// encode unsuccessfulOutcome

			if pvalue.U.UnsuccessfulOutcome == nil {
				return pctxt.ErrWithNoParam("Unexpected nil pointer")
			}
			pctxt.PushElemName("unsuccessfulOutcome")

			alt := UnsuccessfulOutcome((*pvalue.U.UnsuccessfulOutcome))
			err = alt.PerEncode(pctxt)

			pctxt.PopElemName()

		default:
			err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
			return
		}
	} else {
		/* Encode extension choice index value */

		err = pctxt.PerEncSmallNonNegWholeNumber(idx)
		if err != nil {
			return
		}
		/* Encode extension element data value */

		var bitidx uint64
		bitidx, err = pctxt.PerEncOpenTypeStart(true)
		if err != nil {
			return
		}

		if pvalue.U.ExtElem1 != nil {
			err = pctxt.EncBytes(pvalue.U.ExtElem1.Data)
			if err != nil {
				return
			}
		}

		err = pctxt.PerEncOpenTypeEnd(bitidx)
		if err != nil {
			return
		}
	}
	return
}

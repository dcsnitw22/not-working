// Package asn1rt - ASN1C generated run-time code package
/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (https://obj-sys.com).  Version: 7.7.2, Date: 05-Feb-2024.
 *
 * Copyright (c) 2020-2023 Objective Systems, Inc.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Objective Systems, Inc.
 *
 * PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not
 * indicate any actual or intended publication of such source code.
 *
 * Command:  asn1c /home/imgadmin/asn1c-v772/golang/sample_per/ngap/ngap.asn -i /home/imgadmin/asn1c-v772/golang/sample_per/ngap -o src -oh src -genprint -genprttostr -gentest -aper -go -genmake src/makefile -prjdir ../ngap
 *
 **************************************************************************/
package asn1rt

import (
	"container/list"
	"encoding/asn1"
	"fmt"
	"math/bits"
	"strconv"
	"strings"
	"unsafe"
)

type OpenType []byte
type OctetString []byte
type ObjectIdentifier []uint64

// OSRTBuffer holds encoded message data.  For an encode operation,
// it is where the message being built is stored.  For decode, it
// holds a copy of the message that is being decoded.
type OSRTBuffer struct {
	data      []byte
	bitOffset uint64
	byteIndex uint64
	partial   byte
}

// OSRTContext is a container structure that holds all working
// variables involved in encoding or decoding a message.
type OSRTContext struct {
	buffer        OSRTBuffer
	elemNameStack list.List
	pBitFieldList *list.List
	lastTagForm   bool
	DiagLevel     byte
}

// DiagBitField describes a bit field within a message
type DiagBitField struct {
	elemName           string
	nameSuffix         string
	bitOffset          uint64
	numbits            uint64
	pOpenTypeFieldList *list.List
	closed             bool /* If true, closed; otherwise open. */
}

type diagBinDumpBuffer struct {
	lb            uint8
	lbm           uint8
	fmtBitBuffer  string
	fmtHexBuffer  string
	fmtAscBuffer  string
	lastBitBuffer string
	repeatCount   uint64
}

func (pctxt *OSRTContext) init() {
	pctxt.buffer.bitOffset = 8
	pctxt.buffer.byteIndex = 0
	pctxt.buffer.partial = 0
}

// AlignBuffer aligns the buffer on the next byte boundary
func (pctxt *OSRTContext) AlignBuffer() bool {
	if pctxt.buffer.bitOffset != 8 {
		pctxt.buffer.bitOffset = 8
		pctxt.buffer.byteIndex++
		return true
	}
	return false
}

// FlushBuffer writes the last partially encoded byte to the output stream.
func (pctxt *OSRTContext) FlushBuffer() {
	if pctxt.buffer.bitOffset != 8 {
		pctxt.buffer.bitOffset = 8
		pctxt.buffer.data =
			append(pctxt.buffer.data, pctxt.buffer.partial)
		pctxt.buffer.byteIndex++
		pctxt.buffer.partial = 0
	}
}

// InitEncode initializes the context buffer for encoding
func (pctxt *OSRTContext) InitEncode() {
	pctxt.init()
	pctxt.buffer.data = make([]byte, 0, 1024)
}

// InitDecodeBytes initializes the context buffer for decoding from a byte
// buffer
func (pctxt *OSRTContext) InitDecodeBytes(b []byte) {
	pctxt.init()
	pctxt.buffer.data = b
}

// ElemName returns the full dotted element name of the current element
func (pctxt *OSRTContext) ElemName() string {
	elemName := ""
	if pctxt.elemNameStack.Len() > 0 {
		for e := pctxt.elemNameStack.Front(); e != nil; e = e.Next() {
			elemName += e.Value.(string)
			if e != pctxt.elemNameStack.Back() {
				elemName += "."
			}
		}
	}
	return elemName
}

// BitOffset return the current bit offset
func (pctxt *OSRTContext) BitOffset() uint64 {
	return uint64((pctxt.buffer.byteIndex * 8) +
		(8 - pctxt.buffer.bitOffset))
}

// Buffer returns a copy of the context buffer
func (pctxt *OSRTContext) Buffer() OSRTBuffer {
	return pctxt.buffer
}

// BufferData returns a pointer to the message data buffer
func (pctxt *OSRTContext) BufferData() []byte {
	return pctxt.buffer.data
}

// BufferDataByte returns the byte at the message data buffer byte index
func (pctxt *OSRTContext) BufferDataByte() byte {
	return pctxt.buffer.data[pctxt.buffer.byteIndex]
}

// BufferRemBytes returns a slice representing the number of bytes remaining
// in the message data buffer after a decode operation
func (pctxt *OSRTContext) BufferRemBytes() []byte {
	return pctxt.buffer.data[pctxt.buffer.byteIndex:]
}

// BufferByteIndex returns the current buffer byte index
func (pctxt *OSRTContext) BufferByteIndex() uint64 {
	return pctxt.buffer.byteIndex
}

// ErrInvalidEnum returns an invalid enumerated identifier error oject
func (pctxt *OSRTContext) ErrInvalidEnum(value uint64) error {
	return fmt.Errorf("invalid enumerated identifier: field %s, value %d",
		pctxt.ElemName(), value)
}

// ErrNotPDUType returns an error indicating value passed into Marshal or
// Unmarshal function is not a known PDU type
func (pctxt *OSRTContext) ErrNotPDUType(value interface{}) error {
	switch v := value.(type) {
	default:
		return fmt.Errorf("type %T is not a known PDU type", v)
	}
}

// ErrNotSupported returns a feature not supported error
func (pctxt *OSRTContext) ErrNotSupported(descr string) error {
	return fmt.Errorf("feature not supported: %s, field %s",
		descr, pctxt.ElemName())
}

// ErrSizeConsVio returns a size constraint violation error oject
func (pctxt *OSRTContext) ErrSizeConsVio(len uint64) error {
	return pctxt.ErrWithParam("size constraint violation", len)
}

// ErrValueConsVio return a value constraint violation error object
func (pctxt *OSRTContext) ErrValueConsVio(value interface{}) error {
	return pctxt.ErrWithParam("value constraint violation", value)
}

// ErrWithNoParam returns an error object with the string description and
// current element.
func (pctxt *OSRTContext) ErrWithNoParam(descr string) error {
	return fmt.Errorf("%s: field %s", descr, pctxt.ElemName())
}

// ErrWithParam returns an error object with a single parameter of any type
func (pctxt *OSRTContext) ErrWithParam(descr string, value interface{}) error {
	var valstr string
	switch v := value.(type) {
	case string:
		valstr = v
	case int:
		valstr = strconv.Itoa(v)
	case uint:
		valstr = strconv.FormatUint(uint64(v), 10)
	case uint64:
		valstr = strconv.FormatUint(v, 10)
	}
	return fmt.Errorf("%s: field %s, value %s", descr, pctxt.ElemName(), valstr)
}

// FetchByte fetches the next byte from the message data buffer and
// increments the byte index
func (pctxt *OSRTContext) FetchByte() byte {
	b := pctxt.buffer.data[pctxt.buffer.byteIndex]
	pctxt.buffer.byteIndex++
	return b
}

// IncrBufferByteIndex increments the byte index by the specified amount
func (pctxt *OSRTContext) IncrBufferByteIndex(n uint64) {
	pctxt.buffer.byteIndex += n
}

// PushArrayElemName is used to push an element name with array subscript
// onto the eleent name stack
func (pctxt *OSRTContext) PushArrayElemName(elemName string, idx uint64) {
	name := fmt.Sprintf("%s[%d]", elemName, idx)
	pctxt.elemNameStack.PushBack(name)
}

// PushElemName is used to push an element name onto the eleent name stack
func (pctxt *OSRTContext) PushElemName(elemName string) {
	pctxt.elemNameStack.PushBack(elemName)
}

// PopElemName returns the top element name on the stack and removes the
// top record
func (pctxt *OSRTContext) PopElemName() string {
	if pctxt.elemNameStack.Len() > 0 {
		element := pctxt.elemNameStack.Back()
		pctxt.elemNameStack.Remove(element)
		return element.Value.(string)
	}
	return ""
}

// PeekElemName returns the top name element name on the stack but leaves the
// stack intact
func (pctxt *OSRTContext) PeekElemName() string {
	if pctxt.elemNameStack.Len() > 0 {
		element := pctxt.elemNameStack.Back()
		return element.Value.(string)
	}
	return ""
}

// ReplaceTopElemName replace the top element name on the stack with a new name
func (pctxt *OSRTContext) ReplaceTopElemName(elemName string) {
	pctxt.PopElemName()
	pctxt.elemNameStack.PushBack(elemName)
}

// SetBitOffset sets the context buffer byteIndex and bitOffset parameters to the
// given aggregate bit offset
func (pctxt *OSRTContext) SetBitOffset(offset uint64) error {
	pctxt.buffer.byteIndex = uint64(offset / 8)
	pctxt.buffer.bitOffset = uint64(8 - (offset % 8))
	byteIndex := pctxt.buffer.byteIndex
	if pctxt.buffer.bitOffset != 8 {
		byteIndex++
	}
	if byteIndex >= uint64(len(pctxt.buffer.data)) {
		return fmt.Errorf("attempt made to set byte index past end of buffer")
	}
	return nil
}

// SetBuffer sets the context buffer to the given value
func (pctxt *OSRTContext) SetBuffer(buf OSRTBuffer) {
	pctxt.buffer = buf
}

// SetBufferByteIndex sets the context buffer byte index to the given value
func (pctxt *OSRTContext) SetBufferByteIndex(idx uint64) {
	pctxt.buffer.byteIndex = idx
}

// SkipBits increases the context buffer's byteIndex and/or bitOffset
// to move the decoder cursor ahead by the given number of bits.
func (pctxt *OSRTContext) SkipBits(nbits uint64) error {
	if nbits == 0 {
		return nil
	}

	if pctxt.buffer.bitOffset > nbits {
		pctxt.buffer.bitOffset -= nbits
		return nil
	}

	nbits -= pctxt.buffer.bitOffset
	// think of pctxt.buffer.bitOffset as == 8 now and pcxt.buffer.bitOffset as
	// incremented by 1 (which happens below)

	byteIndex := pctxt.buffer.byteIndex + 1 + nbits/8
	rem := nbits % 8

	if (rem == 0 && byteIndex > uint64(len(pctxt.buffer.data))) ||
		(rem > 0 && byteIndex >= uint64(len(pctxt.buffer.data))) {
		return fmt.Errorf("attempt made to set byte index past end of buffer")
	}

	pctxt.buffer.byteIndex = byteIndex
	pctxt.buffer.bitOffset = 8 - rem

	return nil
}

/**
 * CanonicalError is used for violations of canonical encodings specified by
 * CER, DER, canonical XER etc.
 * The CanonicalErrorf function can be used to create such an error, simliar to
 * fmt.Errorf, except that %w is not recognized (you cannot wrap some other error
 * in a CanonicalError).
 */
type CanonicalError struct {
	msg string
}

func CanonicalErrorf(format string, a ...interface{}) CanonicalError {
	var err CanonicalError
	err.msg = fmt.Sprintf(format, a...)
	return err
}

func (x CanonicalError) Error() string {
	return x.msg
}

// SkipBytes increases the context buffer's byteIndex to move the decoder
// cursor ahead by the given number of bytes. If an attempt is made to
// set the byte index past the end of the buffer, an error is returned.
func (pctxt *OSRTContext) SkipBytes(nbytes uint64) error {
	if nbytes == 0 {
		return nil
	}
	byteIndex := pctxt.buffer.byteIndex + nbytes
	if byteIndex > uint64(len(pctxt.buffer.data)) {
		return fmt.Errorf("attempt made to set byte index past end of buffer")
	}
	pctxt.buffer.byteIndex = byteIndex
	return nil
}

// intByteCount returns the smallest number of bytes needed to
// represent the given value in 2's complement form
// Examples:
//
//		intByteCount(0) == 1
//	 intByteCount(255) == 2
func intByteCount(val int64) uint8 {
	var retVal uint8

	var mask int64 = 0x7f80 << 48 /* 7f80 put into highest bits */
	retVal = 8                    /* 8 bytes for 64-bit int) */

	if val < 0 {
		/* Take bit-wise complement of val.  However many octets are needed
		to represent that positive value (as a signed number), the same will
		be needed to represent the original value.
		*/
		val = ^val
	}

	for (retVal > 1) && ((val & mask) == 0) {
		mask >>= 8
		retVal--
	}

	return retVal
}

type Asn1ChoiceExt struct {
	Index uint64
	Data  []byte
}

// decBytes reads the given number of bytes from input and returns an array
// containing the data read.
// The returned slice may be backed by the input data, so that modifications
// to it will modify the input data and also the input data will not be garbage
// collected until the slice is garbarge collected.  If this is undesirable,
// use DecBytesCopy instead.
func (pctxt *OSRTContext) decBytes(nbytes uint64) (value []byte, err error) {
	if pctxt.buffer.bitOffset == 8 {
		if nbytes > uint64(len(pctxt.buffer.data))-pctxt.buffer.byteIndex {
			err = fmt.Errorf("decBytes: buffer overflow")
			return
		}

		value = pctxt.buffer.data[pctxt.buffer.byteIndex : pctxt.buffer.byteIndex+nbytes]
		pctxt.buffer.byteIndex += nbytes
	} else {
		/* Data is not byte-aligned.  We'll have to copy the data. */
		value = make([]byte, nbytes)
		err = pctxt.DecBytesIntoSlice(value)
	}
	return
}

// DecBytesCopy read the given number of bytes from input and returns an array
// containing the data read.
// This will always make a copy of the input data. See also DecBytes for a
// possible alternative.
func (pctxt *OSRTContext) DecBytesCopy(nbytes uint64) (value []byte, err error) {
	value = make([]byte, nbytes)
	err = pctxt.DecBytesIntoSlice(value)
	return
}

// DecBytesIntoSlice reads len(value) bytes from input into value.
func (pctxt *OSRTContext) DecBytesIntoSlice(value []byte) (err error) {
	nbytes := uint64(len(value))

	if pctxt.buffer.bitOffset == 8 {
		if nbytes > uint64(len(pctxt.buffer.data))-pctxt.buffer.byteIndex {
			err = fmt.Errorf("DecBytesIntoSlice: buffer overflow")
			return
		}

		copy(value, pctxt.buffer.data[pctxt.buffer.byteIndex:pctxt.buffer.byteIndex+nbytes])
		pctxt.buffer.byteIndex += nbytes
	} else {
		for i := uint64(0); i < nbytes; i++ {
			var ub uint64
			ub, err = pctxt.PerDecBitsToUInt(8)
			if err != nil {
				err = fmt.Errorf("DecBytesIntoSlice: %w", err)
				return
			}
			value[i] = byte(ub)
		}
	}
	return
}

// DecBit decodes one bit
func (pctxt *OSRTContext) DecBit() (result bool, err error) {
	err = nil
	result = false

	if pctxt.buffer.byteIndex >= uint64(len(pctxt.buffer.data)) {
		err = fmt.Errorf("attempt to read past end-of-buffer")
		return
	}
	pctxt.buffer.bitOffset--

	buf := pctxt.buffer.data
	idx := pctxt.buffer.byteIndex
	if ((buf[idx] >> pctxt.buffer.bitOffset) & 1) == 1 {
		result = true
	}

	if pctxt.buffer.bitOffset == 0 {
		pctxt.buffer.bitOffset = 8
		pctxt.buffer.byteIndex++
	}

	return
}

// PerDecBitsToUInt decodes the given number of bits and returns the result
// in an unsigned integer variable
func (pctxt *OSRTContext) PerDecBitsToUInt(nbits uint64) (uint64, error) {
	if nbits == 0 {
		return uint64(0), nil
	} else if nbits > 64 {
		return 0,
			fmt.Errorf("Result will not fit in 64-bit unsigned int")
	}
	buf := pctxt.buffer.data
	idx := pctxt.buffer.byteIndex

	// If the number of bits is less than the current bit offset, mask
	// off the required number of bits and return..

	var ui uint64
	if nbits <= pctxt.buffer.bitOffset {
		if idx >= uint64(len(pctxt.buffer.data)) {
			return uint64(0), fmt.Errorf("Attempt to read past end-of-buffer")
		}
		pctxt.buffer.bitOffset -= nbits

		ui = uint64((buf[idx] >> pctxt.buffer.bitOffset) &
			((1 << nbits) - 1))

		if pctxt.buffer.bitOffset == 0 {
			pctxt.buffer.bitOffset = 8
			pctxt.buffer.byteIndex++
		}
	} else {
		nbytes := uint64((nbits - pctxt.buffer.bitOffset + 15) / 8)
		var i uint64
		if pctxt.buffer.bitOffset == 8 {
			if nbits%8 == 0 {
				for i = 0; i < nbytes; i++ {
					ui = ui*256 + uint64(buf[idx+i])
				}
			} else {
				for i = 0; i < nbytes-1; i++ {
					ui = ui*256 + uint64(buf[idx+i])
				}
				pctxt.buffer.bitOffset = 8 - (nbits % 8)
				ui = ui<<(8-pctxt.buffer.bitOffset) +
					uint64(buf[idx+i]>>pctxt.buffer.bitOffset)

			}
		} else {
			// handle case of non-byte boundary
			// first read current byte remaining bits
			mask := byte(0xff >> (8 - pctxt.buffer.bitOffset))
			ui = uint64(buf[idx] & mask)

			nbits -= pctxt.buffer.bitOffset
			pctxt.buffer.bitOffset = 8

			// second add full bytes from buf
			for i = 1; nbits >= 8; i++ {
				ui <<= 8
				ui |= uint64(buf[idx+i])
				nbits -= 8
			}

			// third process last partial byte
			if nbits > 0 {
				pctxt.buffer.bitOffset = uint64(8 - nbits)
				ui <<= nbits
				ui |= uint64(buf[idx+i]) >> pctxt.buffer.bitOffset
			}
		}
		pctxt.buffer.byteIndex += nbytes
		if pctxt.buffer.bitOffset != 8 {
			pctxt.buffer.byteIndex--
		}
	}

	return ui, nil
}

// PerDecUnconsLen is used to decode a PER unconstrained length.
func (pctxt *OSRTContext) PerDecUnconsLen() (uint64, bool, error) {
	pctxt.AlignBuffer()

	/* Decode length */
	b, err := pctxt.DecBit()
	if err != nil {
		return 0, false, err
	}

	var ui uint64
	if b == false {
		ui, err = pctxt.PerDecBitsToUInt(7)
		return ui, false, err
	}
	b, err = pctxt.DecBit()
	if err != nil {
		return 0, false, err
	}
	if b == false {
		ui, err = pctxt.PerDecBitsToUInt(14)
		return ui, false, err
	}
	// fragmented length
	var mult uint64
	mult, err = pctxt.PerDecBitsToUInt(6)
	if err != nil {
		return 0, false, err
	}
	if mult > 4 {
		return 0, true, fmt.Errorf("Invalid multiplier %d", mult)
	}

	return 16384 * mult, true, nil
}

// PerDecUnconsOctStr decodes an unconstrained octet string.
// This includes the length and the data.
func (pctxt *OSRTContext) PerDecUnconsOctStr() ([]byte, error) {
	var value []byte
	var err error
	var nitems uint64
	var frag bool = true
	for frag {
		// decode length
		nitems, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return nil, err
		}
		var tmp []byte
		tmp, err = pctxt.decBytes(nitems)
		if err != nil {
			return nil, err
		}
		value = append(value, tmp...)
	}
	return value, nil
}

func (pctxt *OSRTContext) PerEncBufAlign() {
	if pctxt.buffer.bitOffset != 8 {
		pctxt.buffer.bitOffset = 8
		pctxt.buffer.data = append(pctxt.buffer.data, pctxt.buffer.partial)
		pctxt.buffer.byteIndex++
		pctxt.buffer.partial = 0
	}
}
func (pctxt *OSRTContext) EncBytes(value []byte) error {
	if pctxt.buffer.bitOffset == 8 {
		pctxt.buffer.data = append(pctxt.buffer.data, value...)
		pctxt.buffer.byteIndex = uint64(len(pctxt.buffer.data))
	} else {
		// write to not byte-aligned boundary
		for i := 0; i < len(value); i++ {
			err := pctxt.EncBitsFromByte(value[i], 8)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// PerEncUnconsLen will encode an unconstrained length value.
// This returns value or the size of the fragment to encode (a multiple
// of 16384).
func (pctxt *OSRTContext) PerEncUnconsLen(value uint64) (uint64, error) {
	pctxt.PerEncBufAlign()

	enclen := value
	var err error
	if value < 128 {
		err = pctxt.EncBitsFromByte(byte(value), 8)
	} else if value < 16384 {
		err = pctxt.PerEncBitsFromUInt((uint64)(value|0x8000), 16)
	} else {
		/* fragmentation case */
		var multiplier uint64 = 4
		if value <= 64*1024 {
			multiplier = value / 16384
		}
		err = pctxt.EncBitsFromByte(byte(multiplier|0xC0), 8)
		if err == nil {
			enclen = uint64(16384 * multiplier)
		}
	}
	return enclen, err
}

// PerEncUnconsOctStr will encode an unconstrained octet string value.
// The string is assumed to not have a size constraint.
func (pctxt *OSRTContext) PerEncUnconsOctStr(value []byte) error {
	var err error
	nitems := uint64(len(value))
	var enclen uint64
	var fraglen uint64

	if nitems == 0 {
		fraglen, err = pctxt.PerEncUnconsLen(0)
		return err
	}

	for enclen < nitems {
		// Encode length
		fraglen, err = pctxt.PerEncUnconsLen(nitems - enclen)
		if err != nil {
			return err
		}
		// Encode bytes
		if enclen+fraglen < nitems {
			err = pctxt.EncBytes(value[enclen : enclen+fraglen])
		} else {
			err = pctxt.EncBytes(value[enclen:])
		}
		if err != nil {
			return err
		}
		enclen += fraglen
	}
	return nil
}

func (pctxt *OSRTContext) PerDecSmallNonNegWholeNumber() (uint64, error) {
	bitValue, err := pctxt.DecBit()
	if err != nil {
		return 0, err
	}

	var value uint64
	if !bitValue {
		/* n <= 64. Encoded value is n-1. */
		return pctxt.PerDecBitsToUInt(6)
	}
	/*  n > 64. Encoded value is n. */
	var llen uint64
	llen, _, err = pctxt.PerDecUnconsLen()
	if err == nil {
		pctxt.PerDecByteAlign()
		value, err = pctxt.PerDecBitsToUInt(llen * 8)
	}

	return value, err
}
func (pctxt *OSRTContext) EncBit(value bool) error {
	encbuf := &pctxt.buffer
	var bitOffset uint64 = encbuf.bitOffset - 1
	var mask byte
	if value {
		mask = 1 << bitOffset
	}
	encbuf.partial |= mask

	if bitOffset == 0 {
		encbuf.data = append(encbuf.data, encbuf.partial)
		encbuf.partial = 0
		encbuf.bitOffset = 8
		encbuf.byteIndex++
	} else {
		encbuf.bitOffset = bitOffset
	}

	return nil
}

// EncBitsFromByte will encode bits from a byte value.
// The least significant bits in the value will be encoded.
func (pctxt *OSRTContext) EncBitsFromByte(value byte, nbits uint64) error {
	encbuf := &pctxt.buffer
	bitOff := encbuf.bitOffset

	if nbits == 0 {
		return nil
	} else if nbits > 8 {
		return fmt.Errorf("nbits %d greater than max 8", nbits)
	}

	if bitOff == 8 {
		/* field aligned */
		if nbits == 8 {
			encbuf.data = append(encbuf.data, value)
			encbuf.byteIndex++
		} else {
			encbuf.partial = value << (8 - nbits) // clear unused bits
			encbuf.bitOffset = (8 - (nbits & 7))
		}
	} else {
		/* field unaligned */
		usedBits := 8 - bitOff
		nextOff := nbits + usedBits

		encbuf.bitOffset = (8 - (nextOff & 0x7))

		value <<= 8 - nbits /* clear unused bits */
		encbuf.partial |= value >> usedBits

		if nextOff > 7 {
			encbuf.data = append(encbuf.data, encbuf.partial)
			encbuf.byteIndex++
			encbuf.partial = value << bitOff
		}
	}

	return nil
}

// PerEncBitsFromUInt will encode bits from an unsigned integer value.
// The least significant bits in the value will be encoded.
func (pctxt *OSRTContext) PerEncBitsFromUInt(value uint64, nbits uint64) error {
	if nbits == 0 {
		return nil
	} else if nbits > bits.UintSize {
		return fmt.Errorf("nbits %d greater than max %d", nbits, bits.UintSize)
	}

	/* Encode value to temp buffer */
	const uintSizeBytes = bits.UintSize / 8
	var ba [uintSizeBytes]byte
	tmpidx := uint64(uintSizeBytes)
	temp := value
	for {
		lb := temp % 256
		temp /= 256
		tmpidx--
		ba[tmpidx] = byte(lb)

		if temp == 0 {
			break
		}
	}

	/* Encode bytes from temp buffer to output stream */
	var err error
	nbytes := nbits / 8
	b0bits := nbits % 8
	startx := uintSizeBytes - nbytes
	if b0bits != 0 {
		err = pctxt.EncBitsFromByte(ba[startx-1], b0bits)
		if err != nil {
			return err
		}
	}
	for i := startx; i < uintSizeBytes; i++ {
		err = pctxt.EncBitsFromByte(ba[i], 8)
		if err != nil {
			return err
		}
	}

	return nil
}

// PerEncSmallNonNegWholeNumber encompasses the rules to encode a small
// non-negative whole number as specified in section 10.6 of the X.691
// standard.
func (pctxt *OSRTContext) PerEncSmallNonNegWholeNumber(value uint64) error {
	var err error
	if value < 64 {
		err = pctxt.PerEncBitsFromUInt(value, 7)
	} else {
		/* Encode extension bit */
		err = pctxt.EncBit(true)
		if err != nil {
			return err
		}
		pctxt.PerEncBufAlign()

		/* Encode a one-byte length determinant value */
		var llen uint64
		if value < 256 {
			llen = 1
		} else if value < 65536 {
			llen = 2
		} else if value < 0x1000000 {
			llen = 3
		} else {
			return fmt.Errorf("Very large SmallNonNegWholeNumber not supported")
		}

		err = pctxt.PerEncBitsFromUInt(llen, 8)

		/* Encode the value */
		if err == nil {
			err = pctxt.PerEncBitsFromUInt(value, llen*8)
		}
	}

	return err
}
func (pctxt *OSRTContext) PerEncOpenTypeStart(aligned bool) (uint64, error) {
	return pctxt.PerEncEmbeddedLenStart(aligned)
}

// PerEncOpenTypeEnd will complete a PER open type encoding which was initiated
// using PerEncOpenTypeStart. It will encode and fill in the length value. The
// buffer contents will be shifted if necessary
func (pctxt *OSRTContext) PerEncOpenTypeEnd(bitidx uint64) error {
	// The encoded open type value must first be padded out to a byte boundary
	for (pctxt.BitOffset()-bitidx)%8 != 0 {
		err := pctxt.EncBit(false)
		if err != nil {
			return err
		}
	}
	return pctxt.PerEncEmbeddedLenEnd(bitidx, false)
}
func (pctxt *OSRTContext) PerDecSmallLength() (uint64, error) {
	bitValue, err := pctxt.DecBit()
	if err != nil {
		return 0, err
	}

	var value uint64
	if !bitValue {
		/* n <= 64. Encoded value is n-1. */
		value, err = pctxt.PerDecBitsToUInt(6)
		value = value + 1
	} else {
		/*  n > 64. Encoded value is n. */
		value, _, err = pctxt.PerDecUnconsLen()
	}
	return value, err
}

// PerEncSmallLength encodes a normally small length as specified in
// section 11.9 of the X.691 standard.
func (pctxt *OSRTContext) PerEncSmallLength(value uint64) error {
	var err error
	if value == 0 {
		return fmt.Errorf(
			"Normally small length value must be greater than zero")
	} else if value <= 64 {
		err = pctxt.EncBit(false) /*  indicate <= 64 */
		if err == nil {
			/* encode n-1 */
			err = pctxt.PerEncBitsFromUInt(value-1, 6)
		}
	} else {
		err = pctxt.EncBit(true) /* indicate value > 64 */
		if err == nil {
			_, err = pctxt.PerEncUnconsLen(value)
		}
	}

	return err
}
func (pctxt *OSRTContext) PerEncOpenTypeExtBits(extElems [][]byte) error {
	if len(extElems) > 0 {
		for i := 0; i < len(extElems); i++ {
			err := pctxt.EncBit(bool(len(extElems[i]) > 0))
			if err != nil {
				return err
			}
		}
	}
	return nil
}
func (pctxt *OSRTContext) PerEncOpenTypeExt(extElems [][]byte) error {
	if len(extElems) > 0 {
		for i := 0; i < len(extElems); i++ {
			err := pctxt.PerEncOpenType(extElems[i])
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type BitString asn1.BitString

// SetBit sets the bit at the given bit index in the bit string
func SetBit(bitidx uint64, pbitstr *BitString) {
	byteIndex := bitidx / 8
	bitMask := byte(0x80 >> (bitidx % 8))
	if uint64(cap(pbitstr.Bytes)) <= byteIndex {
		s := make([]byte, byteIndex+1)
		copy(s, pbitstr.Bytes)
		pbitstr.Bytes = s
	}
	pbitstr.Bytes[byteIndex] |= bitMask
	if bitidx >= uint64(pbitstr.BitLength) {
		pbitstr.BitLength = int(bitidx) + 1
	}
}

// ClearBit clear the bit at the given bit index in the bit string
func ClearBit(bitidx uint64, pbitstr *BitString) error {
	byteIndex := bitidx / 8
	if uint64(cap(pbitstr.Bytes)) <= byteIndex {
		return fmt.Errorf("bit index %d is out of range", bitidx)
	}
	bitMask := ^(0x80 >> (bitidx % 8))
	pbitstr.Bytes[byteIndex] &= byte(bitMask)
	return nil
}

// TestBit test if the bit at the given bit index is set in the bit string
func TestBit(bitidx uint64, pbitstr *BitString) (bool, error) {
	byteIndex := bitidx / 8
	if uint64(cap(pbitstr.Bytes)) <= byteIndex {
		return false, fmt.Errorf("bit index %d is out of range", bitidx)
	}
	bitMask := 0x80 >> (bitidx % 8)
	res := bool((pbitstr.Bytes[byteIndex] & byte(bitMask)) != 0)

	return res, nil
}

/**
 * ClearUnusedBits clears the unused bits in the last byte of the bit string.
 */
func ClearUnusedBits(pbitstr *BitString) {
	usedBits := pbitstr.BitLength % 8
	if usedBits > 0 {
		lastByteIdx := pbitstr.BitLength / 8
		pbitstr.Bytes[lastByteIdx] &= 0xFF << (8 - usedBits)
	}
}

/**
 * TrimZeroBitsLen returns a trimmed version of pbitstr, with trailing
 * zero bits removed so as to make the string as short as minlen.
 * As a side-effect, this will zero the unused bits of the final byte of the
 * given string
 * This returns a shallow copy of the given bit string, which means the
 * returned string will share the underlying byte data with the given string.
 */
func TrimZeroBitsLen(pbitstr *BitString, minlen int) (ret BitString) {

	ret = *pbitstr

	/* First, determine how many (full or partial) bytes there are
	and make sure unused bits in the last byte are zeroed.
	*/
	bytes := pbitstr.BitLength / 8
	extraBits := pbitstr.BitLength % 8
	if extraBits > 0 {
		/* Clear the unused bits in the last byte */
		unused := 8 - extraBits
		pbitstr.Bytes[bytes] &= 0xFF << unused

		bytes++

		/* Treat last byte as full.  The extra bits are zeroed so
		we'll just trim them off later, but this simplifies the logic.
		*/
		ret.BitLength += unused
	}

	/* Next, adjust bytes and ret.BitLength to get rid of all trailing
	zero bits.
	*/
	for bytes > 0 {
		lastByte := pbitstr.Bytes[bytes-1]
		if lastByte == 0 && ret.BitLength-8 >= minlen {
			/* entire last byte is trimmed */
			bytes--
			ret.BitLength -= 8
		} else if lastByte%2 == 1 {
			/* last byte does not get trimmed at all. */
			break
		} else {
			/* Lowest bit is zero; entire byte is not trimmed,
			so trim bit-by-bit. */
			for ret.BitLength > minlen {
				lastByte = lastByte >> 1
				ret.BitLength--
				if ret.BitLength == 0 || lastByte%2 == 1 {
					break
				}
			}
			break
		}
	}

	ret.Bytes = ret.Bytes[0:bytes]
	return
}

/**
 * TrimZeroBits clears the unused bits in the last byte of the given bit string.
 * It then returns a shallow copy of the given bit string, with Bytes and BitLength set
 * so as to trim all zero bits from the string. Note that the returned string will share
 * the underlying byte data with the given string.
 */
func TrimZeroBits(pbitstr *BitString) (ret BitString) {

	return TrimZeroBitsLen(pbitstr, 0)
}
func (pctxt *OSRTContext) PerDecConsLength(
	rangeBitCount uint64, lowerBound uint64) (uint64, error) {
	var err error
	var len uint64

	len, err = pctxt.PerDecBitsToUInt(rangeBitCount)
	if err != nil {
		return 0, err
	}

	return len + lowerBound, nil
}

// PerDecRestrStringData decodes the data of a restricted character string,
// decoding slen characters, each of which was encoded in nbits bits.
// If charSet is not empty, it is used to translate character values.
//
// This function can be used for string types where each character is
// represented in the Go string by 1 byte (NumericString, PrintableString,
// VisibleString (ISO646String), and IA5String).
//
// charSet, if not empty, is the set of characters, in sorted order, which
// form the effective permitted alphabet for the string type being decoded.
func (pctxt *OSRTContext) PerDecRestrStringData(slen uint64,
	charSet string, nbits uint64) (string, error) {
	var strbuf string

	if len(charSet) == 0 {
		// Decode without translation.
		if pctxt.buffer.bitOffset == 8 && nbits == 8 {
			idx := pctxt.buffer.byteIndex
			endx := idx + slen
			if endx > uint64(len(pctxt.buffer.data)) {
				return "", fmt.Errorf("Attempt to read past end-of-buffer")
			}
			strbuf = string(pctxt.buffer.data[idx:endx])
			pctxt.buffer.byteIndex = endx
		} else {
			var sb strings.Builder
			for i := uint64(0); i < slen; i++ {
				idx, err := pctxt.PerDecBitsToUInt(nbits)
				if err != nil {
					return "", err
				}
				sb.WriteRune(rune(idx))
			}
			strbuf = sb.String()
		}
	} else {
		// Decode with translation.
		nchars := uint64(len(charSet))
		for i := uint64(0); i < slen; i++ {
			idx, err := pctxt.PerDecBitsToUInt(nbits)
			if err != nil {
				return "", err
			}
			if idx < nchars {
				strbuf += charSet[idx : idx+1]
			} else {
				return "",
					fmt.Errorf("Decoded index %d not in character set", idx)
			}
		}
	}

	return strbuf, nil
}
func getIntLength(value int64) int {
	var tempValue uint64
	var shift int

	/* Calculate signed number value length */
	// note: in C, shift is calculated as follows:
	// int shift = (int)(((sizeof(value) - 1) * 8) - 1);
	// for a 64-bit integer, this produces a value of 55

	for shift = 55; shift > 0; shift -= 8 {
		tempValue = uint64((value >> shift) & 0x1ff)
		if tempValue == 0 || tempValue == 0x1ff {
			continue
		} else {
			break
		}
	}

	return (shift + 9) / 8
}

// PerEncRestrStringData encodes the data (no length determinant) for an ASN.1
// restricted charactcer string value, encoding each character in nbits bits.
// If charSet is not empty, it is used to translate character values.
//
// This function can be used for string types where each character is
// represented in the Go string by 1 byte (NumericString, PrintableString,
// VisibleString (ISO646String), and IA5String).
//
// charSet, if not empty, is the set of characters, in sorted order, which
// form the effective permitted alphabet for the string type being encoded.
func (pctxt *OSRTContext) PerEncRestrStringData(value string,
	charSet string, nbits uint64) error {

	if len(charSet) == 0 {
		// Encode as-is, w/o translation.
		if pctxt.buffer.bitOffset == 8 && nbits == 8 {
			strbytes := []byte(value)
			pctxt.buffer.data = append(pctxt.buffer.data, strbytes...)
			pctxt.buffer.byteIndex += uint64(len(strbytes))
		} else {
			for i := 0; i < len(value); i++ {
				err := pctxt.EncBitsFromByte(value[i], nbits)
				if err != nil {
					return err
				}
			}
		}
	} else {
		//Encode with translation.
		for i := 0; i < len(value); i++ {
			idx := strings.Index(charSet, value[i:i+1])
			if idx < 0 {
				return fmt.Errorf("Character %s not found in character set %s",
					value[i:i+1], charSet)
			}

			err := pctxt.PerEncBitsFromUInt(uint64(idx), nbits)
			if err != nil {
				return err
			}
		}
	}

	return nil
}
func (pctxt *OSRTContext) DecBits(nbits uint64) (value []byte, err error) {
	nbytes := nbits / 8
	rembits := nbits % 8

	value = make([]byte, nbytes)
	err = pctxt.DecBytesIntoSlice(value)
	if rembits > 0 {
		var b bool
		var lastByte byte
		var mask byte = 0x80
		for i := uint64(0); i < rembits; i++ {
			b, err = pctxt.DecBit()
			if err != nil {
				return
			}
			if b {
				lastByte |= mask
			}
			mask >>= 1
		}
		value = append(value, lastByte)
	}

	return
}

// PerEncBitsFromByteArray will encode bits from a byte array/slice
func (pctxt *OSRTContext) PerEncBitsFromByteArray(
	value []byte, nbits uint64) (err error) {
	encbuf := &pctxt.buffer
	bitOff := encbuf.bitOffset

	if nbits == 0 {
		return
	} else if nbits > uint64(len(value)*8) {
		err = fmt.Errorf("nbits %d greater than length of buffer", nbits)
		return
	}

	nbytes := nbits / 8
	if bitOff == 8 {
		// field aligned
		encbuf.data = append(encbuf.data, value[:nbytes]...)
		encbuf.byteIndex += nbytes
	} else {
		// not aligned
		for i := uint64(0); i < nbytes; i++ {
			err = pctxt.EncBitsFromByte(value[i], 8)
		}
	}
	rembits := nbits % 8
	if rembits != 0 {
		// encode remaining bits in last byte
		b := byte(value[nbytes] >> (8 - rembits))
		err = pctxt.EncBitsFromByte(b, rembits)
	}

	return
}
func (pctxt *OSRTContext) PerDecConsWholeNumRangeGT64K(
	lenBits uint64) (uint64, error) {
	/* range > 64k, indefinite-length case (10.5.7d)               */
	/* Encode length determinant as a constrained whole number.    */
	/* Constraint is 1 to max number of bytes needed to hold       */
	/* the target integer value..                                  */

	nocts, err := pctxt.PerDecBitsToUInt(lenBits)
	if err != nil {
		return 0, err
	}
	pctxt.PerDecByteAlign()

	rangeBitCount := (nocts + 1) * 8

	return pctxt.PerDecBitsToUInt(rangeBitCount)
}

// PerEncConsWholeNumRangeGT64K encodes a constrained whole number
// whose range is greater than 64K
func (pctxt *OSRTContext) PerEncConsWholeNumRangeGT64K(
	adjustedValue uint64, lenBits uint64) error {
	var nocts uint64
	var bitcnt uint64
	if adjustedValue == 0 {
		nocts = 1
		bitcnt = 1
	} else {
		bitcnt = uint64(bits.Len(uint(adjustedValue)))
		nocts = (bitcnt + 7) / 8
	}

	// Encode length
	err := pctxt.PerEncBitsFromUInt(nocts-1, lenBits)
	if err != nil {
		return err
	}
	pctxt.PerEncBufAlign()

	bitcnt = ((bitcnt + 7) >> 3) << 3

	err = pctxt.PerEncBitsFromUInt(adjustedValue, bitcnt)

	return err
}

// PerDecObjectIdentifier - Decode an OBJECT IDENTIFIER type.
func (pctxt *OSRTContext) PerDecObjectIdentifier() ([]uint64, error) {
	var b, subid uint64
	var i int

	/* Decode unconstrained length */
	length, frag, stat := pctxt.PerDecUnconsLen()
	if stat != nil {
		return nil, stat
	}
	if frag {
		return nil, fmt.Errorf(
			"Object identifier with fragmented length not supported")
	}

	subids := make([]uint64, length+1)

	/* Copy contents to a byte-aligned local buffer */
	for (length > 0) && (stat == nil) {
		if i < 128 { /* ASN_K_MAXSUBIDS */
			/* Parse a subidentifier out of the contents field */
			subids[i] = 0
			for stat == nil {
				b, stat = pctxt.PerDecBitsToUInt(8)
				if stat == nil {
					subids[i] = (subids[i] * 128) + (b & 0x7F)
					length--
				}

				if (b & 0x80) == 0 {
					break
				}
			}

			/* Handle the first subidentifier special case: the first two
			   sub-id's are encoded into one using the formula (x * 40) + y */
			if i == 0 {
				subid = subids[0]
				if (subid / 40) >= 2 {
					subids[0] = 2
				} else {
					subids[0] = subid / 40
				}

				if subids[0] == 2 {
					subids[1] = subid - 80
				} else {
					subids[1] = subid % 40
				}

				i = 2
			} else {
				i++
			}
		} else {
			stat = fmt.Errorf("Invalid object identifier value")
		}
	}

	if (stat == nil) && (length != 0) {
		return nil, fmt.Errorf("Invalid object identifier length")
	}

	if stat != nil {
		return nil, stat
	}

	if i < len(subids) {
		subids = subids[0:i]
	}
	return subids, nil
}
func EncGetIdentByteCount(ident uint64) uint64 {
	if ident < (1 << 7) {
		return 1
	} else if ident < (1 << 14) {
		return 2
	} else if ident < (1 << 21) {
		return 3
	} else if ident < (1 << 28) {
		return 4
	}
	return 5
}

// PerEncObjectIdentifier - Encode an OBJECT IDENTIFIER type.
func (pctxt *OSRTContext) PerEncObjectIdentifier(subids []uint64) error {
	var i int
	var length uint64 = 1 /* 1st 2 arcs require 1 byte */
	var numids = len(subids)
	var temp uint64

	/* Calculate length in bytes and encode */
	for i = 2; i < numids; i++ {
		length += EncGetIdentByteCount(subids[i])
	}

	_, stat := pctxt.PerEncUnconsLen(length)
	if stat != nil {
		return stat
	}

	/* Validate given object ID by applying ASN.1 rules */
	if (numids < 2) || (subids[0] > 2) {
		return fmt.Errorf("OID too short or has invalid first subid")
	}
	if (subids[0] != 2) && (subids[1] > 39) {
		return fmt.Errorf("OID has invalid 2nd subid (must be less than 40)")
	}

	/* Munge first two sub ID's and encode */
	temp = (subids[0] * 40) + subids[1]
	stat = pctxt.PerEncIdentifier(temp)
	if stat != nil {
		return stat
	}

	/* Encode the remainder of the OID value */
	for i = 2; i < numids; i++ {
		stat = pctxt.PerEncIdentifier(subids[i])
		if stat != nil {
			return stat
		}
	}

	return nil
}
func (pctxt *OSRTContext) PerDecByteAlign() {
	if pctxt.buffer.bitOffset != 8 {
		pctxt.buffer.bitOffset = 8
		pctxt.buffer.byteIndex++
	}
}
func (pctxt *OSRTContext) PerEncEmbeddedLenStart(aligned bool) (uint64, error) {
	if aligned {
		pctxt.PerEncBufAlign()
	}

	// Encode a zero length byte
	err := pctxt.EncBitsFromByte(0, 8)
	if err != nil {
		return pctxt.BitOffset(), err
	}

	bitidx := pctxt.BitOffset() - 8

	return bitidx, nil
}
func (pctxt *OSRTContext) PerEncEmbeddedLenEnd(bitidx uint64, bitlen bool) error {
	/* lenvalueBits = length of encoded data in bits */
	lenvalueBits := (pctxt.BitOffset() - bitidx - 8)
	lenvalue := lenvalueBits
	if !bitlen {
		lenvalue /= 8 // length in bytes
	}

	//byteIndex after embedded data was encoded.
	savedByteIndex := pctxt.buffer.byteIndex

	/* If fragmented, the number of groups of 16K items the total items
	could be divided into.
	*/
	var num16K uint64 = 0

	/* If fragmented, the number of fragments having 4*16K items. */
	var numMaxFrag uint64 = 0

	/* If fragmented, the multiplier for the last large (>=16384 items)
	fragment.  If 0, there is no fragment having >= 16K items and < 4*16K items.
	*/
	var lastMult uint8 = 0

	/* If fragmented, the number of items in final fragment;
	If not fragmented, just the number of items.
	0 <= lastFrag < 16384.
	*/
	var lastFrag uint64 = 0

	/* If fragmented, the number of bytes we'll be inserting for the
	fragmented lengths. */
	var addBytes uint64 = 0

	/* Value for pctxt.buffer.byteIndex when finished.  It will get pushed out
	by the total number of bytes we insert for lengths. */
	var finishByteIndex = pctxt.buffer.byteIndex

	/* Value for pctxt.buffer.bitOffset when finished.  It will be
	unchanged from what it is now, as we only insert multiples of 8 bits
	for lengths.
	*/
	var finishBitOffset = pctxt.buffer.bitOffset

	/* Bit index at which the next length bytes are to be merged.
	Because the lengths are not necessarily aligned, we have to copy
	the data for both fragments on either side of the length field
	before we merge in the length field. */
	var lengthBitIdx uint64

	/* Slice holding encoding of length.  Its capacity is 2 (the most we'll need),
	and its length will be 1 or 2 depending on whether we have a 1 or 2 byte length.
	*/
	var lengthBytes = []byte{0, 0}

	// Restore context bit offset to where length encoding started
	pctxt.SetBitOffset(bitidx)

	/* aligned is true if the data begins aligned.  Every fragment will
	be aligned, if true.
	*/
	var aligned = pctxt.buffer.bitOffset == 8

	/* beginIndex is the index where first bit of the encoded data is found
	(the first bit after the 1 byte length)
	*/
	beginIndex := pctxt.buffer.byteIndex + 1

	/* partialByte is true if the data includes some bits in the byte
	at index savedByteIndex (the data ends w/o alignment)
	*/
	partialByte := finishBitOffset != 8

	/* srcByteBeginIndex: When doing fragmentation, the source byte
	index of the first byte of the next fragment that we'll copy to its new
	location.
	*/
	var srcByteBeginIndex uint64

	/* srcByteEndIndex: When doing fragmentation, the source byte index
	of the last byte of the next fragment that we'll copy, + 1.
	*/
	var srcByteEndIndex uint64

	/* destIndex: When doing fragmentation, the destination byte index
	of the first byte of the next fragment that we'll copy to its
	new location.
	*/
	var destIndex uint64

	if lenvalue > 16384 {
		/* Fragmentation is required.
		Determine how many fragments of each sort there will be, and how many
		bytes we'll be inserting into the encoding for lengths.
		*/
		num16K = lenvalue / 16384
		lastFrag = lenvalue % 16384
		numMaxFrag = num16K / 4
		lastMult = uint8(num16K % 4)
		addBytes = numMaxFrag //1 byte for each 4*16K fragment
		if lastMult > 0 {
			addBytes += 1 //1 byte for final >=16K fragment
		}
		if lastFrag > 127 {
			addBytes += 1 //final fragment uses 2, not 1, bytes.
		}

		finishByteIndex += addBytes

		/* Make sure pctxt.buffer.data is large enough to hold data after
		fragmentation (i.e. after length bytes are inserted) */

		if cap(pctxt.buffer.data) >= int(savedByteIndex+addBytes) {
			/* Existing underlying array is large enough.  We can reslice
			it to make the slice bigger.
			*/
			pctxt.buffer.data = pctxt.buffer.data[0 : savedByteIndex+addBytes]
		} else {
			/* Create a new array large enough to hold fragmented data,
			and copy all of the original data into it.
			*/
			dest := make([]byte, savedByteIndex+addBytes)
			copy(dest, pctxt.buffer.data)
			pctxt.buffer.data = dest
		}

		/* The initial value for lengthBitIdx is the bit index where the final length
		belongs.  This is:
		bit index of encoded data + # of bits in encoded data + # of bits being added
		for lengths - # of bits for the final length (8 or 16) -
		# of bits in the last fragment (possibly 0).
		*/
		lengthBitIdx = bitidx + 8 + lenvalueBits + addBytes*8 - 8
		if lastFrag > 127 {
			lengthBitIdx -= 8
		}

		/* itemsBefore is the number of items before the last (possibly empty)
		fragment. It is evenly divisible by 8 (by 16384, actually).
		*/
		itemsBefore := lenvalue - lastFrag
		if bitlen {
			bytesBefore := itemsBefore / 8 /* itemsBefore, in bytes */
			srcByteBeginIndex = beginIndex + bytesBefore
			lengthBitIdx -= lastFrag
		} else {
			srcByteBeginIndex = beginIndex + itemsBefore
			lengthBitIdx -= lastFrag * 8
		}

		if partialByte {
			//include savedByteIndex in the copy
			srcByteEndIndex = savedByteIndex + 1
		} else {
			//don't include savedByteIndex in the copy
			srcByteEndIndex = savedByteIndex
		}

		/* The destination index equals the source index plus
		the number of bytes we'll be adding in for lengths.
		*/
		destIndex = srcByteBeginIndex + addBytes

		if lastFrag > 0 {
			src := pctxt.buffer.data[srcByteBeginIndex:srcByteEndIndex]
			dest := pctxt.buffer.data[destIndex:]
			copy(dest, src)
		} //else: nothing to copy
	} else {
		if lenvalue > 127 {
			/* Shift the encoding 1 byte to make room for the 2 byte length.
			This can be done by taking a slice that includes the first byte
			after the reserved length byte, and appending to that the slice that
			begins with the first byte after the reserved byte.
			beginIndex is the byte after the reserved byte.
			*/
			leadingData := pctxt.buffer.data[0 : beginIndex+1]
			pctxt.buffer.data = append(leadingData, pctxt.buffer.data[beginIndex:]...)
			finishByteIndex += 1
		} /* else: no shifting required and the finishByteIndex doesn't need to
		be moved */

		lastFrag = lenvalue
		lengthBitIdx = bitidx
	}

	if lastFrag > 127 {
		/* Set the two byte length for the last (or only) fragment. */
		lengthBytes[0] = byte(0x80) + byte(lastFrag>>8)
		lengthBytes[1] = byte(lastFrag)
	} else {
		/* Set the one byte length for the last (or only) fragment. */
		lengthBytes[0] = byte(lastFrag)
		lengthBytes = lengthBytes[0:1] // 1 byte length
	}

	if lenvalue > 16384 {
		/* Copy the k*16K item fragments to their correct positions */
		var multiplier uint8 /* fragment is multiplier * 16K items */
		var numFrag uint64   /* number of fragments to be copied */
		var unitSize uint64  //size, in bytes, of 16K items

		if bitlen {
			unitSize = 16384 / 8
		} else {
			unitSize = 16384
		}

		if lastMult > 0 {
			multiplier = lastMult
			numFrag = numMaxFrag + 1
		} else {
			multiplier = 4
			numFrag = numMaxFrag
		}

		for i := uint64(0); i < numFrag; i++ {
			/* Copy the data for the fragment.
			First, update the src and dest indexes, backing them up from
			the last fragment we copyied by the size of the fragment we're
			dealing with now.
			*/
			fragSize := uint64(multiplier) * unitSize
			srcByteBeginIndex -= fragSize
			srcByteEndIndex = srcByteBeginIndex + fragSize
			if !aligned {
				srcByteEndIndex += 1
			}
			destIndex = destIndex - (fragSize + uint64(len(lengthBytes)))

			src := pctxt.buffer.data[srcByteBeginIndex:srcByteEndIndex]
			dest := pctxt.buffer.data[destIndex:]
			copy(dest, src)

			/* Merge in the length of the fragment we last copied (not
			the one just copied).
			*/
			var err = pctxt.PerEncMergeBytes(lengthBytes, lengthBitIdx)
			if err != nil {
				return err
			}

			/* Now backup the location for the length field and update the
			length bytes for this fragment.*/
			lengthBitIdx -= (fragSize + 1) * 8 // + 1 for the length itself
			lengthBytes = lengthBytes[0:1]
			lengthBytes[0] = 0xC0 + multiplier

			/* The multiplier needs to be increased to the max value after
			the first pass. */
			multiplier = 4
		}
	}

	/* Merge in the length of the first (or only) fragment */
	var err = pctxt.PerEncMergeBytes(lengthBytes, lengthBitIdx)
	if err != nil {
		return err
	}

	pctxt.buffer.byteIndex = finishByteIndex
	pctxt.buffer.bitOffset = finishBitOffset

	// this is needed to cause the PenEncUnconsLen function to be included
	// pctxt.PerEncUnconsLen(lenvalue)

	return nil
}
func (pctxt *OSRTContext) PerEncOpenType(buf []byte) error {
	return pctxt.PerEncUnconsOctStr(buf)
}
func (pctxt *OSRTContext) PerEncIdentifier(ident uint64) error {
	var lv uint64
	var mask, nshifts uint64
	var stat error

	if ident != 0 {
		nshifts = EncGetIdentByteCount(ident)
		for nshifts > 0 {
			/* avoid mask overflow */
			mask = 0x7f << (7 * (nshifts - 1))
			nshifts--
			lv = (ident & mask) >> (nshifts * 7)
			if nshifts != 0 {
				lv |= 0x80
			}
			stat = pctxt.EncBitsFromByte(byte(lv), 8)
			if stat != nil {
				return stat
			}
		}
	} else {
		/* encode a single zero byte */
		stat = pctxt.EncBitsFromByte(0, 8)
		if stat != nil {
			return stat
		}
	}

	return nil
}
func (pctxt *OSRTContext) PerEncMergeBytes(buf []byte, bitidx uint64) error {
	buflen := uint64(len(buf))
	if buflen == 0 {
		return nil
	}
	byteIndex := uint64(bitidx / 8)
	bitOffset := uint64(8 - (bitidx % 8))
	if bitOffset == 8 {
		// Copy bytes directly into encode buffer
		copy(pctxt.buffer.data[byteIndex:byteIndex+buflen], buf[:buflen])
	} else {
		// Not on byte boundary
		// Merge first byte
		rshift := 8 - bitOffset
		tmp := byte((pctxt.buffer.data[byteIndex] >> bitOffset) << bitOffset)
		tmp2 := buf[0] >> rshift
		pctxt.buffer.data[byteIndex] = byte(tmp | tmp2)
		byteIndex++

		// Merge bytes in middle
		for i := 0; i < len(buf)-1; i++ {
			tmp = byte(buf[i] << bitOffset)
			tmp2 = byte(buf[i+1] >> rshift)
			pctxt.buffer.data[byteIndex] = byte(tmp | tmp2)
			byteIndex++
		}

		// Merge last byte
		tmp = byte(buf[len(buf)-1] << bitOffset)
		tmp2 = byte((pctxt.buffer.data[byteIndex] << rshift) >> rshift)
		pctxt.buffer.data[byteIndex] = byte(tmp | tmp2)
	}
	return nil
}

// DecByte decodes a single byte value
func (pctxt *OSRTContext) DecByte() (value byte, err error) {

	if pctxt.buffer.bitOffset == 8 {
		if pctxt.buffer.byteIndex >= uint64(len(pctxt.buffer.data)) {
			err = fmt.Errorf("DecByte: buffer overflow")
			return
		}

		value = pctxt.buffer.data[pctxt.buffer.byteIndex]
		pctxt.buffer.byteIndex++
	} else {
		var ub uint64
		ub, err = pctxt.PerDecBitsToUInt(8)
		if err != nil {
			err = fmt.Errorf("DecByte: %w", err)
			return
		}
		value = byte(ub)
	}
	return
}

func (pctxt *OSRTContext) PerEnc2sCompBinInt(value int64) error {
	var lbuf [8]byte
	var lb byte
	var i int

	temp := value

	for i = len(lbuf) - 1; i >= 0; i-- {
		lb = byte(temp % 256)
		temp /= 256
		if temp < 0 && lb != 0 {
			temp-- /* two's complement adjustment */
		}
		lbuf[i] = lb
		if temp == 0 || temp == -1 {
			break
		}
	}

	/* If the value is positive and bit 8 of the leading byte is set,    */
	/* copy a zero byte to the contents to signal a positive number..    */

	if value > 0 && (lb&0x80) != 0 {
		i--

	} else if value < 0 && ((lb & 0x80) == 0) {
		/* If the value is negative and bit 8 of the leading byte is clear,  */
		/* copy a -1 byte (0xFF) to the contents to signal a negative        */
		/* number..                                                          */

		i--
		if i >= 0 && i < len(lbuf) {
			lbuf[i] = 0xff
		}
	}

	/* Add the data to the encode buffer */

	return pctxt.EncBytes(lbuf[i:])
}

// PerEncUnconsInt will encode an unconstrained signed integer value.
func (pctxt *OSRTContext) PerEncUnconsInt(value int64) error {
	pctxt.PerEncBufAlign()
	nbytes := getIntLength(value)

	/* Encode length */
	err := pctxt.EncBitsFromByte(byte(nbytes), 8)
	if err != nil {
		return err
	}
	/* Encode signed value */
	err = pctxt.PerEnc2sCompBinInt(value)
	if err != nil {
		return err
	}
	return nil
}

// PerEncUnconsUInt will encode an unconstrained unsigned integer value.
func (pctxt *OSRTContext) PerEncUnconsUInt(value uint64) error {
	/* Encode value as an unconstrained whole number. */

	var mask uint64 = 1 << (bits.UintSize - 1)

	if (value & mask) == 0 {
		/* The most significant bit is 0, we can simply cast to int */
		/* and use PerEncUnconsInt */
		return pctxt.PerEncUnconsInt(int64(value))
	}
	/* The most significant bit is 1.  We can encode this as a 2's
	complement binary integer by encoding the length, a zero byte,
	and then the value. */

	nbytes := uint64(unsafe.Sizeof(value) + 1) /*  + 1 for the leading zero byte */

	/* Encode length */

	err := pctxt.PerEncBitsFromUInt(nbytes, 8)
	if err != nil {
		return err
	}

	/* Encode unsigned value */

	err = pctxt.PerEncBitsFromUInt(0, 8)
	if err != nil {
		return err
	}

	/* Encode the value */
	err = pctxt.PerEncBitsFromUInt(value, bits.UintSize)
	if err != nil {
		return err
	}

	return nil
}

// DiagAdjustBitOffsets finds the first record in the bit field list with
// the given start offset and then adds the delta value to all subsequent
// records. Its primary use is to adjust bit field records after an embedded
// length encoding is done.
func (pctxt *OSRTContext) DiagAdjustBitOffsets(startOffset uint64, delta uint64) {
	if pctxt.pBitFieldList == nil {
		return
	}
	var found bool
	for pNode := pctxt.pBitFieldList.Front(); pNode != nil; pNode = pNode.Next() {
		pField := pNode.Value.(*DiagBitField)
		if found {
			pField.bitOffset += delta
		} else if pField.bitOffset == startOffset {
			found = true
			pField.numbits += delta
		}
	}
}

// DiagNewBitField creates a new bit field and adds it at the end of the
// context bit field list.
// A call to this function is a redundant call if the previous field is at the
// same location and is not closed.  Redundant calls are allowed and ignored;
// calls from within the runtime might in some cases be redundant but not
// in others.
// This function will automatically call DiagSetBitFieldCount for the previous field
// (if there is one), if the previous field is not at the same location. Generally,
// this means explicit calls to DiagSetBitFieldCount are not required.  However,
// calling DiagSetBitFieldCount is required for zero-length bit fields.
func (pctxt *OSRTContext) DiagNewBitField(nameSuffix string) *DiagBitField {
	var pBitField *DiagBitField

	if pctxt.pBitFieldList != nil {
		var pPrevField *DiagBitField
		var collocated = false
		var redundant = false
		if pctxt.pBitFieldList.Len() > 0 {
			pPrevField = pctxt.pBitFieldList.Back().Value.(*DiagBitField)
			collocated = pctxt.BitOffset() == pPrevField.bitOffset
			redundant = collocated && !pPrevField.closed
			if redundant {
				return pPrevField
			} else if !collocated && !pPrevField.closed {
				// Automatically call DiagSetBitFieldCount.  If the previous
				// field was zero-length, the fact that the new field is not
				// collocated implies there were alignment bits added and
				// calling DiagSetBitFieldCount would incorrectly set the
				// bit field size, which is why DiagSetBitFieldCount must be
				// called explicitly for zero-length fields.
				pctxt.DiagSetBitFieldCount()
			}
			//else: !redundant and (collocated || pPrevField.closed) implies field is already closed
		}

		// Not a redundant call.
		pBitField = new(DiagBitField)
		pBitField.elemName = pctxt.ElemName()
		pBitField.nameSuffix = nameSuffix
		pBitField.bitOffset = pctxt.BitOffset()
		//fmt.Printf("DiagNewBitField: bitOffset = %d\n",
		//	pBitField.bitOffset)
		pctxt.pBitFieldList.PushBack(pBitField)
	}
	return pBitField
}

// DiagSetBitFieldOffset set the bit offset within the last bit field
// structure to be the current bit field offset in the context
func (pctxt *OSRTContext) DiagSetBitFieldOffset() {
	if pctxt.pBitFieldList != nil && pctxt.pBitFieldList.Len() > 0 {
		var pField = pctxt.pBitFieldList.Back()
		if pField != nil && pField.Value.(*DiagBitField).numbits == 0 {
			pBitField := pField.Value.(*DiagBitField)
			pBitField.bitOffset = pctxt.BitOffset()
			//fmt.Printf("DiagSetBitFieldOffset: bitOffset = %d\n",
			//	pBitField.bitOffset)
			//pField.Value = DiagBitField
		}
	}
}

// DiagSetBitFieldCount sets the bit field count in the last bit field
// structure to be the difference between the current bit offset and
// the bit offset in the previous bit field structure.
func (pctxt *OSRTContext) DiagSetBitFieldCount() {
	if pctxt.pBitFieldList != nil && pctxt.pBitFieldList.Len() > 0 {
		var pField = pctxt.pBitFieldList.Back().Value.(*DiagBitField)
		pField.closed = true
		if pField.numbits == 0 {
			pField.numbits = pctxt.BitOffset() - pField.bitOffset
		}
	}
}

func (buf *diagBinDumpBuffer) init(currBitOffset uint64) {
	buf.fmtBitBuffer = ""
	buf.fmtHexBuffer = ""
	buf.fmtAscBuffer = ""
	buf.lastBitBuffer = ""
	buf.repeatCount = 0

	//fmt.Printf("currBitOffset = %d\n", currBitOffset)
	fillerLen := currBitOffset % 32
	if fillerLen > 0 {
		for i := uint64(0); i < fillerLen; i++ {
			if i > 0 && i%8 == 0 {
				buf.fmtBitBuffer += " -"
				buf.fmtHexBuffer += "--"
				buf.fmtAscBuffer += "-"
			} else {
				buf.fmtBitBuffer += "-"
			}
		}
		if fillerLen%8 == 0 {
			buf.fmtBitBuffer += " "
			buf.fmtHexBuffer += "--"
			buf.fmtAscBuffer += "-"
		}
	}
}

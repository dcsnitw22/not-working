// Package asn1gen - ASN1C generated code package
/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (https://obj-sys.com).  Version: 7.7.2, Date: 05-Feb-2024.
 *
 * Copyright (c) 2020-2023 Objective Systems, Inc.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Objective Systems, Inc.
 *
 * PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not
 * indicate any actual or intended publication of such source code.
 *
 * Command:  asn1c /home/imgadmin/asn1c-v772/golang/sample_per/ngap/ngap.asn -i /home/imgadmin/asn1c-v772/golang/sample_per/ngap -o src -oh src -genprint -genprttostr -gentest -aper -go -genmake src/makefile -prjdir ../ngap
 *
 **************************************************************************/
package asn1gen

import (
	"w5gc.io/wipro5gcore/pkg/amf/ngap/asn1gen/asn1rt"
)

/*
	NGSetupRequest ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type NGSetupRequest struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	NGSetupResponse ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type NGSetupResponse struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	NGSetupFailure ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type NGSetupFailure struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	NGReset ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type NGReset struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	NGResetAcknowledge ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type NGResetAcknowledge struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	ErrorIndication ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type ErrorIndication struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	PDUSessionResourceSetupRequest ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type PDUSessionResourceSetupRequest struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	PDUSessionResourceSetupResponse ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type PDUSessionResourceSetupResponse struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	PDUSessionResourceReleaseCommand ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type PDUSessionResourceReleaseCommand struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	PDUSessionResourceReleaseResponse ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type PDUSessionResourceReleaseResponse struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	InitialContextSetupRequest ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type InitialContextSetupRequest struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	InitialContextSetupResponse ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type InitialContextSetupResponse struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	InitialContextSetupFailure ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type InitialContextSetupFailure struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

// PerDecode method implementation
func (pvalue *NGSetupRequest) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NGSetupRequest) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NGSetupResponse) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NGSetupResponse) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NGSetupFailure) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NGSetupFailure) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

/*
	InitialUEMessage ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type InitialUEMessage struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	DownlinkNASTransport ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type DownlinkNASTransport struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	UplinkNASTransport ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type UplinkNASTransport struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	NASNonDeliveryIndication ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type NASNonDeliveryIndication struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

// PerDecode method implementation
func (pvalue *InitialUEMessage) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *InitialUEMessage) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *DownlinkNASTransport) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *DownlinkNASTransport) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UplinkNASTransport) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UplinkNASTransport) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NASNonDeliveryIndication) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NASNonDeliveryIndication) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NGReset) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NGReset) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NGResetAcknowledge) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NGResetAcknowledge) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupRequest) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupRequest) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupResponse) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupResponse) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceReleaseCommand) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceReleaseCommand) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceReleaseResponse) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceReleaseResponse) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ErrorIndication) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *ErrorIndication) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *InitialContextSetupRequest) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *InitialContextSetupRequest) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *InitialContextSetupResponse) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *InitialContextSetupResponse) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *InitialContextSetupFailure) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *InitialContextSetupFailure) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

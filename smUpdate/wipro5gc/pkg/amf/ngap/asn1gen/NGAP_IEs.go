// Package asn1gen - ASN1C generated code package
/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (https://obj-sys.com).  Version: 7.7.2, Date: 05-Feb-2024.
 *
 * Copyright (c) 2020-2023 Objective Systems, Inc.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Objective Systems, Inc.
 *
 * PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not
 * indicate any actual or intended publication of such source code.
 *
 * Command:  asn1c /home/imgadmin/asn1c-v772/golang/sample_per/ngap/ngap.asn -i /home/imgadmin/asn1c-v772/golang/sample_per/ngap -o src -oh src -genprint -genprttostr -gentest -aper -go -genmake src/makefile -prjdir ../ngap
 *
 **************************************************************************/
package asn1gen

import (
	"w5gc.io/wipro5gcore/pkg/amf/ngap/asn1gen/asn1rt"
)

/*
AMFName ::= PrintableString (SIZE (1..150, ...))
*/
type AMFName string

/*
AMFPointer ::= BIT STRING  (SIZE (6))
*/
type AMFPointer asn1rt.BitString

/*
AMFRegionID ::= BIT STRING  (SIZE (8))
*/
type AMFRegionID asn1rt.BitString

/*
AMFSetID ::= BIT STRING  (SIZE (10))
*/
type AMFSetID asn1rt.BitString

/*
AMF-UE-NGAP-ID ::= INTEGER (0..1099511627775)
*/
type AMFUENGAPID uint64

/*
BitRate ::= INTEGER (0..4000000000000, ...)
*/
type BitRate uint64

/*
CauseMisc ::= ENUMERATED { control-processing-overload(0), not-enough-user-plane-processing-resources(1), hardware-failure(2), om-intervention(3), unknown-PLMN(4), unspecified(5), ... }
*/
type CauseMisc uint64

const (
	CauseMiscControlProcessingOverload             = 0
	CauseMiscNotEnoughUserPlaneProcessingResources = 1
	CauseMiscHardwareFailure                       = 2
	CauseMiscOmIntervention                        = 3
	CauseMiscUnknownPLMN                           = 4
	CauseMiscUnspecified                           = 5
	CauseMiscUNKNOWN                               = 6
)

/*
CauseNas ::= ENUMERATED { normal-release(0), authentication-failure(1), deregister(2), unspecified(3), ... }
*/
type CauseNas uint64

const (
	CauseNasNormalRelease         = 0
	CauseNasAuthenticationFailure = 1
	CauseNasDeregister            = 2
	CauseNasUnspecified           = 3
	CauseNasUNKNOWN               = 4
)

/*
CauseProtocol ::= ENUMERATED { transfer-syntax-error(0), abstract-syntax-error-reject(1), abstract-syntax-error-ignore-and-notify(2), message-not-compatible-with-receiver-state(3), semantic-error(4), abstract-syntax-error-falsely-constructed-message(5), unspecified(6), ... }
*/
type CauseProtocol uint64

const (
	CauseProtocolTransferSyntaxError                          = 0
	CauseProtocolAbstractSyntaxErrorReject                    = 1
	CauseProtocolAbstractSyntaxErrorIgnoreAndNotify           = 2
	CauseProtocolMessageNotCompatibleWithReceiverState        = 3
	CauseProtocolSemanticError                                = 4
	CauseProtocolAbstractSyntaxErrorFalselyConstructedMessage = 5
	CauseProtocolUnspecified                                  = 6
	CauseProtocolUNKNOWN                                      = 7
)

/*
CauseRadioNetwork ::= ENUMERATED { unspecified(0), txnrelocoverall-expiry(1), successful-handover(2), release-due-to-ngran-generated-reason(3), release-due-to-5gc-generated-reason(4), handover-cancelled(5), partial-handover(6), ho-failure-in-target-5GC-ngran-node-or-target-system(7), ho-target-not-allowed(8), tngrelocoverall-expiry(9), tngrelocprep-expiry(10), cell-not-available(11), unknown-targetID(12), no-radio-resources-available-in-target-cell(13), unknown-local-UE-NGAP-ID(14), inconsistent-remote-UE-NGAP-ID(15), handover-desirable-for-radio-reason(16), time-critical-handover(17), resource-optimisation-handover(18), reduce-load-in-serving-cell(19), user-inactivity(20), radio-connection-with-ue-lost(21), radio-resources-not-available(22), invalid-qos-combination(23), failure-in-radio-interface-procedure(24), interaction-with-other-procedure(25), unknown-PDU-session-ID(26), unkown-qos-flow-ID(27), multiple-PDU-session-ID-instances(28), multiple-qos-flow-ID-instances(29), encryption-and-or-integrity-protection-algorithms-not-supported(30), ng-intra-system-handover-triggered(31), ng-inter-system-handover-triggered(32), xn-handover-triggered(33), not-supported-5QI-value(34), ue-context-transfer(35), ims-voice-eps-fallback-or-rat-fallback-triggered(36), up-integrity-protection-not-possible(37), up-confidentiality-protection-not-possible(38), slice-not-supported(39), ue-in-rrc-inactive-state-not-reachable(40), redirection(41), resources-not-available-for-the-slice(42), ue-max-integrity-protected-data-rate-reason(43), release-due-to-cn-detected-mobility(44), ..., n26-interface-not-available(45), release-due-to-pre-emption(46), multiple-location-reporting-reference-ID-instances(47) }
*/
type CauseRadioNetwork uint64

const (
	CauseRadioNetworkUnspecified                                              = 0
	CauseRadioNetworkTxnrelocoverallExpiry                                    = 1
	CauseRadioNetworkSuccessfulHandover                                       = 2
	CauseRadioNetworkReleaseDueToNgranGeneratedReason                         = 3
	CauseRadioNetworkReleaseDueTo5gcGeneratedReason                           = 4
	CauseRadioNetworkHandoverCancelled                                        = 5
	CauseRadioNetworkPartialHandover                                          = 6
	CauseRadioNetworkHoFailureInTarget5GCNgranNodeOrTargetSystem              = 7
	CauseRadioNetworkHoTargetNotAllowed                                       = 8
	CauseRadioNetworkTngrelocoverallExpiry                                    = 9
	CauseRadioNetworkTngrelocprepExpiry                                       = 10
	CauseRadioNetworkCellNotAvailable                                         = 11
	CauseRadioNetworkUnknownTargetID                                          = 12
	CauseRadioNetworkNoRadioResourcesAvailableInTargetCell                    = 13
	CauseRadioNetworkUnknownLocalUENGAPID                                     = 14
	CauseRadioNetworkInconsistentRemoteUENGAPID                               = 15
	CauseRadioNetworkHandoverDesirableForRadioReason                          = 16
	CauseRadioNetworkTimeCriticalHandover                                     = 17
	CauseRadioNetworkResourceOptimisationHandover                             = 18
	CauseRadioNetworkReduceLoadInServingCell                                  = 19
	CauseRadioNetworkUserInactivity                                           = 20
	CauseRadioNetworkRadioConnectionWithUeLost                                = 21
	CauseRadioNetworkRadioResourcesNotAvailable                               = 22
	CauseRadioNetworkInvalidQosCombination                                    = 23
	CauseRadioNetworkFailureInRadioInterfaceProcedure                         = 24
	CauseRadioNetworkInteractionWithOtherProcedure                            = 25
	CauseRadioNetworkUnknownPDUSessionID                                      = 26
	CauseRadioNetworkUnkownQosFlowID                                          = 27
	CauseRadioNetworkMultiplePDUSessionIDInstances                            = 28
	CauseRadioNetworkMultipleQosFlowIDInstances                               = 29
	CauseRadioNetworkEncryptionAndOrIntegrityProtectionAlgorithmsNotSupported = 30
	CauseRadioNetworkNgIntraSystemHandoverTriggered                           = 31
	CauseRadioNetworkNgInterSystemHandoverTriggered                           = 32
	CauseRadioNetworkXnHandoverTriggered                                      = 33
	CauseRadioNetworkNotSupported5QIValue                                     = 34
	CauseRadioNetworkUeContextTransfer                                        = 35
	CauseRadioNetworkImsVoiceEpsFallbackOrRatFallbackTriggered                = 36
	CauseRadioNetworkUpIntegrityProtectionNotPossible                         = 37
	CauseRadioNetworkUpConfidentialityProtectionNotPossible                   = 38
	CauseRadioNetworkSliceNotSupported                                        = 39
	CauseRadioNetworkUeInRrcInactiveStateNotReachable                         = 40
	CauseRadioNetworkRedirection                                              = 41
	CauseRadioNetworkResourcesNotAvailableForTheSlice                         = 42
	CauseRadioNetworkUeMaxIntegrityProtectedDataRateReason                    = 43
	CauseRadioNetworkReleaseDueToCnDetectedMobility                           = 44
	CauseRadioNetworkN26InterfaceNotAvailable                                 = 45
	CauseRadioNetworkReleaseDueToPreEmption                                   = 46
	CauseRadioNetworkMultipleLocationReportingReferenceIDInstances            = 47
	CauseRadioNetworkUNKNOWN                                                  = 48
)

/*
CauseTransport ::= ENUMERATED { transport-resource-unavailable(0), unspecified(1), ... }
*/
type CauseTransport uint64

const (
	CauseTransportTransportResourceUnavailable = 0
	CauseTransportUnspecified                  = 1
	CauseTransportUNKNOWN                      = 2
)

/*
EUTRACellIdentity ::= BIT STRING  (SIZE (28))
*/
type EUTRACellIdentity asn1rt.BitString

/*
FiveG-TMSI ::= OCTET STRING (SIZE (4))
*/
type FiveGTMSI asn1rt.OctetString

/*
IndexToRFSP ::= INTEGER (1..256, ...)
*/
type IndexToRFSP uint64

/*
NAS-PDU ::= OCTET STRING
*/
type NASPDU asn1rt.OctetString

/*
NRCellIdentity ::= BIT STRING  (SIZE (36))
*/
type NRCellIdentity asn1rt.BitString

/*
NRencryptionAlgorithms ::= BIT STRING  (SIZE (16, ...))
*/
type NRencryptionAlgorithms asn1rt.BitString

/*
NRintegrityProtectionAlgorithms ::= BIT STRING  (SIZE (16, ...))
*/
type NRintegrityProtectionAlgorithms asn1rt.BitString

/*
PagingDRX ::= ENUMERATED { v32(0), v64(1), v128(2), v256(3), ... }
*/
type PagingDRX uint64

const (
	PagingDRXV32     = 0
	PagingDRXV64     = 1
	PagingDRXV128    = 2
	PagingDRXV256    = 3
	PagingDRXUNKNOWN = 4
)

/*
PLMNIdentity ::= OCTET STRING (SIZE (3))
*/
type PLMNIdentity asn1rt.OctetString

/*
PortNumber ::= OCTET STRING (SIZE (2))
*/
type PortNumber asn1rt.OctetString

/*
RANNodeName ::= PrintableString (SIZE (1..150, ...))
*/
type RANNodeName string

/*
RANPagingPriority ::= INTEGER (1..256)
*/
type RANPagingPriority uint64

/*
RAN-UE-NGAP-ID ::= INTEGER (0..4294967295)
*/
type RANUENGAPID uint64

/*
RATRestrictionInformation ::= BIT STRING  (SIZE (8, ...))
*/
type RATRestrictionInformation asn1rt.BitString

/*
RedirectionVoiceFallback ::= ENUMERATED { possible(0), not-possible(1), ... }
*/
type RedirectionVoiceFallback uint64

const (
	RedirectionVoiceFallbackPossible    = 0
	RedirectionVoiceFallbackNotPossible = 1
	RedirectionVoiceFallbackUNKNOWN     = 2
)

/*
RelativeAMFCapacity ::= INTEGER (0..255)
*/
type RelativeAMFCapacity uint64

/*
RRCEstablishmentCause ::= ENUMERATED { emergency(0), highPriorityAccess(1), mt-Access(2), mo-Signalling(3), mo-Data(4), mo-VoiceCall(5), mo-VideoCall(6), mo-SMS(7), mps-PriorityAccess(8), mcs-PriorityAccess(9), ..., notAvailable(10) }
*/
type RRCEstablishmentCause uint64

const (
	RRCEstablishmentCauseEmergency          = 0
	RRCEstablishmentCauseHighPriorityAccess = 1
	RRCEstablishmentCauseMtAccess           = 2
	RRCEstablishmentCauseMoSignalling       = 3
	RRCEstablishmentCauseMoData             = 4
	RRCEstablishmentCauseMoVoiceCall        = 5
	RRCEstablishmentCauseMoVideoCall        = 6
	RRCEstablishmentCauseMoSMS              = 7
	RRCEstablishmentCauseMpsPriorityAccess  = 8
	RRCEstablishmentCauseMcsPriorityAccess  = 9
	RRCEstablishmentCauseNotAvailable       = 10
	RRCEstablishmentCauseUNKNOWN            = 11
)

/*
SD ::= OCTET STRING (SIZE (3))
*/
type SD asn1rt.OctetString

/*
SecurityKey ::= BIT STRING  (SIZE (256))
*/
type SecurityKey asn1rt.BitString

/*
SourceOfUEActivityBehaviourInformation ::= ENUMERATED { subscription-information(0), statistics(1), ... }
*/
type SourceOfUEActivityBehaviourInformation uint64

const (
	SourceOfUEActivityBehaviourInformationSubscriptionInformation = 0
	SourceOfUEActivityBehaviourInformationStatistics              = 1
	SourceOfUEActivityBehaviourInformationUNKNOWN                 = 2
)

/*
ConfiguredNSSAI ::= OCTET STRING (SIZE (128))
*/
type ConfiguredNSSAI asn1rt.OctetString

/*
RejectedNSSAIinPLMN ::= OCTET STRING (SIZE (32))
*/
type RejectedNSSAIinPLMN asn1rt.OctetString

/*
RejectedNSSAIinTA ::= OCTET STRING (SIZE (32))
*/
type RejectedNSSAIinTA asn1rt.OctetString

/*
SST ::= OCTET STRING (SIZE (1))
*/
type SST asn1rt.OctetString

/*
TAC ::= OCTET STRING (SIZE (3))
*/
type TAC asn1rt.OctetString

/*
TraceDepth ::= ENUMERATED { minimum(0), medium(1), maximum(2), minimumWithoutVendorSpecificExtension(3), mediumWithoutVendorSpecificExtension(4), maximumWithoutVendorSpecificExtension(5), ... }
*/
type TraceDepth uint64

const (
	TraceDepthMinimum                               = 0
	TraceDepthMedium                                = 1
	TraceDepthMaximum                               = 2
	TraceDepthMinimumWithoutVendorSpecificExtension = 3
	TraceDepthMediumWithoutVendorSpecificExtension  = 4
	TraceDepthMaximumWithoutVendorSpecificExtension = 5
	TraceDepthUNKNOWN                               = 6
)

/*
TimeStamp ::= OCTET STRING (SIZE (4))
*/
type TimeStamp asn1rt.OctetString

/*
TimeToWait ::= ENUMERATED { v1s(0), v2s(1), v5s(2), v10s(3), v20s(4), v60s(5), ... }
*/
type TimeToWait uint64

const (
	TimeToWaitV1s     = 0
	TimeToWaitV2s     = 1
	TimeToWaitV5s     = 2
	TimeToWaitV10s    = 3
	TimeToWaitV20s    = 4
	TimeToWaitV60s    = 5
	TimeToWaitUNKNOWN = 6
)

/*
TransportLayerAddress ::= BIT STRING  (SIZE (1..160, ...))
*/
type TransportLayerAddress asn1rt.BitString

/*
TypeOfError ::= ENUMERATED { not-understood(0), missing(1), ... }
*/
type TypeOfError uint64

const (
	TypeOfErrorNotUnderstood = 0
	TypeOfErrorMissing       = 1
	TypeOfErrorUNKNOWN       = 2
)

/*
UERadioCapability ::= OCTET STRING
*/
type UERadioCapability asn1rt.OctetString

/*
UERadioCapabilityForPagingOfNR ::= OCTET STRING
*/
type UERadioCapabilityForPagingOfNR asn1rt.OctetString

/*
UERadioCapabilityForPagingOfEUTRA ::= OCTET STRING
*/
type UERadioCapabilityForPagingOfEUTRA asn1rt.OctetString

/*
UERetentionInformation ::= ENUMERATED { ues-retained(0), ... }
*/
type UERetentionInformation uint64

const (
	UERetentionInformationUesRetained = 0
	UERetentionInformationUNKNOWN     = 1
)

/*
	S-NSSAI ::= SEQUENCE {
		sST [0] SST,
		sD [1] SD OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type SNSSAI struct {
	SST          SST
	SD           *SD
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	AllowedNSSAI-Item ::= SEQUENCE {
		s-NSSAI [0] S-NSSAI,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AllowedNSSAIItem struct {
	SNSSAI       SNSSAI
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
AllowedNSSAI ::= SEQUENCE (SIZE (1..maxnoofAllowedS-NSSAIs)) OF AllowedNSSAI-Item
*/
type AllowedNSSAI []AllowedNSSAIItem

/*
AllowedTACs ::= SEQUENCE (SIZE (1..maxnoofAllowedAreas)) OF TAC
*/
type AllowedTACs []TAC

/*
	SliceSupportItem ::= SEQUENCE {
		s-NSSAI [0] S-NSSAI,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type SliceSupportItem struct {
	SNSSAI       SNSSAI
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
SliceSupportList ::= SEQUENCE (SIZE (1..maxnoofSliceItems)) OF SliceSupportItem
*/
type SliceSupportList []SliceSupportItem

/*
	BroadcastPLMNItem ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		tAISliceSupportList [1] SliceSupportList,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type BroadcastPLMNItem struct {
	PLMNIdentity        PLMNIdentity
	TAISliceSupportList SliceSupportList
	IEExtensions        ProtocolExtensionContainer
	ExtElem1            [][]byte
}

/*
BroadcastPLMNList ::= SEQUENCE (SIZE (1..maxnoofBPLMNs)) OF BroadcastPLMNItem
*/
type BroadcastPLMNList []BroadcastPLMNItem

/*
Cause ::= CHOICE {
	radioNetwork [0] CauseRadioNetwork,
	transport [1] CauseTransport,
	nas [2] CauseNas,
	protocol [3] CauseProtocol,
	misc [4] CauseMisc,
	choice-Extensions [5] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	CauseRadioNetworkTAG     = 1
	CauseTransportTAG        = 2
	CauseNasTAG              = 3
	CauseProtocolTAG         = 4
	CauseMiscTAG             = 5
	CauseChoiceExtensionsTAG = 6
)

type Cause struct {
	T uint64
	U struct {
		RadioNetwork     *CauseRadioNetwork
		Transport        *CauseTransport
		Nas              *CauseNas
		Protocol         *CauseProtocol
		Misc             *CauseMisc
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	CriticalityDiagnostics-IE-Item ::= SEQUENCE {
		iECriticality [0] Criticality,
		iE-ID [1] ProtocolIE-ID,
		typeOfError [2] TypeOfError,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type CriticalityDiagnosticsIEItem struct {
	IECriticality Criticality
	IEID          ProtocolIEID
	TypeOfError   TypeOfError
	IEExtensions  ProtocolExtensionContainer
	ExtElem1      [][]byte
}

/*
CriticalityDiagnostics-IE-List ::= SEQUENCE (SIZE (1..maxnoofErrors)) OF CriticalityDiagnostics-IE-Item
*/
type CriticalityDiagnosticsIEList []CriticalityDiagnosticsIEItem

/*
	CriticalityDiagnostics ::= SEQUENCE {
		procedureCode [0] ProcedureCode OPTIONAL,
		triggeringMessage [1] TriggeringMessage OPTIONAL,
		procedureCriticality [2] Criticality OPTIONAL,
		iEsCriticalityDiagnostics [3] CriticalityDiagnostics-IE-List OPTIONAL,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type CriticalityDiagnostics struct {
	ProcedureCode             *ProcedureCode
	TriggeringMessage         *TriggeringMessage
	ProcedureCriticality      *Criticality
	IEsCriticalityDiagnostics CriticalityDiagnosticsIEList
	IEExtensions              ProtocolExtensionContainer
	ExtElem1                  [][]byte
}

/*
EquivalentPLMNs ::= SEQUENCE (SIZE (1..maxnoofEPLMNs)) OF PLMNIdentity
*/
type EquivalentPLMNs []PLMNIdentity

/*
	EUTRA-CGI ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		eUTRACellIdentity [1] EUTRACellIdentity,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type EUTRACGI struct {
	PLMNIdentity      PLMNIdentity
	EUTRACellIdentity EUTRACellIdentity
	IEExtensions      ProtocolExtensionContainer
	ExtElem1          [][]byte
}

/*
NGRAN-CGI ::= CHOICE {
	nR-CGI [0] NR-CGI,
	eUTRA-CGI [1] EUTRA-CGI,
	choice-Extensions [2] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	NGRANCGINRCGITAG            = 1
	NGRANCGIEUTRACGITAG         = 2
	NGRANCGIChoiceExtensionsTAG = 3
)

type NGRANCGI struct {
	T uint64
	U struct {
		NRCGI            *NRCGI
		EUTRACGI         *EUTRACGI
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	AreaOfInterestCellItem ::= SEQUENCE {
		nGRAN-CGI [0] EXPLICIT NGRAN-CGI,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AreaOfInterestCellItem struct {
	NGRANCGI     NGRANCGI
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
AreaOfInterestCellList ::= SEQUENCE (SIZE (1..maxnoofCellinAoI)) OF AreaOfInterestCellItem
*/
type AreaOfInterestCellList []AreaOfInterestCellItem

/*
	FiveG-S-TMSI ::= SEQUENCE {
		aMFSetID [0] AMFSetID,
		aMFPointer [1] AMFPointer,
		fiveG-TMSI [2] FiveG-TMSI,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type FiveGSTMSI struct {
	AMFSetID     AMFSetID
	AMFPointer   AMFPointer
	FiveGTMSI    FiveGTMSI
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
ForbiddenTACs ::= SEQUENCE (SIZE (1..maxnoofForbTACs)) OF TAC
*/
type ForbiddenTACs []TAC

/*
	ForbiddenAreaInformation-Item ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		forbiddenTACs [1] ForbiddenTACs,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type ForbiddenAreaInformationItem struct {
	PLMNIdentity  PLMNIdentity
	ForbiddenTACs ForbiddenTACs
	IEExtensions  ProtocolExtensionContainer
	ExtElem1      [][]byte
}

/*
ForbiddenAreaInformation ::= SEQUENCE (SIZE (1..maxnoofEPLMNsPlusOne)) OF ForbiddenAreaInformation-Item
*/
type ForbiddenAreaInformation []ForbiddenAreaInformationItem

/*
GNB-ID ::= CHOICE {
	gNB-ID [0] BIT STRING  (SIZE (22..32)),
	choice-Extensions [1] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	GNBIDGNBIDTAG            = 1
	GNBIDChoiceExtensionsTAG = 2
)

type GNBID struct {
	T uint64
	U struct {
		GNBID            *asn1rt.BitString
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	GlobalGNB-ID ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		gNB-ID [1] EXPLICIT GNB-ID,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type GlobalGNBID struct {
	PLMNIdentity PLMNIdentity
	GNBID        GNBID
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
N3IWF-ID ::= CHOICE {
	n3IWF-ID [0] BIT STRING  (SIZE (16)),
	choice-Extensions [1] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	N3IWFIDN3IWFIDTAG          = 1
	N3IWFIDChoiceExtensionsTAG = 2
)

type N3IWFID struct {
	T uint64
	U struct {
		N3IWFID          *asn1rt.BitString
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	GlobalN3IWF-ID ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		n3IWF-ID [1] EXPLICIT N3IWF-ID,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type GlobalN3IWFID struct {
	PLMNIdentity PLMNIdentity
	N3IWFID      N3IWFID
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
NgENB-ID ::= CHOICE {
	macroNgENB-ID [0] BIT STRING  (SIZE (20)),
	shortMacroNgENB-ID [1] BIT STRING  (SIZE (18)),
	longMacroNgENB-ID [2] BIT STRING  (SIZE (21)),
	choice-Extensions [3] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	NgENBIDMacroNgENBIDTAG      = 1
	NgENBIDShortMacroNgENBIDTAG = 2
	NgENBIDLongMacroNgENBIDTAG  = 3
	NgENBIDChoiceExtensionsTAG  = 4
)

type NgENBID struct {
	T uint64
	U struct {
		MacroNgENBID      *asn1rt.BitString
		ShortMacroNgENBID *asn1rt.BitString
		LongMacroNgENBID  *asn1rt.BitString
		ChoiceExtensions  *ProtocolIESingleContainer
	}
}

/*
	GlobalNgENB-ID ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		ngENB-ID [1] EXPLICIT NgENB-ID,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type GlobalNgENBID struct {
	PLMNIdentity PLMNIdentity
	NgENBID      NgENBID
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
GlobalRANNodeID ::= CHOICE {
	globalGNB-ID [0] GlobalGNB-ID,
	globalNgENB-ID [1] GlobalNgENB-ID,
	globalN3IWF-ID [2] GlobalN3IWF-ID,
	choice-Extensions [3] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	GlobalRANNodeIDGlobalGNBIDTAG      = 1
	GlobalRANNodeIDGlobalNgENBIDTAG    = 2
	GlobalRANNodeIDGlobalN3IWFIDTAG    = 3
	GlobalRANNodeIDChoiceExtensionsTAG = 4
)

type GlobalRANNodeID struct {
	T uint64
	U struct {
		GlobalGNBID      *GlobalGNBID
		GlobalNgENBID    *GlobalNgENBID
		GlobalN3IWFID    *GlobalN3IWFID
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	AreaOfInterestRANNodeItem ::= SEQUENCE {
		globalRANNodeID [0] EXPLICIT GlobalRANNodeID,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AreaOfInterestRANNodeItem struct {
	GlobalRANNodeID GlobalRANNodeID
	IEExtensions    ProtocolExtensionContainer
	ExtElem1        [][]byte
}

/*
AreaOfInterestRANNodeList ::= SEQUENCE (SIZE (1..maxnoofRANNodeinAoI)) OF AreaOfInterestRANNodeItem
*/
type AreaOfInterestRANNodeList []AreaOfInterestRANNodeItem

/*
	AreaOfInterest ::= SEQUENCE {
		areaOfInterestTAIList [0] AreaOfInterestTAIList OPTIONAL,
		areaOfInterestCellList [1] AreaOfInterestCellList OPTIONAL,
		areaOfInterestRANNodeList [2] AreaOfInterestRANNodeList OPTIONAL,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AreaOfInterest struct {
	AreaOfInterestTAIList     AreaOfInterestTAIList
	AreaOfInterestCellList    AreaOfInterestCellList
	AreaOfInterestRANNodeList AreaOfInterestRANNodeList
	IEExtensions              ProtocolExtensionContainer
	ExtElem1                  [][]byte
}

/*
	AreaOfInterestItem ::= SEQUENCE {
		areaOfInterest [0] AreaOfInterest,
		locationReportingReferenceID [1] LocationReportingReferenceID,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AreaOfInterestItem struct {
	AreaOfInterest               AreaOfInterest
	LocationReportingReferenceID LocationReportingReferenceID
	IEExtensions                 ProtocolExtensionContainer
	ExtElem1                     [][]byte
}

/*
AreaOfInterestList ::= SEQUENCE (SIZE (1..maxnoofAoI)) OF AreaOfInterestItem
*/
type AreaOfInterestList []AreaOfInterestItem

/*
	GUAMI ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		aMFRegionID [1] AMFRegionID,
		aMFSetID [2] AMFSetID,
		aMFPointer [3] AMFPointer,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type GUAMI struct {
	PLMNIdentity PLMNIdentity
	AMFRegionID  AMFRegionID
	AMFSetID     AMFSetID
	AMFPointer   AMFPointer
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	LocationReportingRequestType ::= SEQUENCE {
		eventType [0] EventType,
		reportArea [1] ReportArea,
		areaOfInterestList [2] AreaOfInterestList OPTIONAL,
		locationReportingReferenceIDToBeCancelled [3] LocationReportingReferenceID OPTIONAL,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type LocationReportingRequestType struct {
	EventType                                 EventType
	ReportArea                                ReportArea
	AreaOfInterestList                        AreaOfInterestList
	LocationReportingReferenceIDToBeCancelled *LocationReportingReferenceID
	IEExtensions                              ProtocolExtensionContainer
	ExtElem1                                  [][]byte
}

/*
	RATRestrictions-Item ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		rATRestrictionInformation [1] RATRestrictionInformation,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type RATRestrictionsItem struct {
	PLMNIdentity              PLMNIdentity
	RATRestrictionInformation RATRestrictionInformation
	IEExtensions              ProtocolExtensionContainer
	ExtElem1                  [][]byte
}

/*
RATRestrictions ::= SEQUENCE (SIZE (1..maxnoofEPLMNsPlusOne)) OF RATRestrictions-Item
*/
type RATRestrictions []RATRestrictionsItem

/*
NotAllowedTACs ::= SEQUENCE (SIZE (1..maxnoofAllowedAreas)) OF TAC
*/
type NotAllowedTACs []TAC

/*
	ServedGUAMIItem ::= SEQUENCE {
		gUAMI [0] GUAMI,
		backupAMFName [1] AMFName OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type ServedGUAMIItem struct {
	GUAMI         GUAMI
	BackupAMFName *AMFName
	IEExtensions  ProtocolExtensionContainer
	ExtElem1      [][]byte
}

/*
ServedGUAMIList ::= SEQUENCE (SIZE (1..maxnoofServedGUAMIs)) OF ServedGUAMIItem
*/
type ServedGUAMIList []ServedGUAMIItem

/*
	PLMNSupportItem ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		sliceSupportList [1] SliceSupportList,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PLMNSupportItem struct {
	PLMNIdentity     PLMNIdentity
	SliceSupportList SliceSupportList
	IEExtensions     ProtocolExtensionContainer
	ExtElem1         [][]byte
}

/*
PLMNSupportList ::= SEQUENCE (SIZE (1..maxnoofPLMNs)) OF PLMNSupportItem
*/
type PLMNSupportList []PLMNSupportItem

/*
	SupportedTAItem ::= SEQUENCE {
		tAC [0] TAC,
		broadcastPLMNList [1] BroadcastPLMNList,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type SupportedTAItem struct {
	TAC               TAC
	BroadcastPLMNList BroadcastPLMNList
	IEExtensions      ProtocolExtensionContainer
	ExtElem1          [][]byte
}

/*
SupportedTAList ::= SEQUENCE (SIZE (1..maxnoofTACs)) OF SupportedTAItem
*/
type SupportedTAList []SupportedTAItem

/*
	ServiceAreaInformation-Item ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		allowedTACs [1] AllowedTACs OPTIONAL,
		notAllowedTACs [2] NotAllowedTACs OPTIONAL,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type ServiceAreaInformationItem struct {
	PLMNIdentity   PLMNIdentity
	AllowedTACs    AllowedTACs
	NotAllowedTACs NotAllowedTACs
	IEExtensions   ProtocolExtensionContainer
	ExtElem1       [][]byte
}

/*
ServiceAreaInformation ::= SEQUENCE (SIZE (1..maxnoofEPLMNsPlusOne)) OF ServiceAreaInformation-Item
*/
type ServiceAreaInformation []ServiceAreaInformationItem

/*
	MobilityRestrictionList ::= SEQUENCE {
		servingPLMN [0] PLMNIdentity,
		equivalentPLMNs [1] EquivalentPLMNs OPTIONAL,
		rATRestrictions [2] RATRestrictions OPTIONAL,
		forbiddenAreaInformation [3] ForbiddenAreaInformation OPTIONAL,
		serviceAreaInformation [4] ServiceAreaInformation OPTIONAL,
		iE-Extensions [5] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type MobilityRestrictionList struct {
	ServingPLMN              PLMNIdentity
	EquivalentPLMNs          EquivalentPLMNs
	RATRestrictions          RATRestrictions
	ForbiddenAreaInformation ForbiddenAreaInformation
	ServiceAreaInformation   ServiceAreaInformation
	IEExtensions             ProtocolExtensionContainer
	ExtElem1                 [][]byte
}

/*
	NR-CGI ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		nRCellIdentity [1] NRCellIdentity,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type NRCGI struct {
	PLMNIdentity   PLMNIdentity
	NRCellIdentity NRCellIdentity
	IEExtensions   ProtocolExtensionContainer
	ExtElem1       [][]byte
}

/*
	SourceToTarget-AMFInformationReroute ::= SEQUENCE {
		configuredNSSAI [0] ConfiguredNSSAI OPTIONAL,
		rejectedNSSAIinPLMN [1] RejectedNSSAIinPLMN OPTIONAL,
		rejectedNSSAIinTA [2] RejectedNSSAIinTA OPTIONAL,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type SourceToTargetAMFInformationReroute struct {
	ConfiguredNSSAI     *ConfiguredNSSAI
	RejectedNSSAIinPLMN *RejectedNSSAIinPLMN
	RejectedNSSAIinTA   *RejectedNSSAIinTA
	IEExtensions        ProtocolExtensionContainer
	ExtElem1            [][]byte
}

/*
	TAI ::= SEQUENCE {
		pLMNIdentity [0] PLMNIdentity,
		tAC [1] TAC,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type TAI struct {
	PLMNIdentity PLMNIdentity
	TAC          TAC
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	AreaOfInterestTAIItem ::= SEQUENCE {
		tAI [0] TAI,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AreaOfInterestTAIItem struct {
	TAI          TAI
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
AreaOfInterestTAIList ::= SEQUENCE (SIZE (1..maxnoofTAIinAoI)) OF AreaOfInterestTAIItem
*/
type AreaOfInterestTAIList []AreaOfInterestTAIItem

/*
	UEAggregateMaximumBitRate ::= SEQUENCE {
		uEAggregateMaximumBitRateDL [0] BitRate,
		uEAggregateMaximumBitRateUL [1] BitRate,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UEAggregateMaximumBitRate struct {
	UEAggregateMaximumBitRateDL BitRate
	UEAggregateMaximumBitRateUL BitRate
	IEExtensions                ProtocolExtensionContainer
	ExtElem1                    [][]byte
}

/*
	UERadioCapabilityForPaging ::= SEQUENCE {
		uERadioCapabilityForPagingOfNR [0] UERadioCapabilityForPagingOfNR OPTIONAL,
		uERadioCapabilityForPagingOfEUTRA [1] UERadioCapabilityForPagingOfEUTRA OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UERadioCapabilityForPaging struct {
	UERadioCapabilityForPagingOfNR    *UERadioCapabilityForPagingOfNR
	UERadioCapabilityForPagingOfEUTRA *UERadioCapabilityForPagingOfEUTRA
	IEExtensions                      ProtocolExtensionContainer
	ExtElem1                          [][]byte
}

/*
	UESecurityCapabilities ::= SEQUENCE {
		nRencryptionAlgorithms [0] NRencryptionAlgorithms,
		nRintegrityProtectionAlgorithms [1] NRintegrityProtectionAlgorithms,
		eUTRAencryptionAlgorithms [2] EUTRAencryptionAlgorithms,
		eUTRAintegrityProtectionAlgorithms [3] EUTRAintegrityProtectionAlgorithms,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UESecurityCapabilities struct {
	NRencryptionAlgorithms             NRencryptionAlgorithms
	NRintegrityProtectionAlgorithms    NRintegrityProtectionAlgorithms
	EUTRAencryptionAlgorithms          EUTRAencryptionAlgorithms
	EUTRAintegrityProtectionAlgorithms EUTRAintegrityProtectionAlgorithms
	IEExtensions                       ProtocolExtensionContainer
	ExtElem1                           [][]byte
}

/*
	UserLocationInformationEUTRA ::= SEQUENCE {
		eUTRA-CGI [0] EUTRA-CGI,
		tAI [1] TAI,
		timeStamp [2] TimeStamp OPTIONAL,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UserLocationInformationEUTRA struct {
	EUTRACGI     EUTRACGI
	TAI          TAI
	TimeStamp    *TimeStamp
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	UserLocationInformationNR ::= SEQUENCE {
		nR-CGI [0] NR-CGI,
		tAI [1] TAI,
		timeStamp [2] TimeStamp OPTIONAL,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UserLocationInformationNR struct {
	NRCGI        NRCGI
	TAI          TAI
	TimeStamp    *TimeStamp
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	UserLocationInformationN3IWF ::= SEQUENCE {
		iPAddress [0] TransportLayerAddress,
		portNumber [1] PortNumber,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UserLocationInformationN3IWF struct {
	IPAddress    TransportLayerAddress
	PortNumber   PortNumber
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
UserLocationInformation ::= CHOICE {
	userLocationInformationEUTRA [0] UserLocationInformationEUTRA,
	userLocationInformationNR [1] UserLocationInformationNR,
	userLocationInformationN3IWF [2] UserLocationInformationN3IWF,
	choice-Extensions [3] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	UserLocationInformationUserLocationInformationEUTRATAG = 1
	UserLocationInformationUserLocationInformationNRTAG    = 2
	UserLocationInformationUserLocationInformationN3IWFTAG = 3
	UserLocationInformationChoiceExtensionsTAG             = 4
)

type UserLocationInformation struct {
	T uint64
	U struct {
		UserLocationInformationEUTRA *UserLocationInformationEUTRA
		UserLocationInformationNR    *UserLocationInformationNR
		UserLocationInformationN3IWF *UserLocationInformationN3IWF
		ChoiceExtensions             *ProtocolIESingleContainer
	}
}

/*
UEContextRequest ::= ENUMERATED { requested(0), ... }
*/
type UEContextRequest uint64

const (
	UEContextRequestRequested = 0
	UEContextRequestUNKNOWN   = 1
)

/*
ResetAll ::= ENUMERATED { reset-all(0), ... }
*/
type ResetAll uint64

const (
	ResetAllResetAll = 0
	ResetAllUNKNOWN  = 1
)

/*
	UE-associatedLogicalNG-connectionItem ::= SEQUENCE {
		aMF-UE-NGAP-ID [0] AMF-UE-NGAP-ID OPTIONAL,
		rAN-UE-NGAP-ID [1] RAN-UE-NGAP-ID OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UEAssociatedLogicalNGConnectionItem struct {
	AMFUENGAPID  *AMFUENGAPID
	RANUENGAPID  *RANUENGAPID
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
UE-associatedLogicalNG-connectionList ::= SEQUENCE (SIZE (1..maxnoofNGConnectionsToReset)) OF UE-associatedLogicalNG-connectionItem
*/
type UEAssociatedLogicalNGConnectionList []UEAssociatedLogicalNGConnectionItem

/*
ResetType ::= CHOICE {
	nG-Interface [0] ResetAll,
	partOfNG-Interface [1] UE-associatedLogicalNG-connectionList,
	choice-Extensions [2] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	ResetTypeNGInterfaceTAG       = 1
	ResetTypePartOfNGInterfaceTAG = 2
	ResetTypeChoiceExtensionsTAG  = 3
)

type ResetType struct {
	T uint64
	U struct {
		NGInterface       *ResetAll
		PartOfNGInterface *UEAssociatedLogicalNGConnectionList
		ChoiceExtensions  *ProtocolIESingleContainer
	}
}

/*
AdditionalQosFlowInformation ::= ENUMERATED { more-likely(0), ... }
*/
type AdditionalQosFlowInformation uint64

const (
	AdditionalQosFlowInformationMoreLikely = 0
	AdditionalQosFlowInformationUNKNOWN    = 1
)

/*
AveragingWindow ::= INTEGER (0..4095, ...)
*/
type AveragingWindow uint64

/*
CommonNetworkInstance ::= OCTET STRING
*/
type CommonNetworkInstance asn1rt.OctetString

/*
ConfidentialityProtectionIndication ::= ENUMERATED { required(0), preferred(1), not-needed(2), ... }
*/
type ConfidentialityProtectionIndication uint64

const (
	ConfidentialityProtectionIndicationRequired  = 0
	ConfidentialityProtectionIndicationPreferred = 1
	ConfidentialityProtectionIndicationNotNeeded = 2
	ConfidentialityProtectionIndicationUNKNOWN   = 3
)

/*
ConfidentialityProtectionResult ::= ENUMERATED { performed(0), not-performed(1), ... }
*/
type ConfidentialityProtectionResult uint64

const (
	ConfidentialityProtectionResultPerformed    = 0
	ConfidentialityProtectionResultNotPerformed = 1
	ConfidentialityProtectionResultUNKNOWN      = 2
)

/*
DataForwardingNotPossible ::= ENUMERATED { data-forwarding-not-possible(0), ... }
*/
type DataForwardingNotPossible uint64

const (
	DataForwardingNotPossibleDataForwardingNotPossible = 0
	DataForwardingNotPossibleUNKNOWN                   = 1
)

/*
DelayCritical ::= ENUMERATED { delay-critical(0), non-delay-critical(1), ... }
*/
type DelayCritical uint64

const (
	DelayCriticalDelayCritical    = 0
	DelayCriticalNonDelayCritical = 1
	DelayCriticalUNKNOWN          = 2
)

/*
EmergencyFallbackRequestIndicator ::= ENUMERATED { emergency-fallback-requested(0), ... }
*/
type EmergencyFallbackRequestIndicator uint64

const (
	EmergencyFallbackRequestIndicatorEmergencyFallbackRequested = 0
	EmergencyFallbackRequestIndicatorUNKNOWN                    = 1
)

/*
EmergencyServiceTargetCN ::= ENUMERATED { fiveGC(0), epc(1), ... }
*/
type EmergencyServiceTargetCN uint64

const (
	EmergencyServiceTargetCNFiveGC  = 0
	EmergencyServiceTargetCNEpc     = 1
	EmergencyServiceTargetCNUNKNOWN = 2
)

/*
E-RAB-ID ::= INTEGER (0..15, ...)
*/
type ERABID uint64

/*
FiveQI ::= INTEGER (0..255, ...)
*/
type FiveQI uint64

/*
GTP-TEID ::= OCTET STRING (SIZE (4))
*/
type GTPTEID asn1rt.OctetString

/*
IntegrityProtectionIndication ::= ENUMERATED { required(0), preferred(1), not-needed(2), ... }
*/
type IntegrityProtectionIndication uint64

const (
	IntegrityProtectionIndicationRequired  = 0
	IntegrityProtectionIndicationPreferred = 1
	IntegrityProtectionIndicationNotNeeded = 2
	IntegrityProtectionIndicationUNKNOWN   = 3
)

/*
IntegrityProtectionResult ::= ENUMERATED { performed(0), not-performed(1), ... }
*/
type IntegrityProtectionResult uint64

const (
	IntegrityProtectionResultPerformed    = 0
	IntegrityProtectionResultNotPerformed = 1
	IntegrityProtectionResultUNKNOWN      = 2
)

/*
InterfacesToTrace ::= BIT STRING  (SIZE (8))
*/
type InterfacesToTrace asn1rt.BitString

/*
LocationReportingReferenceID ::= INTEGER (1..64, ...)
*/
type LocationReportingReferenceID uint64

/*
MaskedIMEISV ::= BIT STRING  (SIZE (64))
*/
type MaskedIMEISV asn1rt.BitString

/*
MaximumDataBurstVolume ::= INTEGER (0..4095, ...)
*/
type MaximumDataBurstVolume uint64

/*
MaximumIntegrityProtectedDataRate ::= ENUMERATED { bitrate64kbs(0), maximum-UE-rate(1), ... }
*/
type MaximumIntegrityProtectedDataRate uint64

const (
	MaximumIntegrityProtectedDataRateBitrate64kbs  = 0
	MaximumIntegrityProtectedDataRateMaximumUERate = 1
	MaximumIntegrityProtectedDataRateUNKNOWN       = 2
)

/*
MICOModeIndication ::= ENUMERATED { true(0), ... }
*/
type MICOModeIndication uint64

const (
	MICOModeIndicationTrue    = 0
	MICOModeIndicationUNKNOWN = 1
)

/*
NetworkInstance ::= INTEGER (1..256, ...)
*/
type NetworkInstance uint64

/*
NGRANTraceID ::= OCTET STRING (SIZE (8))
*/
type NGRANTraceID asn1rt.OctetString

/*
NotificationControl ::= ENUMERATED { notification-requested(0), ... }
*/
type NotificationControl uint64

const (
	NotificationControlNotificationRequested = 0
	NotificationControlUNKNOWN               = 1
)

/*
PacketLossRate ::= INTEGER (0..1000, ...)
*/
type PacketLossRate uint64

/*
PacketDelayBudget ::= INTEGER (0..1023, ...)
*/
type PacketDelayBudget uint64

/*
PDUSessionID ::= INTEGER (0..255)
*/
type PDUSessionID uint64

/*
PDUSessionType ::= ENUMERATED { ipv4(0), ipv6(1), ipv4v6(2), ethernet(3), unstructured(4), ... }
*/
type PDUSessionType uint64

const (
	PDUSessionTypeIpv4         = 0
	PDUSessionTypeIpv6         = 1
	PDUSessionTypeIpv4v6       = 2
	PDUSessionTypeEthernet     = 3
	PDUSessionTypeUnstructured = 4
	PDUSessionTypeUNKNOWN      = 5
)

/*
PeriodicRegistrationUpdateTimer ::= BIT STRING  (SIZE (8))
*/
type PeriodicRegistrationUpdateTimer asn1rt.BitString

/*
Pre-emptionCapability ::= ENUMERATED { shall-not-trigger-pre-emption(0), may-trigger-pre-emption(1), ... }
*/
type PreEmptionCapability uint64

const (
	PreEmptionCapabilityShallNotTriggerPreEmption = 0
	PreEmptionCapabilityMayTriggerPreEmption      = 1
	PreEmptionCapabilityUNKNOWN                   = 2
)

/*
Pre-emptionVulnerability ::= ENUMERATED { not-pre-emptable(0), pre-emptable(1), ... }
*/
type PreEmptionVulnerability uint64

const (
	PreEmptionVulnerabilityNotPreEmptable = 0
	PreEmptionVulnerabilityPreEmptable    = 1
	PreEmptionVulnerabilityUNKNOWN        = 2
)

/*
PriorityLevelARP ::= INTEGER (1..15)
*/
type PriorityLevelARP uint64

/*
PriorityLevelQos ::= INTEGER (1..127, ...)
*/
type PriorityLevelQos uint64

/*
QosFlowIdentifier ::= INTEGER (0..63, ...)
*/
type QosFlowIdentifier uint64

/*
ReflectiveQosAttribute ::= ENUMERATED { subject-to(0), ... }
*/
type ReflectiveQosAttribute uint64

const (
	ReflectiveQosAttributeSubjectTo = 0
	ReflectiveQosAttributeUNKNOWN   = 1
)

/*
ReportArea ::= ENUMERATED { cell(0), ... }
*/
type ReportArea uint64

const (
	ReportAreaCell    = 0
	ReportAreaUNKNOWN = 1
)

/*
RRCInactiveTransitionReportRequest ::= ENUMERATED { subsequent-state-transition-report(0), single-rrc-connected-state-report(1), cancel-report(2), ... }
*/
type RRCInactiveTransitionReportRequest uint64

const (
	RRCInactiveTransitionReportRequestSubsequentStateTransitionReport = 0
	RRCInactiveTransitionReportRequestSingleRrcConnectedStateReport   = 1
	RRCInactiveTransitionReportRequestCancelReport                    = 2
	RRCInactiveTransitionReportRequestUNKNOWN                         = 3
)

/*
AssociatedQosFlowItem_qosFlowMappingIndication ::= ENUMERATED { ul(0), dl(1), ... }
*/
type AssociatedQosFlowItemQosFlowMappingIndication uint64

const (
	AssociatedQosFlowItemQosFlowMappingIndicationUl      = 0
	AssociatedQosFlowItemQosFlowMappingIndicationDl      = 1
	AssociatedQosFlowItemQosFlowMappingIndicationUNKNOWN = 2
)

/*
	AllocationAndRetentionPriority ::= SEQUENCE {
		priorityLevelARP [0] PriorityLevelARP,
		pre-emptionCapability [1] Pre-emptionCapability,
		pre-emptionVulnerability [2] Pre-emptionVulnerability,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AllocationAndRetentionPriority struct {
	PriorityLevelARP        PriorityLevelARP
	PreEmptionCapability    PreEmptionCapability
	PreEmptionVulnerability PreEmptionVulnerability
	IEExtensions            ProtocolExtensionContainer
	ExtElem1                [][]byte
}

/*
	AssociatedQosFlowItem ::= SEQUENCE {
		qosFlowIdentifier [0] QosFlowIdentifier,
		qosFlowMappingIndication [1] ENUMERATED { ul(0), dl(1), ... } OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type AssociatedQosFlowItem struct {
	QosFlowIdentifier        QosFlowIdentifier
	QosFlowMappingIndication *AssociatedQosFlowItemQosFlowMappingIndication
	IEExtensions             ProtocolExtensionContainer
	ExtElem1                 [][]byte
}

/*
AssociatedQosFlowList ::= SEQUENCE (SIZE (1..maxnoofQosFlows)) OF AssociatedQosFlowItem
*/
type AssociatedQosFlowList []AssociatedQosFlowItem

/*
	ExpectedUEActivityBehaviour ::= SEQUENCE {
		expectedActivityPeriod [0] ExpectedActivityPeriod OPTIONAL,
		expectedIdlePeriod [1] ExpectedIdlePeriod OPTIONAL,
		sourceOfUEActivityBehaviourInformation [2] SourceOfUEActivityBehaviourInformation OPTIONAL,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type ExpectedUEActivityBehaviour struct {
	ExpectedActivityPeriod                 *ExpectedActivityPeriod
	ExpectedIdlePeriod                     *ExpectedIdlePeriod
	SourceOfUEActivityBehaviourInformation *SourceOfUEActivityBehaviourInformation
	IEExtensions                           ProtocolExtensionContainer
	ExtElem1                               [][]byte
}

/*
	ExpectedUEMovingTrajectoryItem ::= SEQUENCE {
		nGRAN-CGI [0] EXPLICIT NGRAN-CGI,
		timeStayedInCell [1] INTEGER (0..4095) OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type ExpectedUEMovingTrajectoryItem struct {
	NGRANCGI         NGRANCGI
	TimeStayedInCell *uint64
	IEExtensions     ProtocolExtensionContainer
	ExtElem1         [][]byte
}

/*
ExpectedUEMovingTrajectory ::= SEQUENCE (SIZE (1..maxnoofCellsUEMovingTrajectory)) OF ExpectedUEMovingTrajectoryItem
*/
type ExpectedUEMovingTrajectory []ExpectedUEMovingTrajectoryItem

/*
	ExpectedUEBehaviour ::= SEQUENCE {
		expectedUEActivityBehaviour [0] ExpectedUEActivityBehaviour OPTIONAL,
		expectedHOInterval [1] ExpectedHOInterval OPTIONAL,
		expectedUEMobility [2] ExpectedUEMobility OPTIONAL,
		expectedUEMovingTrajectory [3] ExpectedUEMovingTrajectory OPTIONAL,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type ExpectedUEBehaviour struct {
	ExpectedUEActivityBehaviour *ExpectedUEActivityBehaviour
	ExpectedHOInterval          *ExpectedHOInterval
	ExpectedUEMobility          *ExpectedUEMobility
	ExpectedUEMovingTrajectory  ExpectedUEMovingTrajectory
	IEExtensions                ProtocolExtensionContainer
	ExtElem1                    [][]byte
}

/*
	CNAssistedRANTuning ::= SEQUENCE {
		expectedUEBehaviour [0] ExpectedUEBehaviour OPTIONAL,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type CNAssistedRANTuning struct {
	ExpectedUEBehaviour *ExpectedUEBehaviour
	IEExtensions        ProtocolExtensionContainer
	ExtElem1            [][]byte
}

/*
UEIdentityIndexValue ::= CHOICE {
	indexLength10 [0] BIT STRING  (SIZE (10)),
	choice-Extensions [1] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	UEIdentityIndexValueIndexLength10TAG    = 1
	UEIdentityIndexValueChoiceExtensionsTAG = 2
)

type UEIdentityIndexValue struct {
	T uint64
	U struct {
		IndexLength10    *asn1rt.BitString
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	TAIListForInactiveItem ::= SEQUENCE {
		tAI [0] TAI,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type TAIListForInactiveItem struct {
	TAI          TAI
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
TAIListForInactive ::= SEQUENCE (SIZE (1..maxnoofTAIforInactive)) OF TAIListForInactiveItem
*/
type TAIListForInactive []TAIListForInactiveItem

/*
	CoreNetworkAssistanceInformationForInactive ::= SEQUENCE {
		uEIdentityIndexValue [0] EXPLICIT UEIdentityIndexValue,
		uESpecificDRX [1] PagingDRX OPTIONAL,
		periodicRegistrationUpdateTimer [2] PeriodicRegistrationUpdateTimer,
		mICOModeIndication [3] MICOModeIndication OPTIONAL,
		tAIListForInactive [4] TAIListForInactive,
		expectedUEBehaviour [5] ExpectedUEBehaviour OPTIONAL,
		iE-Extensions [6] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type CoreNetworkAssistanceInformationForInactive struct {
	UEIdentityIndexValue            UEIdentityIndexValue
	UESpecificDRX                   *PagingDRX
	PeriodicRegistrationUpdateTimer PeriodicRegistrationUpdateTimer
	MICOModeIndication              *MICOModeIndication
	TAIListForInactive              TAIListForInactive
	ExpectedUEBehaviour             *ExpectedUEBehaviour
	IEExtensions                    ProtocolExtensionContainer
	ExtElem1                        [][]byte
}

/*
	PacketErrorRate ::= SEQUENCE {
		pERScalar [0] INTEGER (0..9, ...),
		pERExponent [1] INTEGER (0..9, ...),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PacketErrorRate struct {
	PERScalar    uint64
	PERExponent  uint64
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	Dynamic5QIDescriptor ::= SEQUENCE {
		priorityLevelQos [0] PriorityLevelQos,
		packetDelayBudget [1] PacketDelayBudget,
		packetErrorRate [2] PacketErrorRate,
		fiveQI [3] FiveQI OPTIONAL,
		delayCritical [4] DelayCritical OPTIONAL,

--The above IE shall be present in case of GBR QoS flow

	averagingWindow [5] AveragingWindow OPTIONAL,

--The above IE shall be present in case of GBR QoS flow

		maximumDataBurstVolume [6] MaximumDataBurstVolume OPTIONAL,
		iE-Extensions [7] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type Dynamic5QIDescriptor struct {
	PriorityLevelQos       PriorityLevelQos
	PacketDelayBudget      PacketDelayBudget
	PacketErrorRate        PacketErrorRate
	FiveQI                 *FiveQI
	DelayCritical          *DelayCritical
	AveragingWindow        *AveragingWindow
	MaximumDataBurstVolume *MaximumDataBurstVolume
	IEExtensions           ProtocolExtensionContainer
	ExtElem1               [][]byte
}

/*
	EmergencyFallbackIndicator ::= SEQUENCE {
		emergencyFallbackRequestIndicator [0] EmergencyFallbackRequestIndicator,
		emergencyServiceTargetCN [1] EmergencyServiceTargetCN OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type EmergencyFallbackIndicator struct {
	EmergencyFallbackRequestIndicator EmergencyFallbackRequestIndicator
	EmergencyServiceTargetCN          *EmergencyServiceTargetCN
	IEExtensions                      ProtocolExtensionContainer
	ExtElem1                          [][]byte
}

/*
	GBR-QosInformation ::= SEQUENCE {
		maximumFlowBitRateDL [0] BitRate,
		maximumFlowBitRateUL [1] BitRate,
		guaranteedFlowBitRateDL [2] BitRate,
		guaranteedFlowBitRateUL [3] BitRate,
		notificationControl [4] NotificationControl OPTIONAL,
		maximumPacketLossRateDL [5] PacketLossRate OPTIONAL,
		maximumPacketLossRateUL [6] PacketLossRate OPTIONAL,
		iE-Extensions [7] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type GBRQosInformation struct {
	MaximumFlowBitRateDL    BitRate
	MaximumFlowBitRateUL    BitRate
	GuaranteedFlowBitRateDL BitRate
	GuaranteedFlowBitRateUL BitRate
	NotificationControl     *NotificationControl
	MaximumPacketLossRateDL *PacketLossRate
	MaximumPacketLossRateUL *PacketLossRate
	IEExtensions            ProtocolExtensionContainer
	ExtElem1                [][]byte
}

/*
	GTPTunnel ::= SEQUENCE {
		transportLayerAddress [0] TransportLayerAddress,
		gTP-TEID [1] GTP-TEID,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type GTPTunnel struct {
	TransportLayerAddress TransportLayerAddress
	GTPTEID               GTPTEID
	IEExtensions          ProtocolExtensionContainer
	ExtElem1              [][]byte
}

/*
	NonDynamic5QIDescriptor ::= SEQUENCE {
		fiveQI [0] FiveQI,
		priorityLevelQos [1] PriorityLevelQos OPTIONAL,
		averagingWindow [2] AveragingWindow OPTIONAL,
		maximumDataBurstVolume [3] MaximumDataBurstVolume OPTIONAL,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type NonDynamic5QIDescriptor struct {
	FiveQI                 FiveQI
	PriorityLevelQos       *PriorityLevelQos
	AveragingWindow        *AveragingWindow
	MaximumDataBurstVolume *MaximumDataBurstVolume
	IEExtensions           ProtocolExtensionContainer
	ExtElem1               [][]byte
}

/*
	PDUSessionResourceSetupUnsuccessfulTransfer ::= SEQUENCE {
		cause [0] EXPLICIT Cause,
		criticalityDiagnostics [1] CriticalityDiagnostics OPTIONAL,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceSetupUnsuccessfulTransfer struct {
	Cause                  Cause
	CriticalityDiagnostics *CriticalityDiagnostics
	IEExtensions           ProtocolExtensionContainer
	ExtElem1               [][]byte
}

/*
	PDUSessionResourceFailedToSetupItemCxtFail ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionResourceSetupUnsuccessfulTransfer [1] OCTET STRING (CONTAINING PDUSessionResourceSetupUnsuccessfulTransfer),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceFailedToSetupItemCxtFail struct {
	PDUSessionID                                PDUSessionID
	PDUSessionResourceSetupUnsuccessfulTransfer PDUSessionResourceSetupUnsuccessfulTransfer
	IEExtensions                                ProtocolExtensionContainer
	ExtElem1                                    [][]byte
}

/*
PDUSessionResourceFailedToSetupListCxtFail ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceFailedToSetupItemCxtFail
*/
type PDUSessionResourceFailedToSetupListCxtFail []PDUSessionResourceFailedToSetupItemCxtFail

/*
	PDUSessionResourceFailedToSetupItemSURes ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionResourceSetupUnsuccessfulTransfer [1] OCTET STRING (CONTAINING PDUSessionResourceSetupUnsuccessfulTransfer),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceFailedToSetupItemSURes struct {
	PDUSessionID                                PDUSessionID
	PDUSessionResourceSetupUnsuccessfulTransfer PDUSessionResourceSetupUnsuccessfulTransfer
	IEExtensions                                ProtocolExtensionContainer
	ExtElem1                                    [][]byte
}

/*
PDUSessionResourceFailedToSetupListSURes ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceFailedToSetupItemSURes
*/
type PDUSessionResourceFailedToSetupListSURes []PDUSessionResourceFailedToSetupItemSURes

/*
	PDUSessionResourceSetupRequestTransfer ::= SEQUENCE {
		protocolIEs [0] ProtocolIE-Container,
		...
	}
*/
type PDUSessionResourceSetupRequestTransfer struct {
	ProtocolIEs ProtocolIEContainer
	ExtElem1    [][]byte
}

/*
	PDUSessionResourceSetupItemCxtReq ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		nAS-PDU [1] NAS-PDU OPTIONAL,
		s-NSSAI [2] S-NSSAI,
		pDUSessionResourceSetupRequestTransfer [3] OCTET STRING (CONTAINING PDUSessionResourceSetupRequestTransfer),
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceSetupItemCxtReq struct {
	PDUSessionID                           PDUSessionID
	NASPDU                                 *NASPDU
	SNSSAI                                 SNSSAI
	PDUSessionResourceSetupRequestTransfer PDUSessionResourceSetupRequestTransfer
	IEExtensions                           ProtocolExtensionContainer
	ExtElem1                               [][]byte
}

/*
PDUSessionResourceSetupListCxtReq ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceSetupItemCxtReq
*/
type PDUSessionResourceSetupListCxtReq []PDUSessionResourceSetupItemCxtReq

/*
	PDUSessionResourceSetupItemSUReq ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionNAS-PDU [1] NAS-PDU OPTIONAL,
		s-NSSAI [2] S-NSSAI,
		pDUSessionResourceSetupRequestTransfer [3] OCTET STRING (CONTAINING PDUSessionResourceSetupRequestTransfer),
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceSetupItemSUReq struct {
	PDUSessionID                           PDUSessionID
	PDUSessionNASPDU                       *NASPDU
	SNSSAI                                 SNSSAI
	PDUSessionResourceSetupRequestTransfer PDUSessionResourceSetupRequestTransfer
	IEExtensions                           ProtocolExtensionContainer
	ExtElem1                               [][]byte
}

/*
PDUSessionResourceSetupListSUReq ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceSetupItemSUReq
*/
type PDUSessionResourceSetupListSUReq []PDUSessionResourceSetupItemSUReq

/*
UPTransportLayerInformation ::= CHOICE {
	gTPTunnel [0] GTPTunnel,
	choice-Extensions [1] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	UPTransportLayerInformationGTPTunnelTAG        = 1
	UPTransportLayerInformationChoiceExtensionsTAG = 2
)

type UPTransportLayerInformation struct {
	T uint64
	U struct {
		GTPTunnel        *GTPTunnel
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	QosFlowPerTNLInformation ::= SEQUENCE {
		uPTransportLayerInformation [0] EXPLICIT UPTransportLayerInformation,
		associatedQosFlowList [1] AssociatedQosFlowList,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type QosFlowPerTNLInformation struct {
	UPTransportLayerInformation UPTransportLayerInformation
	AssociatedQosFlowList       AssociatedQosFlowList
	IEExtensions                ProtocolExtensionContainer
	ExtElem1                    [][]byte
}

/*
	QosFlowPerTNLInformationItem ::= SEQUENCE {
		qosFlowPerTNLInformation [0] QosFlowPerTNLInformation,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type QosFlowPerTNLInformationItem struct {
	QosFlowPerTNLInformation QosFlowPerTNLInformation
	IEExtensions             ProtocolExtensionContainer
	ExtElem1                 [][]byte
}

/*
QosFlowPerTNLInformationList ::= SEQUENCE (SIZE (1..maxnoofMultiConnectivityMinusOne)) OF QosFlowPerTNLInformationItem
*/
type QosFlowPerTNLInformationList []QosFlowPerTNLInformationItem

/*
	SecurityResult ::= SEQUENCE {
		integrityProtectionResult [0] IntegrityProtectionResult,
		confidentialityProtectionResult [1] ConfidentialityProtectionResult,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type SecurityResult struct {
	IntegrityProtectionResult       IntegrityProtectionResult
	ConfidentialityProtectionResult ConfidentialityProtectionResult
	IEExtensions                    ProtocolExtensionContainer
	ExtElem1                        [][]byte
}

/*
	QosFlowWithCauseItem ::= SEQUENCE {
		qosFlowIdentifier [0] QosFlowIdentifier,
		cause [1] EXPLICIT Cause,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type QosFlowWithCauseItem struct {
	QosFlowIdentifier QosFlowIdentifier
	Cause             Cause
	IEExtensions      ProtocolExtensionContainer
	ExtElem1          [][]byte
}

/*
QosFlowListWithCause ::= SEQUENCE (SIZE (1..maxnoofQosFlows)) OF QosFlowWithCauseItem
*/
type QosFlowListWithCause []QosFlowWithCauseItem

/*
	PDUSessionResourceSetupResponseTransfer ::= SEQUENCE {
		dLQosFlowPerTNLInformation [0] QosFlowPerTNLInformation,
		additionalDLQosFlowPerTNLInformation [1] QosFlowPerTNLInformationList OPTIONAL,
		securityResult [2] SecurityResult OPTIONAL,
		qosFlowFailedToSetupList [3] QosFlowListWithCause OPTIONAL,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceSetupResponseTransfer struct {
	DLQosFlowPerTNLInformation           QosFlowPerTNLInformation
	AdditionalDLQosFlowPerTNLInformation QosFlowPerTNLInformationList
	SecurityResult                       *SecurityResult
	QosFlowFailedToSetupList             QosFlowListWithCause
	IEExtensions                         ProtocolExtensionContainer
	ExtElem1                             [][]byte
}

/*
	PDUSessionResourceSetupItemCxtRes ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionResourceSetupResponseTransfer [1] OCTET STRING (CONTAINING PDUSessionResourceSetupResponseTransfer),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceSetupItemCxtRes struct {
	PDUSessionID                            PDUSessionID
	PDUSessionResourceSetupResponseTransfer PDUSessionResourceSetupResponseTransfer
	IEExtensions                            ProtocolExtensionContainer
	ExtElem1                                [][]byte
}

/*
PDUSessionResourceSetupListCxtRes ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceSetupItemCxtRes
*/
type PDUSessionResourceSetupListCxtRes []PDUSessionResourceSetupItemCxtRes

/*
	PDUSessionResourceSetupItemSURes ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionResourceSetupResponseTransfer [1] OCTET STRING (CONTAINING PDUSessionResourceSetupResponseTransfer),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceSetupItemSURes struct {
	PDUSessionID                            PDUSessionID
	PDUSessionResourceSetupResponseTransfer PDUSessionResourceSetupResponseTransfer
	IEExtensions                            ProtocolExtensionContainer
	ExtElem1                                [][]byte
}

/*
PDUSessionResourceSetupListSURes ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceSetupItemSURes
*/
type PDUSessionResourceSetupListSURes []PDUSessionResourceSetupItemSURes

/*
	PDUSessionAggregateMaximumBitRate ::= SEQUENCE {
		pDUSessionAggregateMaximumBitRateDL [0] BitRate,
		pDUSessionAggregateMaximumBitRateUL [1] BitRate,
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionAggregateMaximumBitRate struct {
	PDUSessionAggregateMaximumBitRateDL BitRate
	PDUSessionAggregateMaximumBitRateUL BitRate
	IEExtensions                        ProtocolExtensionContainer
	ExtElem1                            [][]byte
}

/*
QosCharacteristics ::= CHOICE {
	nonDynamic5QI [0] NonDynamic5QIDescriptor,
	dynamic5QI [1] Dynamic5QIDescriptor,
	choice-Extensions [2] ProtocolIE-SingleContainer
}
*/
// Choice tag constants
const (
	QosCharacteristicsNonDynamic5QITAG    = 1
	QosCharacteristicsDynamic5QITAG       = 2
	QosCharacteristicsChoiceExtensionsTAG = 3
)

type QosCharacteristics struct {
	T uint64
	U struct {
		NonDynamic5QI    *NonDynamic5QIDescriptor
		Dynamic5QI       *Dynamic5QIDescriptor
		ChoiceExtensions *ProtocolIESingleContainer
	}
}

/*
	QosFlowLevelQosParameters ::= SEQUENCE {
		qosCharacteristics [0] EXPLICIT QosCharacteristics,
		allocationAndRetentionPriority [1] AllocationAndRetentionPriority,
		gBR-QosInformation [2] GBR-QosInformation OPTIONAL,
		reflectiveQosAttribute [3] ReflectiveQosAttribute OPTIONAL,
		additionalQosFlowInformation [4] AdditionalQosFlowInformation OPTIONAL,
		iE-Extensions [5] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type QosFlowLevelQosParameters struct {
	QosCharacteristics             QosCharacteristics
	AllocationAndRetentionPriority AllocationAndRetentionPriority
	GBRQosInformation              *GBRQosInformation
	ReflectiveQosAttribute         *ReflectiveQosAttribute
	AdditionalQosFlowInformation   *AdditionalQosFlowInformation
	IEExtensions                   ProtocolExtensionContainer
	ExtElem1                       [][]byte
}

/*
	QosFlowSetupRequestItem ::= SEQUENCE {
		qosFlowIdentifier [0] QosFlowIdentifier,
		qosFlowLevelQosParameters [1] QosFlowLevelQosParameters,
		e-RAB-ID [2] E-RAB-ID OPTIONAL,
		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type QosFlowSetupRequestItem struct {
	QosFlowIdentifier         QosFlowIdentifier
	QosFlowLevelQosParameters QosFlowLevelQosParameters
	ERABID                    *ERABID
	IEExtensions              ProtocolExtensionContainer
	ExtElem1                  [][]byte
}

/*
QosFlowSetupRequestList ::= SEQUENCE (SIZE (1..maxnoofQosFlows)) OF QosFlowSetupRequestItem
*/
type QosFlowSetupRequestList []QosFlowSetupRequestItem

/*
	SecurityIndication ::= SEQUENCE {
		integrityProtectionIndication [0] IntegrityProtectionIndication,
		confidentialityProtectionIndication [1] ConfidentialityProtectionIndication,
		maximumIntegrityProtectedDataRate-UL [2] MaximumIntegrityProtectedDataRate OPTIONAL,

--The above IE shall be present if integrity protection is required or preferred

		iE-Extensions [3] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type SecurityIndication struct {
	IntegrityProtectionIndication       IntegrityProtectionIndication
	ConfidentialityProtectionIndication ConfidentialityProtectionIndication
	MaximumIntegrityProtectedDataRateUL *MaximumIntegrityProtectedDataRate
	IEExtensions                        ProtocolExtensionContainer
	ExtElem1                            [][]byte
}

/*
	TraceActivation ::= SEQUENCE {
		nGRANTraceID [0] NGRANTraceID,
		interfacesToTrace [1] InterfacesToTrace,
		traceDepth [2] TraceDepth,
		traceCollectionEntityIPAddress [3] TransportLayerAddress,
		iE-Extensions [4] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type TraceActivation struct {
	NGRANTraceID                   NGRANTraceID
	InterfacesToTrace              InterfacesToTrace
	TraceDepth                     TraceDepth
	TraceCollectionEntityIPAddress TransportLayerAddress
	IEExtensions                   ProtocolExtensionContainer
	ExtElem1                       [][]byte
}

/*
	UPTransportLayerInformationItem ::= SEQUENCE {
		nGU-UP-TNLInformation [0] EXPLICIT UPTransportLayerInformation,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type UPTransportLayerInformationItem struct {
	NGUUPTNLInformation UPTransportLayerInformation
	IEExtensions        ProtocolExtensionContainer
	ExtElem1            [][]byte
}

/*
UPTransportLayerInformationList ::= SEQUENCE (SIZE (1..maxnoofMultiConnectivityMinusOne)) OF UPTransportLayerInformationItem
*/
type UPTransportLayerInformationList []UPTransportLayerInformationItem

/*
	PDUSessionResourceReleaseCommandTransfer ::= SEQUENCE {
		cause [0] EXPLICIT Cause,
		iE-Extensions [1] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceReleaseCommandTransfer struct {
	Cause        Cause
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	PDUSessionResourceToReleaseItemRelCmd ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionResourceReleaseCommandTransfer [1] OCTET STRING (CONTAINING PDUSessionResourceReleaseCommandTransfer),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceToReleaseItemRelCmd struct {
	PDUSessionID                             PDUSessionID
	PDUSessionResourceReleaseCommandTransfer PDUSessionResourceReleaseCommandTransfer
	IEExtensions                             ProtocolExtensionContainer
	ExtElem1                                 [][]byte
}

/*
PDUSessionResourceToReleaseListRelCmd ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceToReleaseItemRelCmd
*/
type PDUSessionResourceToReleaseListRelCmd []PDUSessionResourceToReleaseItemRelCmd

/*
	PDUSessionResourceReleaseResponseTransfer ::= SEQUENCE {
		iE-Extensions [0] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceReleaseResponseTransfer struct {
	IEExtensions ProtocolExtensionContainer
	ExtElem1     [][]byte
}

/*
	PDUSessionResourceReleasedItemRelRes ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionResourceReleaseResponseTransfer [1] OCTET STRING (CONTAINING PDUSessionResourceReleaseResponseTransfer),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceReleasedItemRelRes struct {
	PDUSessionID                              PDUSessionID
	PDUSessionResourceReleaseResponseTransfer PDUSessionResourceReleaseResponseTransfer
	IEExtensions                              ProtocolExtensionContainer
	ExtElem1                                  [][]byte
}

/*
PDUSessionResourceReleasedListRelRes ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceReleasedItemRelRes
*/
type PDUSessionResourceReleasedListRelRes []PDUSessionResourceReleasedItemRelRes

/*
EventType ::= ENUMERATED { direct(0), change-of-serve-cell(1), ue-presence-in-area-of-interest(2), stop-change-of-serve-cell(3), stop-ue-presence-in-area-of-interest(4), cancel-location-reporting-for-the-ue(5), ... }
*/
type EventType uint64

const (
	EventTypeDirect                          = 0
	EventTypeChangeOfServeCell               = 1
	EventTypeUePresenceInAreaOfInterest      = 2
	EventTypeStopChangeOfServeCell           = 3
	EventTypeStopUePresenceInAreaOfInterest  = 4
	EventTypeCancelLocationReportingForTheUe = 5
	EventTypeUNKNOWN                         = 6
)

/*
EUTRAencryptionAlgorithms ::= BIT STRING  (SIZE (16, ...))
*/
type EUTRAencryptionAlgorithms asn1rt.BitString

/*
EUTRAintegrityProtectionAlgorithms ::= BIT STRING  (SIZE (16, ...))
*/
type EUTRAintegrityProtectionAlgorithms asn1rt.BitString

/*
ExpectedActivityPeriod ::= INTEGER (1..30 | 40 | 50 | 60 | 80 | 100 | 120 | 150 | 180 | 181, ...)
*/
type ExpectedActivityPeriod uint64

/*
ExpectedHOInterval ::= ENUMERATED { sec15(0), sec30(1), sec60(2), sec90(3), sec120(4), sec180(5), long-time(6), ... }
*/
type ExpectedHOInterval uint64

const (
	ExpectedHOIntervalSec15    = 0
	ExpectedHOIntervalSec30    = 1
	ExpectedHOIntervalSec60    = 2
	ExpectedHOIntervalSec90    = 3
	ExpectedHOIntervalSec120   = 4
	ExpectedHOIntervalSec180   = 5
	ExpectedHOIntervalLongTime = 6
	ExpectedHOIntervalUNKNOWN  = 7
)

/*
ExpectedIdlePeriod ::= INTEGER (1..30 | 40 | 50 | 60 | 80 | 100 | 120 | 150 | 180 | 181, ...)
*/
type ExpectedIdlePeriod uint64

/*
ExpectedUEMobility ::= ENUMERATED { stationary(0), mobile(1), ... }
*/
type ExpectedUEMobility uint64

const (
	ExpectedUEMobilityStationary = 0
	ExpectedUEMobilityMobile     = 1
	ExpectedUEMobilityUNKNOWN    = 2
)

/*
	PDUSessionResourceFailedToSetupItemCxtRes ::= SEQUENCE {
		pDUSessionID [0] PDUSessionID,
		pDUSessionResourceSetupUnsuccessfulTransfer [1] OCTET STRING (CONTAINING PDUSessionResourceSetupUnsuccessfulTransfer),
		iE-Extensions [2] ProtocolExtensionContainer OPTIONAL,
		...
	}
*/
type PDUSessionResourceFailedToSetupItemCxtRes struct {
	PDUSessionID                                PDUSessionID
	PDUSessionResourceSetupUnsuccessfulTransfer PDUSessionResourceSetupUnsuccessfulTransfer
	IEExtensions                                ProtocolExtensionContainer
	ExtElem1                                    [][]byte
}

/*
PDUSessionResourceFailedToSetupListCxtRes ::= SEQUENCE (SIZE (1..maxnoofPDUSessions)) OF PDUSessionResourceFailedToSetupItemCxtRes
*/
type PDUSessionResourceFailedToSetupListCxtRes []PDUSessionResourceFailedToSetupItemCxtRes

// PerDecodeAMFName method implementation
func PerDecodeAMFName(pctxt *asn1rt.OSRTContext) (value AMFName, err error) {
	var extbit bool
	var nitems uint64
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if !extbit {
		nitems, err = pctxt.PerDecConsLength(8, 1)
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	pctxt.AlignBuffer()

	var tmpval string
	tmpval, err = pctxt.PerDecRestrStringData(nitems, "", 8)
	value = AMFName(tmpval)
	return
}

// PerEncodeAMFName method implementation
func PerEncodeAMFName(pctxt *asn1rt.OSRTContext, value AMFName) (err error) {
	var nitems uint64
	nitems = uint64(len(value))
	if nitems >= 1 && nitems <= 150 {
		/* extension bit */

		err = pctxt.EncBit(false)

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)

	} else {
		/* extension bit */

		err = pctxt.EncBit(true)

		_, err = pctxt.PerEncUnconsLen(nitems)
	}

	if nitems > 0 {
		pctxt.PerEncBufAlign()
	}
	err = pctxt.PerEncRestrStringData(string(value), "", 8)

	return
}

// PerDecodeAMFPointer method implementation
func PerDecodeAMFPointer(pctxt *asn1rt.OSRTContext) (value AMFPointer, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 6
	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}
	value = AMFPointer(tmpval)
	return
}

// PerEncodeAMFPointer method implementation
func PerEncodeAMFPointer(pctxt *asn1rt.OSRTContext, value AMFPointer) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 6 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))
	return
}

// PerDecodeAMFRegionID method implementation
func PerDecodeAMFRegionID(pctxt *asn1rt.OSRTContext) (value AMFRegionID, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 8
	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}
	value = AMFRegionID(tmpval)
	return
}

// PerEncodeAMFRegionID method implementation
func PerEncodeAMFRegionID(pctxt *asn1rt.OSRTContext, value AMFRegionID) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 8 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))
	return
}

// PerDecodeAMFSetID method implementation
func PerDecodeAMFSetID(pctxt *asn1rt.OSRTContext) (value AMFSetID, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 10
	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}
	value = AMFSetID(tmpval)
	return
}

// PerEncodeAMFSetID method implementation
func PerEncodeAMFSetID(pctxt *asn1rt.OSRTContext, value AMFSetID) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 10 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))
	return
}

// PerDecodeAMFUENGAPID method implementation
func PerDecodeAMFUENGAPID(pctxt *asn1rt.OSRTContext) (value AMFUENGAPID, err error) {
	var tmpval uint64
	tmpval, err = pctxt.PerDecConsWholeNumRangeGT64K(3)
	value = AMFUENGAPID(tmpval)

	if value > 1099511627775 {
		err = pctxt.ErrValueConsVio(value)
		return
	}

	return
}

// PerEncodeAMFUENGAPID method implementation
func PerEncodeAMFUENGAPID(pctxt *asn1rt.OSRTContext, value AMFUENGAPID) (err error) {
	if value <= 1099511627775 {
		err = pctxt.PerEncConsWholeNumRangeGT64K(uint64(value), 3)
	} else {
		err = pctxt.ErrValueConsVio(value)
		return
	}

	return
}

// PerDecodeBitRate method implementation
func PerDecodeBitRate(pctxt *asn1rt.OSRTContext) (value BitRate, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if !extbit {
		var tmpval uint64
		tmpval, err = pctxt.PerDecConsWholeNumRangeGT64K(3)
		value = BitRate(tmpval)

		if value > 4000000000000 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

	} else {
		pctxt.AlignBuffer()

		{
			var len0 byte

			len0, err = pctxt.DecByte()

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = BitRate(tmpval)
		}
	}
	return
}

// PerEncodeBitRate method implementation
func PerEncodeBitRate(pctxt *asn1rt.OSRTContext, value BitRate) (err error) {
	var extbit bool
	if value <= 4000000000000 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	err = pctxt.EncBit(extbit)

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		err = pctxt.PerEncConsWholeNumRangeGT64K(uint64(value), 3)
	}
	return
}

// PerDecodeCauseMisc method implementation
func PerDecodeCauseMisc(pctxt *asn1rt.OSRTContext) (value CauseMisc, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = CauseMiscUNKNOWN
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(3)
		value = CauseMisc(tmpval)

		if value > 5 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeCauseMisc method implementation
func PerEncodeCauseMisc(pctxt *asn1rt.OSRTContext, value CauseMisc) (err error) {
	if value >= 6 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(value), 3)
	return
}

// PerDecodeCauseNas method implementation
func PerDecodeCauseNas(pctxt *asn1rt.OSRTContext) (value CauseNas, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = CauseNasUNKNOWN
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(2)
		value = CauseNas(tmpval)

	}
	return
}

// PerEncodeCauseNas method implementation
func PerEncodeCauseNas(pctxt *asn1rt.OSRTContext, value CauseNas) (err error) {
	if value >= 4 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(value), 2)
	return
}

// PerDecodeCauseProtocol method implementation
func PerDecodeCauseProtocol(pctxt *asn1rt.OSRTContext) (value CauseProtocol, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = CauseProtocolUNKNOWN
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(3)
		value = CauseProtocol(tmpval)

		if value > 6 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeCauseProtocol method implementation
func PerEncodeCauseProtocol(pctxt *asn1rt.OSRTContext, value CauseProtocol) (err error) {
	if value >= 7 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(value), 3)
	return
}

// PerDecodeCauseRadioNetwork method implementation
func PerDecodeCauseRadioNetwork(pctxt *asn1rt.OSRTContext) (value CauseRadioNetwork, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		var ui uint64
		ui, err = pctxt.PerDecSmallNonNegWholeNumber()

		switch ui {
		case 0:
			value = 45
		case 1:
			value = 46
		case 2:
			value = 47
		default:
			value = CauseRadioNetworkUNKNOWN
		}
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(6)
		value = CauseRadioNetwork(tmpval)

		if value > 44 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeCauseRadioNetwork method implementation
func PerEncodeCauseRadioNetwork(pctxt *asn1rt.OSRTContext, value CauseRadioNetwork) (err error) {
	var extbit bool
	if value >= 48 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	extbit = (value > 44)

	/* extension bit */

	err = pctxt.EncBit(extbit)

	if extbit {
		err = pctxt.PerEncSmallNonNegWholeNumber(uint64(value) - 45)
	} else {
		err = pctxt.PerEncBitsFromUInt(uint64(value), 6)
	}
	return
}

// PerDecodeCauseTransport method implementation
func PerDecodeCauseTransport(pctxt *asn1rt.OSRTContext) (value CauseTransport, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = CauseTransportUNKNOWN
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = CauseTransport(tmpval)

	}
	return
}

// PerEncodeCauseTransport method implementation
func PerEncodeCauseTransport(pctxt *asn1rt.OSRTContext, value CauseTransport) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)
	return
}

// PerDecodeEUTRACellIdentity method implementation
func PerDecodeEUTRACellIdentity(pctxt *asn1rt.OSRTContext) (value EUTRACellIdentity, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 28
	pctxt.AlignBuffer()

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}
	value = EUTRACellIdentity(tmpval)
	return
}

// PerEncodeEUTRACellIdentity method implementation
func PerEncodeEUTRACellIdentity(pctxt *asn1rt.OSRTContext, value EUTRACellIdentity) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 28 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	pctxt.PerEncBufAlign()

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))
	return
}

// PerDecodeEUTRAencryptionAlgorithms method implementation
func PerDecodeEUTRAencryptionAlgorithms(pctxt *asn1rt.OSRTContext) (value EUTRAencryptionAlgorithms, err error) {
	var tmpval asn1rt.BitString
	var extbit bool
	var nitems uint64
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		nitems = 16
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	tmpval.BitLength = int(nitems)
	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = EUTRAencryptionAlgorithms(tmpval)
	return
}

// PerEncodeEUTRAencryptionAlgorithms method implementation
func PerEncodeEUTRAencryptionAlgorithms(pctxt *asn1rt.OSRTContext, value EUTRAencryptionAlgorithms) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 16 {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(false)

		pctxt.DiagSetBitFieldCount()

	} else {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(true)

		pctxt.DiagSetBitFieldCount()

		_, err = pctxt.PerEncUnconsLen(nitems)
	}
	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeEUTRAintegrityProtectionAlgorithms method implementation
func PerDecodeEUTRAintegrityProtectionAlgorithms(pctxt *asn1rt.OSRTContext) (value EUTRAintegrityProtectionAlgorithms, err error) {
	var tmpval asn1rt.BitString
	var extbit bool
	var nitems uint64
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		nitems = 16
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	tmpval.BitLength = int(nitems)
	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = EUTRAintegrityProtectionAlgorithms(tmpval)
	return
}

// PerEncodeEUTRAintegrityProtectionAlgorithms method implementation
func PerEncodeEUTRAintegrityProtectionAlgorithms(pctxt *asn1rt.OSRTContext, value EUTRAintegrityProtectionAlgorithms) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 16 {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(false)

		pctxt.DiagSetBitFieldCount()

	} else {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(true)

		pctxt.DiagSetBitFieldCount()

		_, err = pctxt.PerEncUnconsLen(nitems)
	}
	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeExpectedActivityPeriod method implementation
func PerDecodeExpectedActivityPeriod(pctxt *asn1rt.OSRTContext) (value ExpectedActivityPeriod, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(8)
		value = ExpectedActivityPeriod(tmpval)

		if value > 180 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

		value += 1

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = ExpectedActivityPeriod(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeExpectedActivityPeriod method implementation
func PerEncodeExpectedActivityPeriod(pctxt *asn1rt.OSRTContext, value ExpectedActivityPeriod) (err error) {
	var extbit bool
	if (value >= 1 && value <= 30) || value == 40 || value == 50 || value == 60 || value == 80 || value == 100 || value == 120 || value == 150 || value == 180 || value == 181 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 8)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeExpectedHOInterval method implementation
func PerDecodeExpectedHOInterval(pctxt *asn1rt.OSRTContext) (value ExpectedHOInterval, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = ExpectedHOIntervalUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(3)
		value = ExpectedHOInterval(tmpval)

		pctxt.DiagSetBitFieldCount()

		if value > 6 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeExpectedHOInterval method implementation
func PerEncodeExpectedHOInterval(pctxt *asn1rt.OSRTContext, value ExpectedHOInterval) (err error) {
	if value >= 7 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 3)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeExpectedIdlePeriod method implementation
func PerDecodeExpectedIdlePeriod(pctxt *asn1rt.OSRTContext) (value ExpectedIdlePeriod, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(8)
		value = ExpectedIdlePeriod(tmpval)

		if value > 180 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

		value += 1

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = ExpectedIdlePeriod(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeExpectedIdlePeriod method implementation
func PerEncodeExpectedIdlePeriod(pctxt *asn1rt.OSRTContext, value ExpectedIdlePeriod) (err error) {
	var extbit bool
	if (value >= 1 && value <= 30) || value == 40 || value == 50 || value == 60 || value == 80 || value == 100 || value == 120 || value == 150 || value == 180 || value == 181 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 8)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeExpectedUEMobility method implementation
func PerDecodeExpectedUEMobility(pctxt *asn1rt.OSRTContext) (value ExpectedUEMobility, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = ExpectedUEMobilityUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = ExpectedUEMobility(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeExpectedUEMobility method implementation
func PerEncodeExpectedUEMobility(pctxt *asn1rt.OSRTContext, value ExpectedUEMobility) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeFiveGTMSI method implementation
func PerDecodeFiveGTMSI(pctxt *asn1rt.OSRTContext) (value FiveGTMSI, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(4)
	if err != nil {
		return
	}
	return
}

// PerEncodeFiveGTMSI method implementation
func PerEncodeFiveGTMSI(pctxt *asn1rt.OSRTContext, value FiveGTMSI) (err error) {
	if len(value) != 4 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeIndexToRFSP method implementation
func PerDecodeIndexToRFSP(pctxt *asn1rt.OSRTContext) (value IndexToRFSP, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if !extbit {
		pctxt.AlignBuffer()

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(8)
		value = IndexToRFSP(tmpval)

		value += 1

	} else {
		pctxt.AlignBuffer()

		{
			var len0 byte

			len0, err = pctxt.DecByte()

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = IndexToRFSP(tmpval)
		}
	}
	return
}

// PerEncodeIndexToRFSP method implementation
func PerEncodeIndexToRFSP(pctxt *asn1rt.OSRTContext, value IndexToRFSP) (err error) {
	var extbit bool
	if value >= 1 && value <= 256 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	err = pctxt.EncBit(extbit)

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.PerEncBufAlign()

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 8)
	}
	return
}

// PerDecodeNASPDU method implementation
func PerDecodeNASPDU(pctxt *asn1rt.OSRTContext) (value NASPDU, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.PerDecUnconsOctStr()
	if err != nil {
		return
	}
	return
}

// PerEncodeNASPDU method implementation
func PerEncodeNASPDU(pctxt *asn1rt.OSRTContext, value NASPDU) (err error) {
	err = pctxt.PerEncUnconsOctStr(value)
	return
}

// PerDecodeNRCellIdentity method implementation
func PerDecodeNRCellIdentity(pctxt *asn1rt.OSRTContext) (value NRCellIdentity, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 36
	pctxt.AlignBuffer()

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}
	value = NRCellIdentity(tmpval)
	return
}

// PerEncodeNRCellIdentity method implementation
func PerEncodeNRCellIdentity(pctxt *asn1rt.OSRTContext, value NRCellIdentity) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 36 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	pctxt.PerEncBufAlign()

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))
	return
}

// PerDecodeNRencryptionAlgorithms method implementation
func PerDecodeNRencryptionAlgorithms(pctxt *asn1rt.OSRTContext) (value NRencryptionAlgorithms, err error) {
	var tmpval asn1rt.BitString
	var extbit bool
	var nitems uint64
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		nitems = 16
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	tmpval.BitLength = int(nitems)
	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = NRencryptionAlgorithms(tmpval)
	return
}

// PerEncodeNRencryptionAlgorithms method implementation
func PerEncodeNRencryptionAlgorithms(pctxt *asn1rt.OSRTContext, value NRencryptionAlgorithms) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 16 {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(false)

		pctxt.DiagSetBitFieldCount()

	} else {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(true)

		pctxt.DiagSetBitFieldCount()

		_, err = pctxt.PerEncUnconsLen(nitems)
	}
	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodePagingDRX method implementation
func PerDecodePagingDRX(pctxt *asn1rt.OSRTContext) (value PagingDRX, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = PagingDRXUNKNOWN
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(2)
		value = PagingDRX(tmpval)

	}
	return
}

// PerEncodePagingDRX method implementation
func PerEncodePagingDRX(pctxt *asn1rt.OSRTContext, value PagingDRX) (err error) {
	if value >= 4 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(value), 2)
	return
}

// PerDecodePLMNIdentity method implementation
func PerDecodePLMNIdentity(pctxt *asn1rt.OSRTContext) (value PLMNIdentity, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(3)
	if err != nil {
		return
	}
	return
}

// PerEncodePLMNIdentity method implementation
func PerEncodePLMNIdentity(pctxt *asn1rt.OSRTContext, value PLMNIdentity) (err error) {
	if len(value) != 3 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodePortNumber method implementation
func PerDecodePortNumber(pctxt *asn1rt.OSRTContext) (value PortNumber, err error) {
	value, err = pctxt.DecBytesCopy(2)
	if err != nil {
		return
	}
	return
}

// PerEncodePortNumber method implementation
func PerEncodePortNumber(pctxt *asn1rt.OSRTContext, value PortNumber) (err error) {
	if len(value) != 2 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeRANNodeName method implementation
func PerDecodeRANNodeName(pctxt *asn1rt.OSRTContext) (value RANNodeName, err error) {
	var extbit bool
	var nitems uint64
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if !extbit {
		nitems, err = pctxt.PerDecConsLength(8, 1)
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	pctxt.AlignBuffer()

	var tmpval string
	tmpval, err = pctxt.PerDecRestrStringData(nitems, "", 8)
	value = RANNodeName(tmpval)
	return
}

// PerEncodeRANNodeName method implementation
func PerEncodeRANNodeName(pctxt *asn1rt.OSRTContext, value RANNodeName) (err error) {
	var nitems uint64
	nitems = uint64(len(value))
	if nitems >= 1 && nitems <= 150 {
		/* extension bit */

		err = pctxt.EncBit(false)

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)

	} else {
		/* extension bit */

		err = pctxt.EncBit(true)

		_, err = pctxt.PerEncUnconsLen(nitems)
	}

	if nitems > 0 {
		pctxt.PerEncBufAlign()
	}
	err = pctxt.PerEncRestrStringData(string(value), "", 8)

	return
}

// PerDecodeRANPagingPriority method implementation
func PerDecodeRANPagingPriority(pctxt *asn1rt.OSRTContext) (value RANPagingPriority, err error) {
	pctxt.AlignBuffer()

	var tmpval uint64
	tmpval, err = pctxt.PerDecBitsToUInt(8)
	value = RANPagingPriority(tmpval)

	value += 1

	return
}

// PerEncodeRANPagingPriority method implementation
func PerEncodeRANPagingPriority(pctxt *asn1rt.OSRTContext, value RANPagingPriority) (err error) {
	if value >= 1 && value <= 256 {
		pctxt.PerEncBufAlign()

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 8)
	} else {
		err = pctxt.ErrValueConsVio(value)
		return
	}

	return
}

// PerDecodeRANUENGAPID method implementation
func PerDecodeRANUENGAPID(pctxt *asn1rt.OSRTContext) (value RANUENGAPID, err error) {
	var tmpval uint64
	tmpval, err = pctxt.PerDecConsWholeNumRangeGT64K(2)
	value = RANUENGAPID(tmpval)

	if value > 4294967295 {
		err = pctxt.ErrValueConsVio(value)
		return
	}

	return
}

// PerEncodeRANUENGAPID method implementation
func PerEncodeRANUENGAPID(pctxt *asn1rt.OSRTContext, value RANUENGAPID) (err error) {
	if value <= 4294967295 {
		err = pctxt.PerEncConsWholeNumRangeGT64K(uint64(value), 2)
	} else {
		err = pctxt.ErrValueConsVio(value)
		return
	}

	return
}

// PerDecodeRATRestrictionInformation method implementation
func PerDecodeRATRestrictionInformation(pctxt *asn1rt.OSRTContext) (value RATRestrictionInformation, err error) {
	var tmpval asn1rt.BitString
	var extbit bool
	var nitems uint64
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if !extbit {
		nitems = 8
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	tmpval.BitLength = int(nitems)
	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}
	value = RATRestrictionInformation(tmpval)
	return
}

// PerEncodeRATRestrictionInformation method implementation
func PerEncodeRATRestrictionInformation(pctxt *asn1rt.OSRTContext, value RATRestrictionInformation) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 8 {
		/* extension bit */

		err = pctxt.EncBit(false)

	} else {
		/* extension bit */

		err = pctxt.EncBit(true)

		_, err = pctxt.PerEncUnconsLen(nitems)
	}
	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))
	return
}

// PerDecodeRedirectionVoiceFallback method implementation
func PerDecodeRedirectionVoiceFallback(pctxt *asn1rt.OSRTContext) (value RedirectionVoiceFallback, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = RedirectionVoiceFallbackUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = RedirectionVoiceFallback(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeRedirectionVoiceFallback method implementation
func PerEncodeRedirectionVoiceFallback(pctxt *asn1rt.OSRTContext, value RedirectionVoiceFallback) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeRRCEstablishmentCause method implementation
func PerDecodeRRCEstablishmentCause(pctxt *asn1rt.OSRTContext) (value RRCEstablishmentCause, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		var ui uint64
		ui, err = pctxt.PerDecSmallNonNegWholeNumber()

		switch ui {
		case 0:
			value = 10
		default:
			value = RRCEstablishmentCauseUNKNOWN
		}
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(4)
		value = RRCEstablishmentCause(tmpval)

		if value > 9 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeRRCEstablishmentCause method implementation
func PerEncodeRRCEstablishmentCause(pctxt *asn1rt.OSRTContext, value RRCEstablishmentCause) (err error) {
	var extbit bool
	if value >= 11 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	extbit = (value > 9)

	/* extension bit */

	err = pctxt.EncBit(extbit)

	if extbit {
		err = pctxt.PerEncSmallNonNegWholeNumber(uint64(value) - 10)
	} else {
		err = pctxt.PerEncBitsFromUInt(uint64(value), 4)
	}
	return
}

// PerDecodeRelativeAMFCapacity method implementation
func PerDecodeRelativeAMFCapacity(pctxt *asn1rt.OSRTContext) (value RelativeAMFCapacity, err error) {
	pctxt.AlignBuffer()

	var tmpval uint64
	tmpval, err = pctxt.PerDecBitsToUInt(8)
	value = RelativeAMFCapacity(tmpval)

	return
}

// PerEncodeRelativeAMFCapacity method implementation
func PerEncodeRelativeAMFCapacity(pctxt *asn1rt.OSRTContext, value RelativeAMFCapacity) (err error) {
	pctxt.PerEncBufAlign()

	err = pctxt.PerEncBitsFromUInt(uint64(value), 8)

	return
}

// PerDecodeSD method implementation
func PerDecodeSD(pctxt *asn1rt.OSRTContext) (value SD, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(3)
	if err != nil {
		return
	}
	return
}

// PerEncodeSD method implementation
func PerEncodeSD(pctxt *asn1rt.OSRTContext, value SD) (err error) {
	if len(value) != 3 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeSecurityKey method implementation
func PerDecodeSecurityKey(pctxt *asn1rt.OSRTContext) (value SecurityKey, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 256
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}

	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = SecurityKey(tmpval)
	return
}

// PerEncodeSecurityKey method implementation
func PerEncodeSecurityKey(pctxt *asn1rt.OSRTContext, value SecurityKey) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 256 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	pctxt.PerEncBufAlign()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeSourceOfUEActivityBehaviourInformation method implementation
func PerDecodeSourceOfUEActivityBehaviourInformation(pctxt *asn1rt.OSRTContext) (value SourceOfUEActivityBehaviourInformation, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = SourceOfUEActivityBehaviourInformationUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = SourceOfUEActivityBehaviourInformation(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeSourceOfUEActivityBehaviourInformation method implementation
func PerEncodeSourceOfUEActivityBehaviourInformation(pctxt *asn1rt.OSRTContext, value SourceOfUEActivityBehaviourInformation) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeConfiguredNSSAI method implementation
func PerDecodeConfiguredNSSAI(pctxt *asn1rt.OSRTContext) (value ConfiguredNSSAI, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(128)
	if err != nil {
		return
	}
	return
}

// PerEncodeConfiguredNSSAI method implementation
func PerEncodeConfiguredNSSAI(pctxt *asn1rt.OSRTContext, value ConfiguredNSSAI) (err error) {
	if len(value) != 128 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeRejectedNSSAIinPLMN method implementation
func PerDecodeRejectedNSSAIinPLMN(pctxt *asn1rt.OSRTContext) (value RejectedNSSAIinPLMN, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(32)
	if err != nil {
		return
	}
	return
}

// PerEncodeRejectedNSSAIinPLMN method implementation
func PerEncodeRejectedNSSAIinPLMN(pctxt *asn1rt.OSRTContext, value RejectedNSSAIinPLMN) (err error) {
	if len(value) != 32 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeRejectedNSSAIinTA method implementation
func PerDecodeRejectedNSSAIinTA(pctxt *asn1rt.OSRTContext) (value RejectedNSSAIinTA, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(32)
	if err != nil {
		return
	}
	return
}

// PerEncodeRejectedNSSAIinTA method implementation
func PerEncodeRejectedNSSAIinTA(pctxt *asn1rt.OSRTContext, value RejectedNSSAIinTA) (err error) {
	if len(value) != 32 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeSST method implementation
func PerDecodeSST(pctxt *asn1rt.OSRTContext) (value SST, err error) {
	value, err = pctxt.DecBytesCopy(1)
	if err != nil {
		return
	}
	return
}

// PerEncodeSST method implementation
func PerEncodeSST(pctxt *asn1rt.OSRTContext, value SST) (err error) {
	if len(value) != 1 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeTAC method implementation
func PerDecodeTAC(pctxt *asn1rt.OSRTContext) (value TAC, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(3)
	if err != nil {
		return
	}
	return
}

// PerEncodeTAC method implementation
func PerEncodeTAC(pctxt *asn1rt.OSRTContext, value TAC) (err error) {
	if len(value) != 3 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeTimeStamp method implementation
func PerDecodeTimeStamp(pctxt *asn1rt.OSRTContext) (value TimeStamp, err error) {
	pctxt.AlignBuffer()

	value, err = pctxt.DecBytesCopy(4)
	if err != nil {
		return
	}
	return
}

// PerEncodeTimeStamp method implementation
func PerEncodeTimeStamp(pctxt *asn1rt.OSRTContext, value TimeStamp) (err error) {
	if len(value) != 4 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	err = pctxt.EncBytes(value[:])
	return
}

// PerDecodeTraceDepth method implementation
func PerDecodeTraceDepth(pctxt *asn1rt.OSRTContext) (value TraceDepth, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = TraceDepthUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(3)
		value = TraceDepth(tmpval)

		pctxt.DiagSetBitFieldCount()

		if value > 5 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeTraceDepth method implementation
func PerEncodeTraceDepth(pctxt *asn1rt.OSRTContext, value TraceDepth) (err error) {
	if value >= 6 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 3)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeTimeToWait method implementation
func PerDecodeTimeToWait(pctxt *asn1rt.OSRTContext) (value TimeToWait, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = TimeToWaitUNKNOWN
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(3)
		value = TimeToWait(tmpval)

		if value > 5 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeTimeToWait method implementation
func PerEncodeTimeToWait(pctxt *asn1rt.OSRTContext, value TimeToWait) (err error) {
	if value >= 6 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(value), 3)
	return
}

// PerDecodeTransportLayerAddress method implementation
func PerDecodeTransportLayerAddress(pctxt *asn1rt.OSRTContext) (value TransportLayerAddress, err error) {
	var tmpval asn1rt.BitString
	var extbit bool
	var nitems uint64
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if !extbit {
		nitems, err = pctxt.PerDecConsLength(8, 1)
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	tmpval.BitLength = int(nitems)
	pctxt.AlignBuffer()

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}
	value = TransportLayerAddress(tmpval)
	return
}

// PerEncodeTransportLayerAddress method implementation
func PerEncodeTransportLayerAddress(pctxt *asn1rt.OSRTContext, value TransportLayerAddress) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems >= 1 && nitems <= 160 {
		/* extension bit */

		err = pctxt.EncBit(false)

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)

	} else {
		/* extension bit */

		err = pctxt.EncBit(true)

		_, err = pctxt.PerEncUnconsLen(nitems)
	}
	pctxt.PerEncBufAlign()

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))
	return
}

// PerDecodeTypeOfError method implementation
func PerDecodeTypeOfError(pctxt *asn1rt.OSRTContext) (value TypeOfError, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = TypeOfErrorUNKNOWN
	} else {
		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = TypeOfError(tmpval)

	}
	return
}

// PerEncodeTypeOfError method implementation
func PerEncodeTypeOfError(pctxt *asn1rt.OSRTContext, value TypeOfError) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)
	return
}

// PerDecodeUERadioCapability method implementation
func PerDecodeUERadioCapability(pctxt *asn1rt.OSRTContext) (value UERadioCapability, err error) {
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}
	value, err = pctxt.PerDecUnconsOctStr()
	if err != nil {
		return
	}
	return
}

// PerEncodeUERadioCapability method implementation
func PerEncodeUERadioCapability(pctxt *asn1rt.OSRTContext, value UERadioCapability) (err error) {
	err = pctxt.PerEncUnconsOctStr(value)
	return
}

// PerDecodeUERadioCapabilityForPagingOfNR method implementation
func PerDecodeUERadioCapabilityForPagingOfNR(pctxt *asn1rt.OSRTContext) (value UERadioCapabilityForPagingOfNR, err error) {
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}
	value, err = pctxt.PerDecUnconsOctStr()
	if err != nil {
		return
	}
	return
}

// PerEncodeUERadioCapabilityForPagingOfNR method implementation
func PerEncodeUERadioCapabilityForPagingOfNR(pctxt *asn1rt.OSRTContext, value UERadioCapabilityForPagingOfNR) (err error) {
	err = pctxt.PerEncUnconsOctStr(value)
	return
}

// PerDecodeUERadioCapabilityForPagingOfEUTRA method implementation
func PerDecodeUERadioCapabilityForPagingOfEUTRA(pctxt *asn1rt.OSRTContext) (value UERadioCapabilityForPagingOfEUTRA, err error) {
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}
	value, err = pctxt.PerDecUnconsOctStr()
	if err != nil {
		return
	}
	return
}

// PerEncodeUERadioCapabilityForPagingOfEUTRA method implementation
func PerEncodeUERadioCapabilityForPagingOfEUTRA(pctxt *asn1rt.OSRTContext, value UERadioCapabilityForPagingOfEUTRA) (err error) {
	err = pctxt.PerEncUnconsOctStr(value)
	return
}

// PerDecodeUEContextRequest method implementation
func PerDecodeUEContextRequest(pctxt *asn1rt.OSRTContext) (value UEContextRequest, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = UEContextRequestUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeUEContextRequest method implementation
func PerEncodeUEContextRequest(pctxt *asn1rt.OSRTContext, value UEContextRequest) (err error) {
	var ui uint64
	switch value {
	case UEContextRequestRequested:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)
	return
}

// PerDecodeUERetentionInformation method implementation
func PerDecodeUERetentionInformation(pctxt *asn1rt.OSRTContext) (value UERetentionInformation, err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	if extbit {
		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		value = UERetentionInformationUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeUERetentionInformation method implementation
func PerEncodeUERetentionInformation(pctxt *asn1rt.OSRTContext, value UERetentionInformation) (err error) {
	var ui uint64
	switch value {
	case UERetentionInformationUesRetained:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	err = pctxt.EncBit(false)

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)
	return
}

// PerDecode method implementation
func (pvalue *SNSSAI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode sST

	pctxt.PushElemName("sST")

	pvalue.SST, err = PerDecodeSST(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode sD

	if present[optx] {
		pctxt.PushElemName("sD")

		pvalue.SD = new(SD)
		(*pvalue.SD), err = PerDecodeSD(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.SD = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *SNSSAI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.SD != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode sST

	pctxt.PushElemName("sST")

	err = PerEncodeSST(pctxt, pvalue.SST)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode sD

	if pvalue.SD != nil {
		pctxt.PushElemName("sD")

		err = PerEncodeSD(pctxt, (*pvalue.SD))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AllowedNSSAIItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AllowedNSSAIItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AllowedNSSAI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(3, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 AllowedNSSAIItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *AllowedNSSAI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 8 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 3)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("AllowedNSSAI-Item", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *AllowedTACs) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 TAC
			elem1, err = PerDecodeTAC(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *AllowedTACs) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("TAC", xx1)

		err = PerEncodeTAC(pctxt, (*pvalue)[xx1])

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *SliceSupportItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *SliceSupportItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *SliceSupportList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.AlignBuffer()

		nitems, err = pctxt.PerDecConsLength(16, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 SliceSupportItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *SliceSupportList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 1024 {
		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 16)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("SliceSupportItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *BroadcastPLMNItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode tAISliceSupportList

	pctxt.PushElemName("tAISliceSupportList")

	err = pvalue.TAISliceSupportList.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *BroadcastPLMNItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode tAISliceSupportList

	pctxt.PushElemName("tAISliceSupportList")

	err = pvalue.TAISliceSupportList.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *BroadcastPLMNList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 BroadcastPLMNItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *BroadcastPLMNList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 12 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("BroadcastPLMNItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *Cause) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	idx, err = pctxt.PerDecBitsToUInt(3)
	switch idx {
	/* radioNetwork */
	case 0:
		(*pvalue).T = CauseRadioNetworkTAG
		pctxt.PushElemName("radioNetwork")

		pvalue.U.RadioNetwork = new(CauseRadioNetwork)
		(*pvalue.U.RadioNetwork), err = PerDecodeCauseRadioNetwork(pctxt)
		pctxt.PopElemName()

	/* transport */
	case 1:
		(*pvalue).T = CauseTransportTAG
		pctxt.PushElemName("transport")

		pvalue.U.Transport = new(CauseTransport)
		(*pvalue.U.Transport), err = PerDecodeCauseTransport(pctxt)
		pctxt.PopElemName()

	/* nas */
	case 2:
		(*pvalue).T = CauseNasTAG
		pctxt.PushElemName("nas")

		pvalue.U.Nas = new(CauseNas)
		(*pvalue.U.Nas), err = PerDecodeCauseNas(pctxt)
		pctxt.PopElemName()

	/* protocol */
	case 3:
		(*pvalue).T = CauseProtocolTAG
		pctxt.PushElemName("protocol")

		pvalue.U.Protocol = new(CauseProtocol)
		(*pvalue.U.Protocol), err = PerDecodeCauseProtocol(pctxt)
		pctxt.PopElemName()

	/* misc */
	case 4:
		(*pvalue).T = CauseMiscTAG
		pctxt.PushElemName("misc")

		pvalue.U.Misc = new(CauseMisc)
		(*pvalue.U.Misc), err = PerDecodeCauseMisc(pctxt)
		pctxt.PopElemName()

	/* choice_Extensions */
	case 5:
		(*pvalue).T = CauseChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *Cause) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case CauseRadioNetworkTAG:
		idx = 0
	case CauseTransportTAG:
		idx = 1
	case CauseNasTAG:
		idx = 2
	case CauseProtocolTAG:
		idx = 3
	case CauseMiscTAG:
		idx = 4
	case CauseChoiceExtensionsTAG:
		idx = 5
	}
	/* Encode choice index value */

	err = pctxt.PerEncBitsFromUInt(idx, 3)
	if err != nil {
		return
	}

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode radioNetwork

		if pvalue.U.RadioNetwork == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("radioNetwork")

		alt := CauseRadioNetwork((*pvalue.U.RadioNetwork))
		err = PerEncodeCauseRadioNetwork(pctxt, alt)

		pctxt.PopElemName()

	case 1:
		// encode transport

		if pvalue.U.Transport == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("transport")

		alt := CauseTransport((*pvalue.U.Transport))
		err = PerEncodeCauseTransport(pctxt, alt)

		pctxt.PopElemName()

	case 2:
		// encode nas

		if pvalue.U.Nas == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("nas")

		alt := CauseNas((*pvalue.U.Nas))
		err = PerEncodeCauseNas(pctxt, alt)

		pctxt.PopElemName()

	case 3:
		// encode protocol

		if pvalue.U.Protocol == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("protocol")

		alt := CauseProtocol((*pvalue.U.Protocol))
		err = PerEncodeCauseProtocol(pctxt, alt)

		pctxt.PopElemName()

	case 4:
		// encode misc

		if pvalue.U.Misc == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("misc")

		alt := CauseMisc((*pvalue.U.Misc))
		err = PerEncodeCauseMisc(pctxt, alt)

		pctxt.PopElemName()

	case 5:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *CriticalityDiagnosticsIEItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode iECriticality

	pctxt.PushElemName("iECriticality")

	pvalue.IECriticality, err = PerDecodeCriticality(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_ID

	pctxt.PushElemName("iE-ID")

	pvalue.IEID, err = PerDecodeProtocolIEID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode typeOfError

	pctxt.PushElemName("typeOfError")

	pvalue.TypeOfError, err = PerDecodeTypeOfError(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *CriticalityDiagnosticsIEItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode iECriticality

	pctxt.PushElemName("iECriticality")

	err = PerEncodeCriticality(pctxt, pvalue.IECriticality)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_ID

	pctxt.PushElemName("iE-ID")

	err = PerEncodeProtocolIEID(pctxt, pvalue.IEID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode typeOfError

	pctxt.PushElemName("typeOfError")

	err = PerEncodeTypeOfError(pctxt, pvalue.TypeOfError)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *CriticalityDiagnosticsIEList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.AlignBuffer()

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 CriticalityDiagnosticsIEItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *CriticalityDiagnosticsIEList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("CriticalityDiagnostics-IE-Item", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *CriticalityDiagnostics) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [5]bool
	var optx int
	for optx = 0; optx < 5; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode procedureCode

	if present[optx] {
		pctxt.PushElemName("procedureCode")

		pvalue.ProcedureCode = new(ProcedureCode)
		(*pvalue.ProcedureCode), err = PerDecodeProcedureCode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ProcedureCode = nil
	}
	optx++

	// decode triggeringMessage

	if present[optx] {
		pctxt.PushElemName("triggeringMessage")

		pvalue.TriggeringMessage = new(TriggeringMessage)
		(*pvalue.TriggeringMessage), err = PerDecodeTriggeringMessage(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.TriggeringMessage = nil
	}
	optx++

	// decode procedureCriticality

	if present[optx] {
		pctxt.PushElemName("procedureCriticality")

		pvalue.ProcedureCriticality = new(Criticality)
		(*pvalue.ProcedureCriticality), err = PerDecodeCriticality(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ProcedureCriticality = nil
	}
	optx++

	// decode iEsCriticalityDiagnostics

	if present[optx] {
		pctxt.PushElemName("iEsCriticalityDiagnostics")

		err = pvalue.IEsCriticalityDiagnostics.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *CriticalityDiagnostics) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.ProcedureCode != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.TriggeringMessage != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.ProcedureCriticality != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEsCriticalityDiagnostics != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode procedureCode

	if pvalue.ProcedureCode != nil {
		pctxt.PushElemName("procedureCode")

		err = PerEncodeProcedureCode(pctxt, (*pvalue.ProcedureCode))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode triggeringMessage

	if pvalue.TriggeringMessage != nil {
		pctxt.PushElemName("triggeringMessage")

		err = PerEncodeTriggeringMessage(pctxt, (*pvalue.TriggeringMessage))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode procedureCriticality

	if pvalue.ProcedureCriticality != nil {
		pctxt.PushElemName("procedureCriticality")

		err = PerEncodeCriticality(pctxt, (*pvalue.ProcedureCriticality))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iEsCriticalityDiagnostics

	if pvalue.IEsCriticalityDiagnostics != nil {
		pctxt.PushElemName("iEsCriticalityDiagnostics")

		err = pvalue.IEsCriticalityDiagnostics.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *EquivalentPLMNs) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 PLMNIdentity
			elem1, err = PerDecodePLMNIdentity(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *EquivalentPLMNs) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 15 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PLMNIdentity", xx1)

		err = PerEncodePLMNIdentity(pctxt, (*pvalue)[xx1])

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *EUTRACGI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode eUTRACellIdentity

	pctxt.PushElemName("eUTRACellIdentity")

	pvalue.EUTRACellIdentity, err = PerDecodeEUTRACellIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *EUTRACGI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode eUTRACellIdentity

	pctxt.PushElemName("eUTRACellIdentity")

	err = PerEncodeEUTRACellIdentity(pctxt, pvalue.EUTRACellIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ExpectedUEActivityBehaviour) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode expectedActivityPeriod

	if present[optx] {
		pctxt.PushElemName("expectedActivityPeriod")

		pvalue.ExpectedActivityPeriod = new(ExpectedActivityPeriod)
		(*pvalue.ExpectedActivityPeriod), err = PerDecodeExpectedActivityPeriod(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ExpectedActivityPeriod = nil
	}
	optx++

	// decode expectedIdlePeriod

	if present[optx] {
		pctxt.PushElemName("expectedIdlePeriod")

		pvalue.ExpectedIdlePeriod = new(ExpectedIdlePeriod)
		(*pvalue.ExpectedIdlePeriod), err = PerDecodeExpectedIdlePeriod(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ExpectedIdlePeriod = nil
	}
	optx++

	// decode sourceOfUEActivityBehaviourInformation

	if present[optx] {
		pctxt.PushElemName("sourceOfUEActivityBehaviourInformation")

		pvalue.SourceOfUEActivityBehaviourInformation = new(SourceOfUEActivityBehaviourInformation)
		(*pvalue.SourceOfUEActivityBehaviourInformation), err = PerDecodeSourceOfUEActivityBehaviourInformation(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.SourceOfUEActivityBehaviourInformation = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *ExpectedUEActivityBehaviour) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("expectedActivityPeriod")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedActivityPeriod != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("expectedIdlePeriod")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedIdlePeriod != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("sourceOfUEActivityBehaviourInformation")
	pctxt.DiagNewBitField("present")

	present = pvalue.SourceOfUEActivityBehaviourInformation != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode expectedActivityPeriod

	if pvalue.ExpectedActivityPeriod != nil {
		pctxt.PushElemName("expectedActivityPeriod")

		err = PerEncodeExpectedActivityPeriod(pctxt, (*pvalue.ExpectedActivityPeriod))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode expectedIdlePeriod

	if pvalue.ExpectedIdlePeriod != nil {
		pctxt.PushElemName("expectedIdlePeriod")

		err = PerEncodeExpectedIdlePeriod(pctxt, (*pvalue.ExpectedIdlePeriod))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode sourceOfUEActivityBehaviourInformation

	if pvalue.SourceOfUEActivityBehaviourInformation != nil {
		pctxt.PushElemName("sourceOfUEActivityBehaviourInformation")

		err = PerEncodeSourceOfUEActivityBehaviourInformation(pctxt, (*pvalue.SourceOfUEActivityBehaviourInformation))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ExpectedUEMovingTrajectoryItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode nGRAN_CGI

	pctxt.PushElemName("nGRAN-CGI")

	err = pvalue.NGRANCGI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode timeStayedInCell

	if present[optx] {
		pctxt.PushElemName("timeStayedInCell")

		pvalue.TimeStayedInCell = new(uint64)
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("constrained int")

		(*pvalue.TimeStayedInCell), err = pctxt.PerDecBitsToUInt(16)
		if err != nil {
			return
		}

		if (*pvalue.TimeStayedInCell) > 4095 {
			err = pctxt.ErrValueConsVio((*pvalue.TimeStayedInCell))
			return
		}

		pctxt.DiagSetBitFieldCount()

		pctxt.PopElemName()
	} else {
		pvalue.TimeStayedInCell = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *ExpectedUEMovingTrajectoryItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("timeStayedInCell")
	pctxt.DiagNewBitField("present")

	present = pvalue.TimeStayedInCell != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode nGRAN_CGI

	pctxt.PushElemName("nGRAN-CGI")

	err = pvalue.NGRANCGI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode timeStayedInCell

	if pvalue.TimeStayedInCell != nil {
		pctxt.PushElemName("timeStayedInCell")

		if (*pvalue.TimeStayedInCell) <= 4095 {
			pctxt.PerEncBufAlign()

			pctxt.DiagNewBitField("cons int/uint")

			err = pctxt.PerEncBitsFromUInt(uint64((*pvalue.TimeStayedInCell)), 16)
			if err != nil {
				return
			}

			pctxt.DiagSetBitFieldCount()
		} else {
			err = pctxt.ErrValueConsVio((*pvalue.TimeStayedInCell))
			return
		}

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ExpectedUEMovingTrajectory) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("ExpectedUEMovingTrajectoryItem", i)

			var elem1 ExpectedUEMovingTrajectoryItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *ExpectedUEMovingTrajectory) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("ExpectedUEMovingTrajectoryItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *ExpectedUEBehaviour) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [5]bool
	var optx int
	for optx = 0; optx < 5; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode expectedUEActivityBehaviour

	if present[optx] {
		pctxt.PushElemName("expectedUEActivityBehaviour")

		pvalue.ExpectedUEActivityBehaviour = new(ExpectedUEActivityBehaviour)
		err = pvalue.ExpectedUEActivityBehaviour.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ExpectedUEActivityBehaviour = nil
	}
	optx++

	// decode expectedHOInterval

	if present[optx] {
		pctxt.PushElemName("expectedHOInterval")

		pvalue.ExpectedHOInterval = new(ExpectedHOInterval)
		(*pvalue.ExpectedHOInterval), err = PerDecodeExpectedHOInterval(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ExpectedHOInterval = nil
	}
	optx++

	// decode expectedUEMobility

	if present[optx] {
		pctxt.PushElemName("expectedUEMobility")

		pvalue.ExpectedUEMobility = new(ExpectedUEMobility)
		(*pvalue.ExpectedUEMobility), err = PerDecodeExpectedUEMobility(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ExpectedUEMobility = nil
	}
	optx++

	// decode expectedUEMovingTrajectory

	if present[optx] {
		pctxt.PushElemName("expectedUEMovingTrajectory")

		err = pvalue.ExpectedUEMovingTrajectory.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *ExpectedUEBehaviour) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("expectedUEActivityBehaviour")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedUEActivityBehaviour != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("expectedHOInterval")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedHOInterval != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("expectedUEMobility")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedUEMobility != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("expectedUEMovingTrajectory")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedUEMovingTrajectory != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode expectedUEActivityBehaviour

	if pvalue.ExpectedUEActivityBehaviour != nil {
		pctxt.PushElemName("expectedUEActivityBehaviour")

		err = (*pvalue.ExpectedUEActivityBehaviour).PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode expectedHOInterval

	if pvalue.ExpectedHOInterval != nil {
		pctxt.PushElemName("expectedHOInterval")

		err = PerEncodeExpectedHOInterval(pctxt, (*pvalue.ExpectedHOInterval))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode expectedUEMobility

	if pvalue.ExpectedUEMobility != nil {
		pctxt.PushElemName("expectedUEMobility")

		err = PerEncodeExpectedUEMobility(pctxt, (*pvalue.ExpectedUEMobility))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode expectedUEMovingTrajectory

	if pvalue.ExpectedUEMovingTrajectory != nil {
		pctxt.PushElemName("expectedUEMovingTrajectory")

		err = pvalue.ExpectedUEMovingTrajectory.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *CNAssistedRANTuning) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode expectedUEBehaviour

	if present[optx] {
		pctxt.PushElemName("expectedUEBehaviour")

		pvalue.ExpectedUEBehaviour = new(ExpectedUEBehaviour)
		err = pvalue.ExpectedUEBehaviour.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ExpectedUEBehaviour = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *CNAssistedRANTuning) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("expectedUEBehaviour")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedUEBehaviour != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode expectedUEBehaviour

	if pvalue.ExpectedUEBehaviour != nil {
		pctxt.PushElemName("expectedUEBehaviour")

		err = (*pvalue.ExpectedUEBehaviour).PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *TAIListForInactiveItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *TAIListForInactiveItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *TAIListForInactive) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("TAIListForInactiveItem", i)

			var elem1 TAIListForInactiveItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *TAIListForInactive) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("TAIListForInactiveItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *CoreNetworkAssistanceInformationForInactive) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode uEIdentityIndexValue

	pctxt.PushElemName("uEIdentityIndexValue")

	err = pvalue.UEIdentityIndexValue.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode uESpecificDRX

	if present[optx] {
		pctxt.PushElemName("uESpecificDRX")

		pvalue.UESpecificDRX = new(PagingDRX)
		(*pvalue.UESpecificDRX), err = PerDecodePagingDRX(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.UESpecificDRX = nil
	}
	optx++

	// decode periodicRegistrationUpdateTimer

	pctxt.PushElemName("periodicRegistrationUpdateTimer")

	pvalue.PeriodicRegistrationUpdateTimer, err = PerDecodePeriodicRegistrationUpdateTimer(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode mICOModeIndication

	if present[optx] {
		pctxt.PushElemName("mICOModeIndication")

		pvalue.MICOModeIndication = new(MICOModeIndication)
		(*pvalue.MICOModeIndication), err = PerDecodeMICOModeIndication(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.MICOModeIndication = nil
	}
	optx++

	// decode tAIListForInactive

	pctxt.PushElemName("tAIListForInactive")

	err = pvalue.TAIListForInactive.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode expectedUEBehaviour

	if present[optx] {
		pctxt.PushElemName("expectedUEBehaviour")

		pvalue.ExpectedUEBehaviour = new(ExpectedUEBehaviour)
		err = pvalue.ExpectedUEBehaviour.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ExpectedUEBehaviour = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *CoreNetworkAssistanceInformationForInactive) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("uESpecificDRX")
	pctxt.DiagNewBitField("present")

	present = pvalue.UESpecificDRX != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("mICOModeIndication")
	pctxt.DiagNewBitField("present")

	present = pvalue.MICOModeIndication != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("expectedUEBehaviour")
	pctxt.DiagNewBitField("present")

	present = pvalue.ExpectedUEBehaviour != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode uEIdentityIndexValue

	pctxt.PushElemName("uEIdentityIndexValue")

	err = pvalue.UEIdentityIndexValue.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode uESpecificDRX

	if pvalue.UESpecificDRX != nil {
		pctxt.PushElemName("uESpecificDRX")

		err = PerEncodePagingDRX(pctxt, (*pvalue.UESpecificDRX))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode periodicRegistrationUpdateTimer

	pctxt.PushElemName("periodicRegistrationUpdateTimer")

	err = PerEncodePeriodicRegistrationUpdateTimer(pctxt, pvalue.PeriodicRegistrationUpdateTimer)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode mICOModeIndication

	if pvalue.MICOModeIndication != nil {
		pctxt.PushElemName("mICOModeIndication")

		err = PerEncodeMICOModeIndication(pctxt, (*pvalue.MICOModeIndication))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode tAIListForInactive

	pctxt.PushElemName("tAIListForInactive")

	err = pvalue.TAIListForInactive.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode expectedUEBehaviour

	if pvalue.ExpectedUEBehaviour != nil {
		pctxt.PushElemName("expectedUEBehaviour")

		err = (*pvalue.ExpectedUEBehaviour).PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UEIdentityIndexValue) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	pctxt.DiagNewBitField("<choice-index>")

	idx, err = pctxt.PerDecBitsToUInt(1)
	pctxt.DiagSetBitFieldCount()

	switch idx {
	/* indexLength10 */
	case 0:
		(*pvalue).T = UEIdentityIndexValueIndexLength10TAG
		pctxt.PushElemName("indexLength10")

		pvalue.U.IndexLength10 = new(asn1rt.BitString)
		pvalue.U.IndexLength10.BitLength = 10
		pctxt.DiagNewBitField("data")

		pvalue.U.IndexLength10.Bytes, err = pctxt.DecBits(uint64(pvalue.U.IndexLength10.BitLength))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()
		pctxt.PopElemName()

	/* choice_Extensions */
	case 1:
		(*pvalue).T = UEIdentityIndexValueChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *UEIdentityIndexValue) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case UEIdentityIndexValueIndexLength10TAG:
		idx = 0
	case UEIdentityIndexValueChoiceExtensionsTAG:
		idx = 1
	}
	/* Encode choice index value */

	pctxt.DiagNewBitField("<choice-index>")

	err = pctxt.PerEncBitsFromUInt(idx, 1)
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode indexLength10

		if pvalue.U.IndexLength10 == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("indexLength10")

		alt := asn1rt.BitString((*pvalue.U.IndexLength10))
		{
			var nitems uint64
			nitems = uint64(alt.BitLength)
			if nitems == 10 {
			} else {
				err = pctxt.ErrSizeConsVio(nitems)
				return
			}
		}
		pctxt.DiagNewBitField("data")

		err = pctxt.PerEncBitsFromByteArray(alt.Bytes, uint64(alt.BitLength))

		pctxt.DiagSetBitFieldCount()

		pctxt.PopElemName()

	case 1:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *NGRANCGI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	pctxt.DiagNewBitField("<choice-index>")

	idx, err = pctxt.PerDecBitsToUInt(2)
	pctxt.DiagSetBitFieldCount()

	switch idx {
	/* nR_CGI */
	case 0:
		(*pvalue).T = NGRANCGINRCGITAG
		pctxt.PushElemName("nR-CGI")

		pvalue.U.NRCGI = new(NRCGI)
		err = pvalue.U.NRCGI.PerDecode(pctxt)
		pctxt.PopElemName()

	/* eUTRA_CGI */
	case 1:
		(*pvalue).T = NGRANCGIEUTRACGITAG
		pctxt.PushElemName("eUTRA-CGI")

		pvalue.U.EUTRACGI = new(EUTRACGI)
		err = pvalue.U.EUTRACGI.PerDecode(pctxt)
		pctxt.PopElemName()

	/* choice_Extensions */
	case 2:
		(*pvalue).T = NGRANCGIChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *NGRANCGI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case NGRANCGINRCGITAG:
		idx = 0
	case NGRANCGIEUTRACGITAG:
		idx = 1
	case NGRANCGIChoiceExtensionsTAG:
		idx = 2
	}
	/* Encode choice index value */

	pctxt.DiagNewBitField("<choice-index>")

	err = pctxt.PerEncBitsFromUInt(idx, 2)
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode nR_CGI

		if pvalue.U.NRCGI == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("nR-CGI")

		alt := NRCGI((*pvalue.U.NRCGI))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 1:
		// encode eUTRA_CGI

		if pvalue.U.EUTRACGI == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("eUTRA-CGI")

		alt := EUTRACGI((*pvalue.U.EUTRACGI))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 2:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestCellItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode nGRAN_CGI

	pctxt.PushElemName("nGRAN-CGI")

	err = pvalue.NGRANCGI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestCellItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode nGRAN_CGI

	pctxt.PushElemName("nGRAN-CGI")

	err = pvalue.NGRANCGI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestCellList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("AreaOfInterestCellItem", i)

			var elem1 AreaOfInterestCellItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestCellList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("AreaOfInterestCellItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *FiveGSTMSI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode aMFSetID

	pctxt.PushElemName("aMFSetID")

	pvalue.AMFSetID, err = PerDecodeAMFSetID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode aMFPointer

	pctxt.PushElemName("aMFPointer")

	pvalue.AMFPointer, err = PerDecodeAMFPointer(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode fiveG_TMSI

	pctxt.PushElemName("fiveG-TMSI")

	pvalue.FiveGTMSI, err = PerDecodeFiveGTMSI(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *FiveGSTMSI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode aMFSetID

	pctxt.PushElemName("aMFSetID")

	err = PerEncodeAMFSetID(pctxt, pvalue.AMFSetID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode aMFPointer

	pctxt.PushElemName("aMFPointer")

	err = PerEncodeAMFPointer(pctxt, pvalue.AMFPointer)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode fiveG_TMSI

	pctxt.PushElemName("fiveG-TMSI")

	err = PerEncodeFiveGTMSI(pctxt, pvalue.FiveGTMSI)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ForbiddenTACs) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.AlignBuffer()

		nitems, err = pctxt.PerDecConsLength(16, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 TAC
			elem1, err = PerDecodeTAC(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *ForbiddenTACs) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 4096 {
		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 16)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("TAC", xx1)

		err = PerEncodeTAC(pctxt, (*pvalue)[xx1])

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *ForbiddenAreaInformationItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode forbiddenTACs

	pctxt.PushElemName("forbiddenTACs")

	err = pvalue.ForbiddenTACs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *ForbiddenAreaInformationItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode forbiddenTACs

	pctxt.PushElemName("forbiddenTACs")

	err = pvalue.ForbiddenTACs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ForbiddenAreaInformation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 ForbiddenAreaInformationItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *ForbiddenAreaInformation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("ForbiddenAreaInformation-Item", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *RATRestrictionsItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode rATRestrictionInformation

	pctxt.PushElemName("rATRestrictionInformation")

	pvalue.RATRestrictionInformation, err = PerDecodeRATRestrictionInformation(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *RATRestrictionsItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode rATRestrictionInformation

	pctxt.PushElemName("rATRestrictionInformation")

	err = PerEncodeRATRestrictionInformation(pctxt, pvalue.RATRestrictionInformation)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *RATRestrictions) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 RATRestrictionsItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *RATRestrictions) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("RATRestrictions-Item", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *NotAllowedTACs) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 TAC
			elem1, err = PerDecodeTAC(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *NotAllowedTACs) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("TAC", xx1)

		err = PerEncodeTAC(pctxt, (*pvalue)[xx1])

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *ServiceAreaInformationItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [3]bool
	var optx int
	for optx = 0; optx < 3; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode allowedTACs

	if present[optx] {
		pctxt.PushElemName("allowedTACs")

		err = pvalue.AllowedTACs.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode notAllowedTACs

	if present[optx] {
		pctxt.PushElemName("notAllowedTACs")

		err = pvalue.NotAllowedTACs.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *ServiceAreaInformationItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.AllowedTACs != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.NotAllowedTACs != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode allowedTACs

	if pvalue.AllowedTACs != nil {
		pctxt.PushElemName("allowedTACs")

		err = pvalue.AllowedTACs.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode notAllowedTACs

	if pvalue.NotAllowedTACs != nil {
		pctxt.PushElemName("notAllowedTACs")

		err = pvalue.NotAllowedTACs.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ServiceAreaInformation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 ServiceAreaInformationItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *ServiceAreaInformation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("ServiceAreaInformation-Item", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *MobilityRestrictionList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [5]bool
	var optx int
	for optx = 0; optx < 5; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode servingPLMN

	pctxt.PushElemName("servingPLMN")

	pvalue.ServingPLMN, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode equivalentPLMNs

	if present[optx] {
		pctxt.PushElemName("equivalentPLMNs")

		err = pvalue.EquivalentPLMNs.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode rATRestrictions

	if present[optx] {
		pctxt.PushElemName("rATRestrictions")

		err = pvalue.RATRestrictions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode forbiddenAreaInformation

	if present[optx] {
		pctxt.PushElemName("forbiddenAreaInformation")

		err = pvalue.ForbiddenAreaInformation.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode serviceAreaInformation

	if present[optx] {
		pctxt.PushElemName("serviceAreaInformation")

		err = pvalue.ServiceAreaInformation.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *MobilityRestrictionList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.EquivalentPLMNs != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.RATRestrictions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.ForbiddenAreaInformation != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.ServiceAreaInformation != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode servingPLMN

	pctxt.PushElemName("servingPLMN")

	err = PerEncodePLMNIdentity(pctxt, pvalue.ServingPLMN)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode equivalentPLMNs

	if pvalue.EquivalentPLMNs != nil {
		pctxt.PushElemName("equivalentPLMNs")

		err = pvalue.EquivalentPLMNs.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode rATRestrictions

	if pvalue.RATRestrictions != nil {
		pctxt.PushElemName("rATRestrictions")

		err = pvalue.RATRestrictions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode forbiddenAreaInformation

	if pvalue.ForbiddenAreaInformation != nil {
		pctxt.PushElemName("forbiddenAreaInformation")

		err = pvalue.ForbiddenAreaInformation.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode serviceAreaInformation

	if pvalue.ServiceAreaInformation != nil {
		pctxt.PushElemName("serviceAreaInformation")

		err = pvalue.ServiceAreaInformation.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NRCGI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode nRCellIdentity

	pctxt.PushElemName("nRCellIdentity")

	pvalue.NRCellIdentity, err = PerDecodeNRCellIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NRCGI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode nRCellIdentity

	pctxt.PushElemName("nRCellIdentity")

	err = PerEncodeNRCellIdentity(pctxt, pvalue.NRCellIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *SourceToTargetAMFInformationReroute) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode configuredNSSAI

	if present[optx] {
		pctxt.PushElemName("configuredNSSAI")

		pvalue.ConfiguredNSSAI = new(ConfiguredNSSAI)
		(*pvalue.ConfiguredNSSAI), err = PerDecodeConfiguredNSSAI(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ConfiguredNSSAI = nil
	}
	optx++

	// decode rejectedNSSAIinPLMN

	if present[optx] {
		pctxt.PushElemName("rejectedNSSAIinPLMN")

		pvalue.RejectedNSSAIinPLMN = new(RejectedNSSAIinPLMN)
		(*pvalue.RejectedNSSAIinPLMN), err = PerDecodeRejectedNSSAIinPLMN(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.RejectedNSSAIinPLMN = nil
	}
	optx++

	// decode rejectedNSSAIinTA

	if present[optx] {
		pctxt.PushElemName("rejectedNSSAIinTA")

		pvalue.RejectedNSSAIinTA = new(RejectedNSSAIinTA)
		(*pvalue.RejectedNSSAIinTA), err = PerDecodeRejectedNSSAIinTA(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.RejectedNSSAIinTA = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *SourceToTargetAMFInformationReroute) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.ConfiguredNSSAI != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.RejectedNSSAIinPLMN != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.RejectedNSSAIinTA != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode configuredNSSAI

	if pvalue.ConfiguredNSSAI != nil {
		pctxt.PushElemName("configuredNSSAI")

		err = PerEncodeConfiguredNSSAI(pctxt, (*pvalue.ConfiguredNSSAI))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode rejectedNSSAIinPLMN

	if pvalue.RejectedNSSAIinPLMN != nil {
		pctxt.PushElemName("rejectedNSSAIinPLMN")

		err = PerEncodeRejectedNSSAIinPLMN(pctxt, (*pvalue.RejectedNSSAIinPLMN))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode rejectedNSSAIinTA

	if pvalue.RejectedNSSAIinTA != nil {
		pctxt.PushElemName("rejectedNSSAIinTA")

		err = PerEncodeRejectedNSSAIinTA(pctxt, (*pvalue.RejectedNSSAIinTA))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *GNBID) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	idx, err = pctxt.PerDecBitsToUInt(1)
	switch idx {
	/* gNB_ID */
	case 0:
		(*pvalue).T = GNBIDGNBIDTAG
		pctxt.PushElemName("gNB-ID")

		pvalue.U.GNBID = new(asn1rt.BitString)
		{
			var nitems uint64
			nitems, err = pctxt.PerDecConsLength(4, 22)
			pvalue.U.GNBID.BitLength = int(nitems)
			pctxt.AlignBuffer()

			pvalue.U.GNBID.Bytes, err = pctxt.DecBits(uint64(pvalue.U.GNBID.BitLength))
			if err != nil {
				return
			}
		}
		pctxt.PopElemName()

	/* choice_Extensions */
	case 1:
		(*pvalue).T = GNBIDChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *GNBID) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case GNBIDGNBIDTAG:
		idx = 0
	case GNBIDChoiceExtensionsTAG:
		idx = 1
	}
	/* Encode choice index value */

	err = pctxt.PerEncBitsFromUInt(idx, 1)
	if err != nil {
		return
	}

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode gNB_ID

		if pvalue.U.GNBID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("gNB-ID")

		alt := asn1rt.BitString((*pvalue.U.GNBID))
		{
			var nitems uint64
			nitems = uint64(alt.BitLength)
			if nitems >= 22 && nitems <= 32 {
				err = pctxt.PerEncBitsFromUInt(uint64((nitems - 22)), 4)

			} else {
				err = pctxt.ErrSizeConsVio(nitems)
				return
			}
		}
		pctxt.PerEncBufAlign()

		err = pctxt.PerEncBitsFromByteArray(alt.Bytes, uint64(alt.BitLength))

		pctxt.PopElemName()

	case 1:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *GlobalGNBID) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode gNB_ID

	pctxt.PushElemName("gNB-ID")

	err = pvalue.GNBID.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *GlobalGNBID) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode gNB_ID

	pctxt.PushElemName("gNB-ID")

	err = pvalue.GNBID.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *N3IWFID) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	idx, err = pctxt.PerDecBitsToUInt(1)
	switch idx {
	/* n3IWF_ID */
	case 0:
		(*pvalue).T = N3IWFIDN3IWFIDTAG
		pctxt.PushElemName("n3IWF-ID")

		pvalue.U.N3IWFID = new(asn1rt.BitString)
		pvalue.U.N3IWFID.BitLength = 16
		pvalue.U.N3IWFID.Bytes, err = pctxt.DecBits(uint64(pvalue.U.N3IWFID.BitLength))
		if err != nil {
			return
		}
		pctxt.PopElemName()

	/* choice_Extensions */
	case 1:
		(*pvalue).T = N3IWFIDChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *N3IWFID) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case N3IWFIDN3IWFIDTAG:
		idx = 0
	case N3IWFIDChoiceExtensionsTAG:
		idx = 1
	}
	/* Encode choice index value */

	err = pctxt.PerEncBitsFromUInt(idx, 1)
	if err != nil {
		return
	}

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode n3IWF_ID

		if pvalue.U.N3IWFID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("n3IWF-ID")

		alt := asn1rt.BitString((*pvalue.U.N3IWFID))
		{
			var nitems uint64
			nitems = uint64(alt.BitLength)
			if nitems == 16 {
			} else {
				err = pctxt.ErrSizeConsVio(nitems)
				return
			}
		}
		err = pctxt.PerEncBitsFromByteArray(alt.Bytes, uint64(alt.BitLength))

		pctxt.PopElemName()

	case 1:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *GlobalN3IWFID) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode n3IWF_ID

	pctxt.PushElemName("n3IWF-ID")

	err = pvalue.N3IWFID.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *GlobalN3IWFID) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode n3IWF_ID

	pctxt.PushElemName("n3IWF-ID")

	err = pvalue.N3IWFID.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NgENBID) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	idx, err = pctxt.PerDecBitsToUInt(2)
	switch idx {
	/* macroNgENB_ID */
	case 0:
		(*pvalue).T = NgENBIDMacroNgENBIDTAG
		pctxt.PushElemName("macroNgENB-ID")

		pvalue.U.MacroNgENBID = new(asn1rt.BitString)
		pvalue.U.MacroNgENBID.BitLength = 20
		pctxt.AlignBuffer()

		pvalue.U.MacroNgENBID.Bytes, err = pctxt.DecBits(uint64(pvalue.U.MacroNgENBID.BitLength))
		if err != nil {
			return
		}
		pctxt.PopElemName()

	/* shortMacroNgENB_ID */
	case 1:
		(*pvalue).T = NgENBIDShortMacroNgENBIDTAG
		pctxt.PushElemName("shortMacroNgENB-ID")

		pvalue.U.ShortMacroNgENBID = new(asn1rt.BitString)
		pvalue.U.ShortMacroNgENBID.BitLength = 18
		pctxt.AlignBuffer()

		pvalue.U.ShortMacroNgENBID.Bytes, err = pctxt.DecBits(uint64(pvalue.U.ShortMacroNgENBID.BitLength))
		if err != nil {
			return
		}
		pctxt.PopElemName()

	/* longMacroNgENB_ID */
	case 2:
		(*pvalue).T = NgENBIDLongMacroNgENBIDTAG
		pctxt.PushElemName("longMacroNgENB-ID")

		pvalue.U.LongMacroNgENBID = new(asn1rt.BitString)
		pvalue.U.LongMacroNgENBID.BitLength = 21
		pctxt.AlignBuffer()

		pvalue.U.LongMacroNgENBID.Bytes, err = pctxt.DecBits(uint64(pvalue.U.LongMacroNgENBID.BitLength))
		if err != nil {
			return
		}
		pctxt.PopElemName()

	/* choice_Extensions */
	case 3:
		(*pvalue).T = NgENBIDChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *NgENBID) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case NgENBIDMacroNgENBIDTAG:
		idx = 0
	case NgENBIDShortMacroNgENBIDTAG:
		idx = 1
	case NgENBIDLongMacroNgENBIDTAG:
		idx = 2
	case NgENBIDChoiceExtensionsTAG:
		idx = 3
	}
	/* Encode choice index value */

	err = pctxt.PerEncBitsFromUInt(idx, 2)
	if err != nil {
		return
	}

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode macroNgENB_ID

		if pvalue.U.MacroNgENBID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("macroNgENB-ID")

		alt := asn1rt.BitString((*pvalue.U.MacroNgENBID))
		{
			var nitems uint64
			nitems = uint64(alt.BitLength)
			if nitems == 20 {
			} else {
				err = pctxt.ErrSizeConsVio(nitems)
				return
			}
		}
		pctxt.PerEncBufAlign()

		err = pctxt.PerEncBitsFromByteArray(alt.Bytes, uint64(alt.BitLength))

		pctxt.PopElemName()

	case 1:
		// encode shortMacroNgENB_ID

		if pvalue.U.ShortMacroNgENBID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("shortMacroNgENB-ID")

		alt := asn1rt.BitString((*pvalue.U.ShortMacroNgENBID))
		{
			var nitems uint64
			nitems = uint64(alt.BitLength)
			if nitems == 18 {
			} else {
				err = pctxt.ErrSizeConsVio(nitems)
				return
			}
		}
		pctxt.PerEncBufAlign()

		err = pctxt.PerEncBitsFromByteArray(alt.Bytes, uint64(alt.BitLength))

		pctxt.PopElemName()

	case 2:
		// encode longMacroNgENB_ID

		if pvalue.U.LongMacroNgENBID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("longMacroNgENB-ID")

		alt := asn1rt.BitString((*pvalue.U.LongMacroNgENBID))
		{
			var nitems uint64
			nitems = uint64(alt.BitLength)
			if nitems == 21 {
			} else {
				err = pctxt.ErrSizeConsVio(nitems)
				return
			}
		}
		pctxt.PerEncBufAlign()

		err = pctxt.PerEncBitsFromByteArray(alt.Bytes, uint64(alt.BitLength))

		pctxt.PopElemName()

	case 3:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *GlobalNgENBID) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode ngENB_ID

	pctxt.PushElemName("ngENB-ID")

	err = pvalue.NgENBID.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *GlobalNgENBID) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode ngENB_ID

	pctxt.PushElemName("ngENB-ID")

	err = pvalue.NgENBID.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *GlobalRANNodeID) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	idx, err = pctxt.PerDecBitsToUInt(2)
	switch idx {
	/* globalGNB_ID */
	case 0:
		(*pvalue).T = GlobalRANNodeIDGlobalGNBIDTAG
		pctxt.PushElemName("globalGNB-ID")

		pvalue.U.GlobalGNBID = new(GlobalGNBID)
		err = pvalue.U.GlobalGNBID.PerDecode(pctxt)
		pctxt.PopElemName()

	/* globalNgENB_ID */
	case 1:
		(*pvalue).T = GlobalRANNodeIDGlobalNgENBIDTAG
		pctxt.PushElemName("globalNgENB-ID")

		pvalue.U.GlobalNgENBID = new(GlobalNgENBID)
		err = pvalue.U.GlobalNgENBID.PerDecode(pctxt)
		pctxt.PopElemName()

	/* globalN3IWF_ID */
	case 2:
		(*pvalue).T = GlobalRANNodeIDGlobalN3IWFIDTAG
		pctxt.PushElemName("globalN3IWF-ID")

		pvalue.U.GlobalN3IWFID = new(GlobalN3IWFID)
		err = pvalue.U.GlobalN3IWFID.PerDecode(pctxt)
		pctxt.PopElemName()

	/* choice_Extensions */
	case 3:
		(*pvalue).T = GlobalRANNodeIDChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *GlobalRANNodeID) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case GlobalRANNodeIDGlobalGNBIDTAG:
		idx = 0
	case GlobalRANNodeIDGlobalNgENBIDTAG:
		idx = 1
	case GlobalRANNodeIDGlobalN3IWFIDTAG:
		idx = 2
	case GlobalRANNodeIDChoiceExtensionsTAG:
		idx = 3
	}
	/* Encode choice index value */

	err = pctxt.PerEncBitsFromUInt(idx, 2)
	if err != nil {
		return
	}

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode globalGNB_ID

		if pvalue.U.GlobalGNBID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("globalGNB-ID")

		alt := GlobalGNBID((*pvalue.U.GlobalGNBID))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 1:
		// encode globalNgENB_ID

		if pvalue.U.GlobalNgENBID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("globalNgENB-ID")

		alt := GlobalNgENBID((*pvalue.U.GlobalNgENBID))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 2:
		// encode globalN3IWF_ID

		if pvalue.U.GlobalN3IWFID == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("globalN3IWF-ID")

		alt := GlobalN3IWFID((*pvalue.U.GlobalN3IWFID))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 3:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("Unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestRANNodeItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode globalRANNodeID

	pctxt.PushElemName("globalRANNodeID")

	err = pvalue.GlobalRANNodeID.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestRANNodeItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode globalRANNodeID

	pctxt.PushElemName("globalRANNodeID")

	err = pvalue.GlobalRANNodeID.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestRANNodeList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(6, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("AreaOfInterestRANNodeItem", i)

			var elem1 AreaOfInterestRANNodeItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestRANNodeList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 64 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 6)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("AreaOfInterestRANNodeItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterest) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode areaOfInterestTAIList

	if present[optx] {
		pctxt.PushElemName("areaOfInterestTAIList")

		err = pvalue.AreaOfInterestTAIList.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode areaOfInterestCellList

	if present[optx] {
		pctxt.PushElemName("areaOfInterestCellList")

		err = pvalue.AreaOfInterestCellList.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode areaOfInterestRANNodeList

	if present[optx] {
		pctxt.PushElemName("areaOfInterestRANNodeList")

		err = pvalue.AreaOfInterestRANNodeList.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterest) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("areaOfInterestTAIList")
	pctxt.DiagNewBitField("present")

	present = pvalue.AreaOfInterestTAIList != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("areaOfInterestCellList")
	pctxt.DiagNewBitField("present")

	present = pvalue.AreaOfInterestCellList != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("areaOfInterestRANNodeList")
	pctxt.DiagNewBitField("present")

	present = pvalue.AreaOfInterestRANNodeList != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode areaOfInterestTAIList

	if pvalue.AreaOfInterestTAIList != nil {
		pctxt.PushElemName("areaOfInterestTAIList")

		err = pvalue.AreaOfInterestTAIList.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode areaOfInterestCellList

	if pvalue.AreaOfInterestCellList != nil {
		pctxt.PushElemName("areaOfInterestCellList")

		err = pvalue.AreaOfInterestCellList.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode areaOfInterestRANNodeList

	if pvalue.AreaOfInterestRANNodeList != nil {
		pctxt.PushElemName("areaOfInterestRANNodeList")

		err = pvalue.AreaOfInterestRANNodeList.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode areaOfInterest

	pctxt.PushElemName("areaOfInterest")

	err = pvalue.AreaOfInterest.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode locationReportingReferenceID

	pctxt.PushElemName("locationReportingReferenceID")

	pvalue.LocationReportingReferenceID, err = PerDecodeLocationReportingReferenceID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode areaOfInterest

	pctxt.PushElemName("areaOfInterest")

	err = pvalue.AreaOfInterest.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode locationReportingReferenceID

	pctxt.PushElemName("locationReportingReferenceID")

	err = PerEncodeLocationReportingReferenceID(pctxt, pvalue.LocationReportingReferenceID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(6, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("AreaOfInterestItem", i)

			var elem1 AreaOfInterestItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 64 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 6)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("AreaOfInterestItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *GUAMI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode aMFRegionID

	pctxt.PushElemName("aMFRegionID")

	pvalue.AMFRegionID, err = PerDecodeAMFRegionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode aMFSetID

	pctxt.PushElemName("aMFSetID")

	pvalue.AMFSetID, err = PerDecodeAMFSetID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode aMFPointer

	pctxt.PushElemName("aMFPointer")

	pvalue.AMFPointer, err = PerDecodeAMFPointer(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *GUAMI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode aMFRegionID

	pctxt.PushElemName("aMFRegionID")

	err = PerEncodeAMFRegionID(pctxt, pvalue.AMFRegionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode aMFSetID

	pctxt.PushElemName("aMFSetID")

	err = PerEncodeAMFSetID(pctxt, pvalue.AMFSetID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode aMFPointer

	pctxt.PushElemName("aMFPointer")

	err = PerEncodeAMFPointer(pctxt, pvalue.AMFPointer)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *LocationReportingRequestType) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [3]bool
	var optx int
	for optx = 0; optx < 3; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode eventType

	pctxt.PushElemName("eventType")

	pvalue.EventType, err = PerDecodeEventType(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode reportArea

	pctxt.PushElemName("reportArea")

	pvalue.ReportArea, err = PerDecodeReportArea(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode areaOfInterestList

	if present[optx] {
		pctxt.PushElemName("areaOfInterestList")

		err = pvalue.AreaOfInterestList.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode locationReportingReferenceIDToBeCancelled

	if present[optx] {
		pctxt.PushElemName("locationReportingReferenceIDToBeCancelled")

		pvalue.LocationReportingReferenceIDToBeCancelled = new(LocationReportingReferenceID)
		(*pvalue.LocationReportingReferenceIDToBeCancelled), err = PerDecodeLocationReportingReferenceID(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.LocationReportingReferenceIDToBeCancelled = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *LocationReportingRequestType) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("areaOfInterestList")
	pctxt.DiagNewBitField("present")

	present = pvalue.AreaOfInterestList != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("locationReportingReferenceIDToBeCancelled")
	pctxt.DiagNewBitField("present")

	present = pvalue.LocationReportingReferenceIDToBeCancelled != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode eventType

	pctxt.PushElemName("eventType")

	err = PerEncodeEventType(pctxt, pvalue.EventType)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode reportArea

	pctxt.PushElemName("reportArea")

	err = PerEncodeReportArea(pctxt, pvalue.ReportArea)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode areaOfInterestList

	if pvalue.AreaOfInterestList != nil {
		pctxt.PushElemName("areaOfInterestList")

		err = pvalue.AreaOfInterestList.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode locationReportingReferenceIDToBeCancelled

	if pvalue.LocationReportingReferenceIDToBeCancelled != nil {
		pctxt.PushElemName("locationReportingReferenceIDToBeCancelled")

		err = PerEncodeLocationReportingReferenceID(pctxt, (*pvalue.LocationReportingReferenceIDToBeCancelled))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ServedGUAMIItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode gUAMI

	pctxt.PushElemName("gUAMI")

	err = pvalue.GUAMI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode backupAMFName

	if present[optx] {
		pctxt.PushElemName("backupAMFName")

		pvalue.BackupAMFName = new(AMFName)
		(*pvalue.BackupAMFName), err = PerDecodeAMFName(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.BackupAMFName = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *ServedGUAMIItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.BackupAMFName != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode gUAMI

	pctxt.PushElemName("gUAMI")

	err = pvalue.GUAMI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode backupAMFName

	if pvalue.BackupAMFName != nil {
		pctxt.PushElemName("backupAMFName")

		err = PerEncodeAMFName(pctxt, (*pvalue.BackupAMFName))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *ServedGUAMIList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.AlignBuffer()

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 ServedGUAMIItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *ServedGUAMIList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("ServedGUAMIItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PLMNSupportItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode sliceSupportList

	pctxt.PushElemName("sliceSupportList")

	err = pvalue.SliceSupportList.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PLMNSupportItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode sliceSupportList

	pctxt.PushElemName("sliceSupportList")

	err = pvalue.SliceSupportList.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PLMNSupportList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 PLMNSupportItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PLMNSupportList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 12 {
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PLMNSupportItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *SupportedTAItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode tAC

	pctxt.PushElemName("tAC")

	pvalue.TAC, err = PerDecodeTAC(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode broadcastPLMNList

	pctxt.PushElemName("broadcastPLMNList")

	err = pvalue.BroadcastPLMNList.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *SupportedTAItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode tAC

	pctxt.PushElemName("tAC")

	err = PerEncodeTAC(pctxt, pvalue.TAC)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode broadcastPLMNList

	pctxt.PushElemName("broadcastPLMNList")

	err = pvalue.BroadcastPLMNList.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *SupportedTAList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.AlignBuffer()

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			var elem1 SupportedTAItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *SupportedTAList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("SupportedTAItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *TAI) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	pvalue.PLMNIdentity, err = PerDecodePLMNIdentity(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode tAC

	pctxt.PushElemName("tAC")

	pvalue.TAC, err = PerDecodeTAC(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *TAI) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode pLMNIdentity

	pctxt.PushElemName("pLMNIdentity")

	err = PerEncodePLMNIdentity(pctxt, pvalue.PLMNIdentity)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode tAC

	pctxt.PushElemName("tAC")

	err = PerEncodeTAC(pctxt, pvalue.TAC)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestTAIItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestTAIItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AreaOfInterestTAIList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(4, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("AreaOfInterestTAIItem", i)

			var elem1 AreaOfInterestTAIItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *AreaOfInterestTAIList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 16 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 4)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("AreaOfInterestTAIItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *UEAggregateMaximumBitRate) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode uEAggregateMaximumBitRateDL

	pctxt.PushElemName("uEAggregateMaximumBitRateDL")

	pvalue.UEAggregateMaximumBitRateDL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode uEAggregateMaximumBitRateUL

	pctxt.PushElemName("uEAggregateMaximumBitRateUL")

	pvalue.UEAggregateMaximumBitRateUL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UEAggregateMaximumBitRate) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode uEAggregateMaximumBitRateDL

	pctxt.PushElemName("uEAggregateMaximumBitRateDL")

	err = PerEncodeBitRate(pctxt, pvalue.UEAggregateMaximumBitRateDL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode uEAggregateMaximumBitRateUL

	pctxt.PushElemName("uEAggregateMaximumBitRateUL")

	err = PerEncodeBitRate(pctxt, pvalue.UEAggregateMaximumBitRateUL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UERadioCapabilityForPaging) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [3]bool
	var optx int
	for optx = 0; optx < 3; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode uERadioCapabilityForPagingOfNR

	if present[optx] {
		pctxt.PushElemName("uERadioCapabilityForPagingOfNR")

		pvalue.UERadioCapabilityForPagingOfNR = new(UERadioCapabilityForPagingOfNR)
		(*pvalue.UERadioCapabilityForPagingOfNR), err = PerDecodeUERadioCapabilityForPagingOfNR(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.UERadioCapabilityForPagingOfNR = nil
	}
	optx++

	// decode uERadioCapabilityForPagingOfEUTRA

	if present[optx] {
		pctxt.PushElemName("uERadioCapabilityForPagingOfEUTRA")

		pvalue.UERadioCapabilityForPagingOfEUTRA = new(UERadioCapabilityForPagingOfEUTRA)
		(*pvalue.UERadioCapabilityForPagingOfEUTRA), err = PerDecodeUERadioCapabilityForPagingOfEUTRA(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.UERadioCapabilityForPagingOfEUTRA = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UERadioCapabilityForPaging) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("uERadioCapabilityForPagingOfNR")
	pctxt.DiagNewBitField("present")

	present = pvalue.UERadioCapabilityForPagingOfNR != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("uERadioCapabilityForPagingOfEUTRA")
	pctxt.DiagNewBitField("present")

	present = pvalue.UERadioCapabilityForPagingOfEUTRA != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode uERadioCapabilityForPagingOfNR

	if pvalue.UERadioCapabilityForPagingOfNR != nil {
		pctxt.PushElemName("uERadioCapabilityForPagingOfNR")

		err = PerEncodeUERadioCapabilityForPagingOfNR(pctxt, (*pvalue.UERadioCapabilityForPagingOfNR))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode uERadioCapabilityForPagingOfEUTRA

	if pvalue.UERadioCapabilityForPagingOfEUTRA != nil {
		pctxt.PushElemName("uERadioCapabilityForPagingOfEUTRA")

		err = PerEncodeUERadioCapabilityForPagingOfEUTRA(pctxt, (*pvalue.UERadioCapabilityForPagingOfEUTRA))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UESecurityCapabilities) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode nRencryptionAlgorithms

	pctxt.PushElemName("nRencryptionAlgorithms")

	pvalue.NRencryptionAlgorithms, err = PerDecodeNRencryptionAlgorithms(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode nRintegrityProtectionAlgorithms

	pctxt.PushElemName("nRintegrityProtectionAlgorithms")

	pvalue.NRintegrityProtectionAlgorithms, err = PerDecodeNRintegrityProtectionAlgorithms(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode eUTRAencryptionAlgorithms

	pctxt.PushElemName("eUTRAencryptionAlgorithms")

	pvalue.EUTRAencryptionAlgorithms, err = PerDecodeEUTRAencryptionAlgorithms(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode eUTRAintegrityProtectionAlgorithms

	pctxt.PushElemName("eUTRAintegrityProtectionAlgorithms")

	pvalue.EUTRAintegrityProtectionAlgorithms, err = PerDecodeEUTRAintegrityProtectionAlgorithms(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UESecurityCapabilities) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode nRencryptionAlgorithms

	pctxt.PushElemName("nRencryptionAlgorithms")

	err = PerEncodeNRencryptionAlgorithms(pctxt, pvalue.NRencryptionAlgorithms)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode nRintegrityProtectionAlgorithms

	pctxt.PushElemName("nRintegrityProtectionAlgorithms")

	err = PerEncodeNRintegrityProtectionAlgorithms(pctxt, pvalue.NRintegrityProtectionAlgorithms)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode eUTRAencryptionAlgorithms

	pctxt.PushElemName("eUTRAencryptionAlgorithms")

	err = PerEncodeEUTRAencryptionAlgorithms(pctxt, pvalue.EUTRAencryptionAlgorithms)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode eUTRAintegrityProtectionAlgorithms

	pctxt.PushElemName("eUTRAintegrityProtectionAlgorithms")

	err = PerEncodeEUTRAintegrityProtectionAlgorithms(pctxt, pvalue.EUTRAintegrityProtectionAlgorithms)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UserLocationInformationEUTRA) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode eUTRA_CGI

	pctxt.PushElemName("eUTRA-CGI")

	err = pvalue.EUTRACGI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode timeStamp

	if present[optx] {
		pctxt.PushElemName("timeStamp")

		pvalue.TimeStamp = new(TimeStamp)
		(*pvalue.TimeStamp), err = PerDecodeTimeStamp(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.TimeStamp = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UserLocationInformationEUTRA) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.TimeStamp != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode eUTRA_CGI

	pctxt.PushElemName("eUTRA-CGI")

	err = pvalue.EUTRACGI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode timeStamp

	if pvalue.TimeStamp != nil {
		pctxt.PushElemName("timeStamp")

		err = PerEncodeTimeStamp(pctxt, (*pvalue.TimeStamp))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UserLocationInformationNR) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode nR_CGI

	pctxt.PushElemName("nR-CGI")

	err = pvalue.NRCGI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode timeStamp

	if present[optx] {
		pctxt.PushElemName("timeStamp")

		pvalue.TimeStamp = new(TimeStamp)
		(*pvalue.TimeStamp), err = PerDecodeTimeStamp(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.TimeStamp = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UserLocationInformationNR) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.TimeStamp != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode nR_CGI

	pctxt.PushElemName("nR-CGI")

	err = pvalue.NRCGI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode tAI

	pctxt.PushElemName("tAI")

	err = pvalue.TAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode timeStamp

	if pvalue.TimeStamp != nil {
		pctxt.PushElemName("timeStamp")

		err = PerEncodeTimeStamp(pctxt, (*pvalue.TimeStamp))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UserLocationInformationN3IWF) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	extbit, err = pctxt.DecBit()

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0

	// decode iPAddress

	pctxt.PushElemName("iPAddress")

	pvalue.IPAddress, err = PerDecodeTransportLayerAddress(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode portNumber

	pctxt.PushElemName("portNumber")

	pvalue.PortNumber, err = PerDecodePortNumber(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UserLocationInformationN3IWF) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	err = pctxt.EncBit(extbit)

	var present bool
	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}

	// encode iPAddress

	pctxt.PushElemName("iPAddress")

	err = PerEncodeTransportLayerAddress(pctxt, pvalue.IPAddress)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode portNumber

	pctxt.PushElemName("portNumber")

	err = PerEncodePortNumber(pctxt, pvalue.PortNumber)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		/* encode optional bits */

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UserLocationInformation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	idx, err = pctxt.PerDecBitsToUInt(2)
	switch idx {
	/* userLocationInformationEUTRA */
	case 0:
		(*pvalue).T = UserLocationInformationUserLocationInformationEUTRATAG
		pctxt.PushElemName("userLocationInformationEUTRA")

		pvalue.U.UserLocationInformationEUTRA = new(UserLocationInformationEUTRA)
		err = pvalue.U.UserLocationInformationEUTRA.PerDecode(pctxt)
		pctxt.PopElemName()

	/* userLocationInformationNR */
	case 1:
		(*pvalue).T = UserLocationInformationUserLocationInformationNRTAG
		pctxt.PushElemName("userLocationInformationNR")

		pvalue.U.UserLocationInformationNR = new(UserLocationInformationNR)
		err = pvalue.U.UserLocationInformationNR.PerDecode(pctxt)
		pctxt.PopElemName()

	/* userLocationInformationN3IWF */
	case 2:
		(*pvalue).T = UserLocationInformationUserLocationInformationN3IWFTAG
		pctxt.PushElemName("userLocationInformationN3IWF")

		pvalue.U.UserLocationInformationN3IWF = new(UserLocationInformationN3IWF)
		err = pvalue.U.UserLocationInformationN3IWF.PerDecode(pctxt)
		pctxt.PopElemName()

	/* choice_Extensions */
	case 3:
		(*pvalue).T = UserLocationInformationChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *UserLocationInformation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case UserLocationInformationUserLocationInformationEUTRATAG:
		idx = 0
	case UserLocationInformationUserLocationInformationNRTAG:
		idx = 1
	case UserLocationInformationUserLocationInformationN3IWFTAG:
		idx = 2
	case UserLocationInformationChoiceExtensionsTAG:
		idx = 3
	}
	/* Encode choice index value */

	err = pctxt.PerEncBitsFromUInt(idx, 2)
	if err != nil {
		return
	}

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode userLocationInformationEUTRA

		if pvalue.U.UserLocationInformationEUTRA == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("userLocationInformationEUTRA")

		alt := UserLocationInformationEUTRA((*pvalue.U.UserLocationInformationEUTRA))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 1:
		// encode userLocationInformationNR

		if pvalue.U.UserLocationInformationNR == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("userLocationInformationNR")

		alt := UserLocationInformationNR((*pvalue.U.UserLocationInformationNR))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 2:
		// encode userLocationInformationN3IWF

		if pvalue.U.UserLocationInformationN3IWF == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("userLocationInformationN3IWF")

		alt := UserLocationInformationN3IWF((*pvalue.U.UserLocationInformationN3IWF))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 3:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecodeResetAll method implementation
func PerDecodeResetAll(pctxt *asn1rt.OSRTContext) (value ResetAll, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = ResetAllUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeResetAll method implementation
func PerEncodeResetAll(pctxt *asn1rt.OSRTContext, value ResetAll) (err error) {
	var ui uint64
	switch value {
	case ResetAllResetAll:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecode method implementation
func (pvalue *UEAssociatedLogicalNGConnectionItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [3]bool
	var optx int
	for optx = 0; optx < 3; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode aMF_UE_NGAP_ID

	if present[optx] {
		pctxt.PushElemName("aMF-UE-NGAP-ID")

		pvalue.AMFUENGAPID = new(AMFUENGAPID)
		(*pvalue.AMFUENGAPID), err = PerDecodeAMFUENGAPID(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.AMFUENGAPID = nil
	}
	optx++

	// decode rAN_UE_NGAP_ID

	if present[optx] {
		pctxt.PushElemName("rAN-UE-NGAP-ID")

		pvalue.RANUENGAPID = new(RANUENGAPID)
		(*pvalue.RANUENGAPID), err = PerDecodeRANUENGAPID(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.RANUENGAPID = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UEAssociatedLogicalNGConnectionItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("aMF-UE-NGAP-ID")
	pctxt.DiagNewBitField("present")

	present = pvalue.AMFUENGAPID != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("rAN-UE-NGAP-ID")
	pctxt.DiagNewBitField("present")

	present = pvalue.RANUENGAPID != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode aMF_UE_NGAP_ID

	if pvalue.AMFUENGAPID != nil {
		pctxt.PushElemName("aMF-UE-NGAP-ID")

		err = PerEncodeAMFUENGAPID(pctxt, (*pvalue.AMFUENGAPID))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode rAN_UE_NGAP_ID

	if pvalue.RANUENGAPID != nil {
		pctxt.PushElemName("rAN-UE-NGAP-ID")

		err = PerEncodeRANUENGAPID(pctxt, (*pvalue.RANUENGAPID))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UEAssociatedLogicalNGConnectionList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	var frag bool = true
	for frag {
		// decode length
		nitems, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("UE-associatedLogicalNG-connectionItem", i)

			var elem1 UEAssociatedLogicalNGConnectionItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UEAssociatedLogicalNGConnectionList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var enclen uint64
	var fraglen uint64
	var xx1 uint64

	remlen := uint64(len((*pvalue)))
	for {
		// Encode length
		fraglen, err = pctxt.PerEncUnconsLen(remlen)
		if err != nil {
			return
		}
		enclen += fraglen
		remlen -= fraglen

		// Encode elements
		for ; xx1 < enclen; xx1++ {
			pctxt.PushArrayElemName("UE-associatedLogicalNG-connectionItem", xx1)

			err = (*pvalue)[xx1].PerEncode(pctxt)

			pctxt.PopElemName()
			if err != nil {
				return
			}
		}
		if remlen == 0 {
			break
		}

	}
	return
}

// PerDecode method implementation
func (pvalue *ResetType) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	pctxt.DiagNewBitField("<choice-index>")

	idx, err = pctxt.PerDecBitsToUInt(2)
	pctxt.DiagSetBitFieldCount()

	switch idx {
	/* nG_Interface */
	case 0:
		(*pvalue).T = ResetTypeNGInterfaceTAG
		pctxt.PushElemName("nG-Interface")

		pvalue.U.NGInterface = new(ResetAll)
		(*pvalue.U.NGInterface), err = PerDecodeResetAll(pctxt)
		pctxt.PopElemName()

	/* partOfNG_Interface */
	case 1:
		(*pvalue).T = ResetTypePartOfNGInterfaceTAG
		pctxt.PushElemName("partOfNG-Interface")

		pvalue.U.PartOfNGInterface = new(UEAssociatedLogicalNGConnectionList)
		err = pvalue.U.PartOfNGInterface.PerDecode(pctxt)
		pctxt.PopElemName()

	/* choice_Extensions */
	case 2:
		(*pvalue).T = ResetTypeChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *ResetType) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case ResetTypeNGInterfaceTAG:
		idx = 0
	case ResetTypePartOfNGInterfaceTAG:
		idx = 1
	case ResetTypeChoiceExtensionsTAG:
		idx = 2
	}
	/* Encode choice index value */

	pctxt.DiagNewBitField("<choice-index>")

	err = pctxt.PerEncBitsFromUInt(idx, 2)
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode nG_Interface

		if pvalue.U.NGInterface == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("nG-Interface")

		alt := ResetAll((*pvalue.U.NGInterface))
		err = PerEncodeResetAll(pctxt, alt)

		pctxt.PopElemName()

	case 1:
		// encode partOfNG_Interface

		if pvalue.U.PartOfNGInterface == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("partOfNG-Interface")

		alt := UEAssociatedLogicalNGConnectionList((*pvalue.U.PartOfNGInterface))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 2:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecodeAdditionalQosFlowInformation method implementation
func PerDecodeAdditionalQosFlowInformation(pctxt *asn1rt.OSRTContext) (value AdditionalQosFlowInformation, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = AdditionalQosFlowInformationUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeAdditionalQosFlowInformation method implementation
func PerEncodeAdditionalQosFlowInformation(pctxt *asn1rt.OSRTContext, value AdditionalQosFlowInformation) (err error) {
	var ui uint64
	switch value {
	case AdditionalQosFlowInformationMoreLikely:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeAveragingWindow method implementation
func PerDecodeAveragingWindow(pctxt *asn1rt.OSRTContext) (value AveragingWindow, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(16)
		value = AveragingWindow(tmpval)

		if value > 4095 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = AveragingWindow(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeAveragingWindow method implementation
func PerEncodeAveragingWindow(pctxt *asn1rt.OSRTContext, value AveragingWindow) (err error) {
	var extbit bool
	if value <= 4095 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.PerEncBufAlign()

		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value), 16)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeCommonNetworkInstance method implementation
func PerDecodeCommonNetworkInstance(pctxt *asn1rt.OSRTContext) (value CommonNetworkInstance, err error) {
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}
	value, err = pctxt.PerDecUnconsOctStr()
	if err != nil {
		return
	}
	return
}

// PerEncodeCommonNetworkInstance method implementation
func PerEncodeCommonNetworkInstance(pctxt *asn1rt.OSRTContext, value CommonNetworkInstance) (err error) {
	err = pctxt.PerEncUnconsOctStr(value)
	return
}

// PerDecodeConfidentialityProtectionIndication method implementation
func PerDecodeConfidentialityProtectionIndication(pctxt *asn1rt.OSRTContext) (value ConfidentialityProtectionIndication, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = ConfidentialityProtectionIndicationUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(2)
		value = ConfidentialityProtectionIndication(tmpval)

		pctxt.DiagSetBitFieldCount()

		if value > 2 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeConfidentialityProtectionIndication method implementation
func PerEncodeConfidentialityProtectionIndication(pctxt *asn1rt.OSRTContext, value ConfidentialityProtectionIndication) (err error) {
	if value >= 3 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 2)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeConfidentialityProtectionResult method implementation
func PerDecodeConfidentialityProtectionResult(pctxt *asn1rt.OSRTContext) (value ConfidentialityProtectionResult, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = ConfidentialityProtectionResultUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = ConfidentialityProtectionResult(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeConfidentialityProtectionResult method implementation
func PerEncodeConfidentialityProtectionResult(pctxt *asn1rt.OSRTContext, value ConfidentialityProtectionResult) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeDataForwardingNotPossible method implementation
func PerDecodeDataForwardingNotPossible(pctxt *asn1rt.OSRTContext) (value DataForwardingNotPossible, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = DataForwardingNotPossibleUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeDataForwardingNotPossible method implementation
func PerEncodeDataForwardingNotPossible(pctxt *asn1rt.OSRTContext, value DataForwardingNotPossible) (err error) {
	var ui uint64
	switch value {
	case DataForwardingNotPossibleDataForwardingNotPossible:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeDelayCritical method implementation
func PerDecodeDelayCritical(pctxt *asn1rt.OSRTContext) (value DelayCritical, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = DelayCriticalUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = DelayCritical(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeDelayCritical method implementation
func PerEncodeDelayCritical(pctxt *asn1rt.OSRTContext, value DelayCritical) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeEmergencyFallbackRequestIndicator method implementation
func PerDecodeEmergencyFallbackRequestIndicator(pctxt *asn1rt.OSRTContext) (value EmergencyFallbackRequestIndicator, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = EmergencyFallbackRequestIndicatorUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeEmergencyFallbackRequestIndicator method implementation
func PerEncodeEmergencyFallbackRequestIndicator(pctxt *asn1rt.OSRTContext, value EmergencyFallbackRequestIndicator) (err error) {
	var ui uint64
	switch value {
	case EmergencyFallbackRequestIndicatorEmergencyFallbackRequested:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeEmergencyServiceTargetCN method implementation
func PerDecodeEmergencyServiceTargetCN(pctxt *asn1rt.OSRTContext) (value EmergencyServiceTargetCN, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = EmergencyServiceTargetCNUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = EmergencyServiceTargetCN(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeEmergencyServiceTargetCN method implementation
func PerEncodeEmergencyServiceTargetCN(pctxt *asn1rt.OSRTContext, value EmergencyServiceTargetCN) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeERABID method implementation
func PerDecodeERABID(pctxt *asn1rt.OSRTContext) (value ERABID, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(4)
		value = ERABID(tmpval)

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = ERABID(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeERABID method implementation
func PerEncodeERABID(pctxt *asn1rt.OSRTContext, value ERABID) (err error) {
	var extbit bool
	if value <= 15 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value), 4)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeEventType method implementation
func PerDecodeEventType(pctxt *asn1rt.OSRTContext) (value EventType, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = EventTypeUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(3)
		value = EventType(tmpval)

		pctxt.DiagSetBitFieldCount()

		if value > 5 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeEventType method implementation
func PerEncodeEventType(pctxt *asn1rt.OSRTContext, value EventType) (err error) {
	if value >= 6 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 3)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeFiveQI method implementation
func PerDecodeFiveQI(pctxt *asn1rt.OSRTContext) (value FiveQI, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(8)
		value = FiveQI(tmpval)

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = FiveQI(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeFiveQI method implementation
func PerEncodeFiveQI(pctxt *asn1rt.OSRTContext, value FiveQI) (err error) {
	var extbit bool
	if value <= 255 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.PerEncBufAlign()

		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value), 8)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeGTPTEID method implementation
func PerDecodeGTPTEID(pctxt *asn1rt.OSRTContext) (value GTPTEID, err error) {
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}

	pctxt.DiagNewBitField("data")

	value, err = pctxt.DecBytesCopy(4)
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	return
}

// PerEncodeGTPTEID method implementation
func PerEncodeGTPTEID(pctxt *asn1rt.OSRTContext, value GTPTEID) (err error) {
	if len(value) != 4 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	pctxt.DiagNewBitField("data")

	err = pctxt.EncBytes(value[:])

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeIntegrityProtectionIndication method implementation
func PerDecodeIntegrityProtectionIndication(pctxt *asn1rt.OSRTContext) (value IntegrityProtectionIndication, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = IntegrityProtectionIndicationUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(2)
		value = IntegrityProtectionIndication(tmpval)

		pctxt.DiagSetBitFieldCount()

		if value > 2 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeIntegrityProtectionIndication method implementation
func PerEncodeIntegrityProtectionIndication(pctxt *asn1rt.OSRTContext, value IntegrityProtectionIndication) (err error) {
	if value >= 3 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 2)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeIntegrityProtectionResult method implementation
func PerDecodeIntegrityProtectionResult(pctxt *asn1rt.OSRTContext) (value IntegrityProtectionResult, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = IntegrityProtectionResultUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = IntegrityProtectionResult(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeIntegrityProtectionResult method implementation
func PerEncodeIntegrityProtectionResult(pctxt *asn1rt.OSRTContext, value IntegrityProtectionResult) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeInterfacesToTrace method implementation
func PerDecodeInterfacesToTrace(pctxt *asn1rt.OSRTContext) (value InterfacesToTrace, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 8
	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = InterfacesToTrace(tmpval)
	return
}

// PerEncodeInterfacesToTrace method implementation
func PerEncodeInterfacesToTrace(pctxt *asn1rt.OSRTContext, value InterfacesToTrace) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 8 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeLocationReportingReferenceID method implementation
func PerDecodeLocationReportingReferenceID(pctxt *asn1rt.OSRTContext) (value LocationReportingReferenceID, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(6)
		value = LocationReportingReferenceID(tmpval)

		value += 1

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = LocationReportingReferenceID(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeLocationReportingReferenceID method implementation
func PerEncodeLocationReportingReferenceID(pctxt *asn1rt.OSRTContext, value LocationReportingReferenceID) (err error) {
	var extbit bool
	if value >= 1 && value <= 64 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 6)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeMaskedIMEISV method implementation
func PerDecodeMaskedIMEISV(pctxt *asn1rt.OSRTContext) (value MaskedIMEISV, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 64
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}

	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = MaskedIMEISV(tmpval)
	return
}

// PerEncodeMaskedIMEISV method implementation
func PerEncodeMaskedIMEISV(pctxt *asn1rt.OSRTContext, value MaskedIMEISV) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 64 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	pctxt.PerEncBufAlign()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeMaximumDataBurstVolume method implementation
func PerDecodeMaximumDataBurstVolume(pctxt *asn1rt.OSRTContext) (value MaximumDataBurstVolume, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(16)
		value = MaximumDataBurstVolume(tmpval)

		if value > 4095 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = MaximumDataBurstVolume(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeMaximumDataBurstVolume method implementation
func PerEncodeMaximumDataBurstVolume(pctxt *asn1rt.OSRTContext, value MaximumDataBurstVolume) (err error) {
	var extbit bool
	if value <= 4095 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.PerEncBufAlign()

		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value), 16)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeMaximumIntegrityProtectedDataRate method implementation
func PerDecodeMaximumIntegrityProtectedDataRate(pctxt *asn1rt.OSRTContext) (value MaximumIntegrityProtectedDataRate, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = MaximumIntegrityProtectedDataRateUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = MaximumIntegrityProtectedDataRate(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeMaximumIntegrityProtectedDataRate method implementation
func PerEncodeMaximumIntegrityProtectedDataRate(pctxt *asn1rt.OSRTContext, value MaximumIntegrityProtectedDataRate) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeMICOModeIndication method implementation
func PerDecodeMICOModeIndication(pctxt *asn1rt.OSRTContext) (value MICOModeIndication, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = MICOModeIndicationUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeMICOModeIndication method implementation
func PerEncodeMICOModeIndication(pctxt *asn1rt.OSRTContext, value MICOModeIndication) (err error) {
	var ui uint64
	switch value {
	case MICOModeIndicationTrue:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeNetworkInstance method implementation
func PerDecodeNetworkInstance(pctxt *asn1rt.OSRTContext) (value NetworkInstance, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(8)
		value = NetworkInstance(tmpval)

		value += 1

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = NetworkInstance(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeNetworkInstance method implementation
func PerEncodeNetworkInstance(pctxt *asn1rt.OSRTContext, value NetworkInstance) (err error) {
	var extbit bool
	if value >= 1 && value <= 256 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.PerEncBufAlign()

		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 8)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeNGRANTraceID method implementation
func PerDecodeNGRANTraceID(pctxt *asn1rt.OSRTContext) (value NGRANTraceID, err error) {
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}

	pctxt.DiagNewBitField("data")

	value, err = pctxt.DecBytesCopy(8)
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	return
}

// PerEncodeNGRANTraceID method implementation
func PerEncodeNGRANTraceID(pctxt *asn1rt.OSRTContext, value NGRANTraceID) (err error) {
	if len(value) != 8 {
		return pctxt.ErrSizeConsVio(uint64(len(value)))
	}
	pctxt.PerEncBufAlign()

	pctxt.DiagNewBitField("data")

	err = pctxt.EncBytes(value[:])

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeNotificationControl method implementation
func PerDecodeNotificationControl(pctxt *asn1rt.OSRTContext) (value NotificationControl, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = NotificationControlUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeNotificationControl method implementation
func PerEncodeNotificationControl(pctxt *asn1rt.OSRTContext, value NotificationControl) (err error) {
	var ui uint64
	switch value {
	case NotificationControlNotificationRequested:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodePacketLossRate method implementation
func PerDecodePacketLossRate(pctxt *asn1rt.OSRTContext) (value PacketLossRate, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(16)
		value = PacketLossRate(tmpval)

		if value > 1000 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = PacketLossRate(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodePacketLossRate method implementation
func PerEncodePacketLossRate(pctxt *asn1rt.OSRTContext, value PacketLossRate) (err error) {
	var extbit bool
	if value <= 1000 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.PerEncBufAlign()

		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value), 16)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeNRintegrityProtectionAlgorithms method implementation
func PerDecodeNRintegrityProtectionAlgorithms(pctxt *asn1rt.OSRTContext) (value NRintegrityProtectionAlgorithms, err error) {
	var tmpval asn1rt.BitString
	var extbit bool
	var nitems uint64
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		nitems = 16
	} else {
		nitems, _, err = pctxt.PerDecUnconsLen()
	}
	tmpval.BitLength = int(nitems)
	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = NRintegrityProtectionAlgorithms(tmpval)
	return
}

// PerEncodeNRintegrityProtectionAlgorithms method implementation
func PerEncodeNRintegrityProtectionAlgorithms(pctxt *asn1rt.OSRTContext, value NRintegrityProtectionAlgorithms) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 16 {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(false)

		pctxt.DiagSetBitFieldCount()

	} else {
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(true)

		pctxt.DiagSetBitFieldCount()

		_, err = pctxt.PerEncUnconsLen(nitems)
	}
	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodePacketDelayBudget method implementation
func PerDecodePacketDelayBudget(pctxt *asn1rt.OSRTContext) (value PacketDelayBudget, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(16)
		value = PacketDelayBudget(tmpval)

		if value > 1023 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = PacketDelayBudget(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodePacketDelayBudget method implementation
func PerEncodePacketDelayBudget(pctxt *asn1rt.OSRTContext, value PacketDelayBudget) (err error) {
	var extbit bool
	if value <= 1023 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.PerEncBufAlign()

		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value), 16)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodePDUSessionID method implementation
func PerDecodePDUSessionID(pctxt *asn1rt.OSRTContext) (value PDUSessionID, err error) {
	if pctxt.AlignBuffer() {
		pctxt.DiagSetBitFieldOffset()
	}
	pctxt.DiagNewBitField("constrained int")

	var tmpval uint64
	tmpval, err = pctxt.PerDecBitsToUInt(8)
	value = PDUSessionID(tmpval)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerEncodePDUSessionID method implementation
func PerEncodePDUSessionID(pctxt *asn1rt.OSRTContext, value PDUSessionID) (err error) {
	pctxt.PerEncBufAlign()

	pctxt.DiagNewBitField("cons int/uint")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 8)

	pctxt.DiagSetBitFieldCount()

	return
}

// PerDecodePDUSessionType method implementation
func PerDecodePDUSessionType(pctxt *asn1rt.OSRTContext) (value PDUSessionType, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = PDUSessionTypeUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(3)
		value = PDUSessionType(tmpval)

		pctxt.DiagSetBitFieldCount()

		if value > 4 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodePDUSessionType method implementation
func PerEncodePDUSessionType(pctxt *asn1rt.OSRTContext, value PDUSessionType) (err error) {
	if value >= 5 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 3)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodePeriodicRegistrationUpdateTimer method implementation
func PerDecodePeriodicRegistrationUpdateTimer(pctxt *asn1rt.OSRTContext) (value PeriodicRegistrationUpdateTimer, err error) {
	var tmpval asn1rt.BitString
	tmpval.BitLength = 8
	pctxt.DiagNewBitField("data")

	tmpval.Bytes, err = pctxt.DecBits(uint64(tmpval.BitLength))
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()
	value = PeriodicRegistrationUpdateTimer(tmpval)
	return
}

// PerEncodePeriodicRegistrationUpdateTimer method implementation
func PerEncodePeriodicRegistrationUpdateTimer(pctxt *asn1rt.OSRTContext, value PeriodicRegistrationUpdateTimer) (err error) {
	var nitems uint64
	nitems = uint64(value.BitLength)
	if nitems == 8 {
	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromByteArray(value.Bytes, uint64(value.BitLength))

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodePreEmptionCapability method implementation
func PerDecodePreEmptionCapability(pctxt *asn1rt.OSRTContext) (value PreEmptionCapability, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = PreEmptionCapabilityUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = PreEmptionCapability(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodePreEmptionCapability method implementation
func PerEncodePreEmptionCapability(pctxt *asn1rt.OSRTContext, value PreEmptionCapability) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodePreEmptionVulnerability method implementation
func PerDecodePreEmptionVulnerability(pctxt *asn1rt.OSRTContext) (value PreEmptionVulnerability, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = PreEmptionVulnerabilityUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = PreEmptionVulnerability(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodePreEmptionVulnerability method implementation
func PerEncodePreEmptionVulnerability(pctxt *asn1rt.OSRTContext, value PreEmptionVulnerability) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodePriorityLevelARP method implementation
func PerDecodePriorityLevelARP(pctxt *asn1rt.OSRTContext) (value PriorityLevelARP, err error) {
	pctxt.DiagNewBitField("constrained int")

	var tmpval uint64
	tmpval, err = pctxt.PerDecBitsToUInt(4)
	value = PriorityLevelARP(tmpval)

	if value > 14 {
		err = pctxt.ErrValueConsVio(value)
		return
	}

	value += 1

	pctxt.DiagSetBitFieldCount()
	return
}

// PerEncodePriorityLevelARP method implementation
func PerEncodePriorityLevelARP(pctxt *asn1rt.OSRTContext, value PriorityLevelARP) (err error) {
	if value >= 1 && value <= 15 {
		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 4)

		pctxt.DiagSetBitFieldCount()
	} else {
		err = pctxt.ErrValueConsVio(value)
		return
	}

	return
}

// PerDecodePriorityLevelQos method implementation
func PerDecodePriorityLevelQos(pctxt *asn1rt.OSRTContext) (value PriorityLevelQos, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(7)
		value = PriorityLevelQos(tmpval)

		if value > 126 {
			err = pctxt.ErrValueConsVio(value)
			return
		}

		value += 1

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = PriorityLevelQos(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodePriorityLevelQos method implementation
func PerEncodePriorityLevelQos(pctxt *asn1rt.OSRTContext, value PriorityLevelQos) (err error) {
	var extbit bool
	if value >= 1 && value <= 127 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value-1), 7)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeQosFlowIdentifier method implementation
func PerDecodeQosFlowIdentifier(pctxt *asn1rt.OSRTContext) (value QosFlowIdentifier, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if !extbit {
		pctxt.DiagNewBitField("constrained int")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(6)
		value = QosFlowIdentifier(tmpval)

		pctxt.DiagSetBitFieldCount()
	} else {
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		{
			var len0 byte
			pctxt.DiagNewBitField("length")

			len0, err = pctxt.DecByte()

			pctxt.DiagSetBitFieldCount()
			pctxt.DiagNewBitField("data")

			var tmpval uint64
			tmpval, err = pctxt.PerDecBitsToUInt(uint64(len0 * 8))
			value = QosFlowIdentifier(tmpval)

			pctxt.DiagSetBitFieldCount()
		}
	}
	return
}

// PerEncodeQosFlowIdentifier method implementation
func PerEncodeQosFlowIdentifier(pctxt *asn1rt.OSRTContext, value QosFlowIdentifier) (err error) {
	var extbit bool
	if value <= 63 {
		extbit = false
	} else {
		extbit = true
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	if extbit {
		err = pctxt.PerEncUnconsUInt(uint64(value))
	} else {
		pctxt.DiagNewBitField("cons int/uint")

		err = pctxt.PerEncBitsFromUInt(uint64(value), 6)

		pctxt.DiagSetBitFieldCount()
	}
	return
}

// PerDecodeReflectiveQosAttribute method implementation
func PerDecodeReflectiveQosAttribute(pctxt *asn1rt.OSRTContext) (value ReflectiveQosAttribute, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = ReflectiveQosAttributeUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeReflectiveQosAttribute method implementation
func PerEncodeReflectiveQosAttribute(pctxt *asn1rt.OSRTContext, value ReflectiveQosAttribute) (err error) {
	var ui uint64
	switch value {
	case ReflectiveQosAttributeSubjectTo:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeReportArea method implementation
func PerDecodeReportArea(pctxt *asn1rt.OSRTContext) (value ReportArea, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = ReportAreaUNKNOWN
	} else {
		value = 0

	}
	return
}

// PerEncodeReportArea method implementation
func PerEncodeReportArea(pctxt *asn1rt.OSRTContext, value ReportArea) (err error) {
	var ui uint64
	switch value {
	case ReportAreaCell:
		ui = 0
		break
	default:
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}

	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(ui), 0)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeRRCInactiveTransitionReportRequest method implementation
func PerDecodeRRCInactiveTransitionReportRequest(pctxt *asn1rt.OSRTContext) (value RRCInactiveTransitionReportRequest, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = RRCInactiveTransitionReportRequestUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(2)
		value = RRCInactiveTransitionReportRequest(tmpval)

		pctxt.DiagSetBitFieldCount()

		if value > 2 {
			err = pctxt.ErrValueConsVio(value)
			return
		}
	}
	return
}

// PerEncodeRRCInactiveTransitionReportRequest method implementation
func PerEncodeRRCInactiveTransitionReportRequest(pctxt *asn1rt.OSRTContext, value RRCInactiveTransitionReportRequest) (err error) {
	if value >= 3 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 2)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecodeAssociatedQosFlowItemQosFlowMappingIndication method implementation
func PerDecodeAssociatedQosFlowItemQosFlowMappingIndication(pctxt *asn1rt.OSRTContext) (value AssociatedQosFlowItemQosFlowMappingIndication, err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	if extbit {
		pctxt.DiagNewBitField("extension value")

		_, err = pctxt.PerDecSmallNonNegWholeNumber()

		pctxt.DiagSetBitFieldCount()

		value = AssociatedQosFlowItemQosFlowMappingIndicationUNKNOWN
	} else {
		pctxt.DiagNewBitField("uint64")

		var tmpval uint64
		tmpval, err = pctxt.PerDecBitsToUInt(1)
		value = AssociatedQosFlowItemQosFlowMappingIndication(tmpval)

		pctxt.DiagSetBitFieldCount()

	}
	return
}

// PerEncodeAssociatedQosFlowItemQosFlowMappingIndication method implementation
func PerEncodeAssociatedQosFlowItemQosFlowMappingIndication(pctxt *asn1rt.OSRTContext, value AssociatedQosFlowItemQosFlowMappingIndication) (err error) {
	if value >= 2 {
		err = pctxt.ErrInvalidEnum(uint64(value))
		return
	}
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(false)

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("data")

	err = pctxt.PerEncBitsFromUInt(uint64(value), 1)

	pctxt.DiagSetBitFieldCount()
	return
}

// PerDecode method implementation
func (pvalue *AllocationAndRetentionPriority) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode priorityLevelARP

	pctxt.PushElemName("priorityLevelARP")

	pvalue.PriorityLevelARP, err = PerDecodePriorityLevelARP(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pre_emptionCapability

	pctxt.PushElemName("pre-emptionCapability")

	pvalue.PreEmptionCapability, err = PerDecodePreEmptionCapability(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pre_emptionVulnerability

	pctxt.PushElemName("pre-emptionVulnerability")

	pvalue.PreEmptionVulnerability, err = PerDecodePreEmptionVulnerability(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AllocationAndRetentionPriority) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode priorityLevelARP

	pctxt.PushElemName("priorityLevelARP")

	err = PerEncodePriorityLevelARP(pctxt, pvalue.PriorityLevelARP)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pre_emptionCapability

	pctxt.PushElemName("pre-emptionCapability")

	err = PerEncodePreEmptionCapability(pctxt, pvalue.PreEmptionCapability)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pre_emptionVulnerability

	pctxt.PushElemName("pre-emptionVulnerability")

	err = PerEncodePreEmptionVulnerability(pctxt, pvalue.PreEmptionVulnerability)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AssociatedQosFlowItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode qosFlowIdentifier

	pctxt.PushElemName("qosFlowIdentifier")

	pvalue.QosFlowIdentifier, err = PerDecodeQosFlowIdentifier(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode qosFlowMappingIndication

	if present[optx] {
		pctxt.PushElemName("qosFlowMappingIndication")

		pvalue.QosFlowMappingIndication = new(AssociatedQosFlowItemQosFlowMappingIndication)
		(*pvalue.QosFlowMappingIndication), err = PerDecodeAssociatedQosFlowItemQosFlowMappingIndication(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.QosFlowMappingIndication = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *AssociatedQosFlowItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("qosFlowMappingIndication")
	pctxt.DiagNewBitField("present")

	present = pvalue.QosFlowMappingIndication != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode qosFlowIdentifier

	pctxt.PushElemName("qosFlowIdentifier")

	err = PerEncodeQosFlowIdentifier(pctxt, pvalue.QosFlowIdentifier)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode qosFlowMappingIndication

	if pvalue.QosFlowMappingIndication != nil {
		pctxt.PushElemName("qosFlowMappingIndication")

		err = PerEncodeAssociatedQosFlowItemQosFlowMappingIndication(pctxt, (*pvalue.QosFlowMappingIndication))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *AssociatedQosFlowList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(6, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("AssociatedQosFlowItem", i)

			var elem1 AssociatedQosFlowItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *AssociatedQosFlowList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 64 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 6)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("AssociatedQosFlowItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PacketErrorRate) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pERScalar

	pctxt.PushElemName("pERScalar")

	{
		var extbit bool
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		extbit, err = pctxt.DecBit()
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		if !extbit {
			pctxt.DiagNewBitField("constrained int")

			pvalue.PERScalar, err = pctxt.PerDecBitsToUInt(4)
			if err != nil {
				return
			}

			if pvalue.PERScalar > 9 {
				err = pctxt.ErrValueConsVio(pvalue.PERScalar)
				return
			}

			pctxt.DiagSetBitFieldCount()
		} else {
			if pctxt.AlignBuffer() {
				pctxt.DiagSetBitFieldOffset()
			}
			{
				var len1 byte
				pctxt.DiagNewBitField("length")

				len1, err = pctxt.DecByte()

				pctxt.DiagSetBitFieldCount()
				pctxt.DiagNewBitField("data")

				pvalue.PERScalar, err = pctxt.PerDecBitsToUInt(uint64(len1 * 8))
				if err != nil {
					return
				}

				pctxt.DiagSetBitFieldCount()
			}
		}
	}

	pctxt.PopElemName()
	// decode pERExponent

	pctxt.PushElemName("pERExponent")

	{
		var extbit bool
		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		extbit, err = pctxt.DecBit()
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		if !extbit {
			pctxt.DiagNewBitField("constrained int")

			pvalue.PERExponent, err = pctxt.PerDecBitsToUInt(4)
			if err != nil {
				return
			}

			if pvalue.PERExponent > 9 {
				err = pctxt.ErrValueConsVio(pvalue.PERExponent)
				return
			}

			pctxt.DiagSetBitFieldCount()
		} else {
			if pctxt.AlignBuffer() {
				pctxt.DiagSetBitFieldOffset()
			}
			{
				var len1 byte
				pctxt.DiagNewBitField("length")

				len1, err = pctxt.DecByte()

				pctxt.DiagSetBitFieldCount()
				pctxt.DiagNewBitField("data")

				pvalue.PERExponent, err = pctxt.PerDecBitsToUInt(uint64(len1 * 8))
				if err != nil {
					return
				}

				pctxt.DiagSetBitFieldCount()
			}
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PacketErrorRate) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pERScalar

	pctxt.PushElemName("pERScalar")

	{
		var extbit bool
		if pvalue.PERScalar <= 9 {
			extbit = false
		} else {
			extbit = true
		}

		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(extbit)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		if extbit {
			err = pctxt.PerEncUnconsUInt(pvalue.PERScalar)
			if err != nil {
				return
			}
		} else {
			pctxt.DiagNewBitField("cons int/uint")

			err = pctxt.PerEncBitsFromUInt(uint64(pvalue.PERScalar), 4)
			if err != nil {
				return
			}

			pctxt.DiagSetBitFieldCount()
		}
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pERExponent

	pctxt.PushElemName("pERExponent")

	{
		var extbit bool
		if pvalue.PERExponent <= 9 {
			extbit = false
		} else {
			extbit = true
		}

		/* extension bit */

		pctxt.DiagNewBitField("extension bit")

		err = pctxt.EncBit(extbit)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		if extbit {
			err = pctxt.PerEncUnconsUInt(pvalue.PERExponent)
			if err != nil {
				return
			}
		} else {
			pctxt.DiagNewBitField("cons int/uint")

			err = pctxt.PerEncBitsFromUInt(uint64(pvalue.PERExponent), 4)
			if err != nil {
				return
			}

			pctxt.DiagSetBitFieldCount()
		}
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *Dynamic5QIDescriptor) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [5]bool
	var optx int
	for optx = 0; optx < 5; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode priorityLevelQos

	pctxt.PushElemName("priorityLevelQos")

	pvalue.PriorityLevelQos, err = PerDecodePriorityLevelQos(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode packetDelayBudget

	pctxt.PushElemName("packetDelayBudget")

	pvalue.PacketDelayBudget, err = PerDecodePacketDelayBudget(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode packetErrorRate

	pctxt.PushElemName("packetErrorRate")

	err = pvalue.PacketErrorRate.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode fiveQI

	if present[optx] {
		pctxt.PushElemName("fiveQI")

		pvalue.FiveQI = new(FiveQI)
		(*pvalue.FiveQI), err = PerDecodeFiveQI(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.FiveQI = nil
	}
	optx++

	// decode delayCritical

	if present[optx] {
		pctxt.PushElemName("delayCritical")

		pvalue.DelayCritical = new(DelayCritical)
		(*pvalue.DelayCritical), err = PerDecodeDelayCritical(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.DelayCritical = nil
	}
	optx++

	// decode averagingWindow

	if present[optx] {
		pctxt.PushElemName("averagingWindow")

		pvalue.AveragingWindow = new(AveragingWindow)
		(*pvalue.AveragingWindow), err = PerDecodeAveragingWindow(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.AveragingWindow = nil
	}
	optx++

	// decode maximumDataBurstVolume

	if present[optx] {
		pctxt.PushElemName("maximumDataBurstVolume")

		pvalue.MaximumDataBurstVolume = new(MaximumDataBurstVolume)
		(*pvalue.MaximumDataBurstVolume), err = PerDecodeMaximumDataBurstVolume(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.MaximumDataBurstVolume = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *Dynamic5QIDescriptor) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("fiveQI")
	pctxt.DiagNewBitField("present")

	present = pvalue.FiveQI != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("delayCritical")
	pctxt.DiagNewBitField("present")

	present = pvalue.DelayCritical != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("averagingWindow")
	pctxt.DiagNewBitField("present")

	present = pvalue.AveragingWindow != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("maximumDataBurstVolume")
	pctxt.DiagNewBitField("present")

	present = pvalue.MaximumDataBurstVolume != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode priorityLevelQos

	pctxt.PushElemName("priorityLevelQos")

	err = PerEncodePriorityLevelQos(pctxt, pvalue.PriorityLevelQos)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode packetDelayBudget

	pctxt.PushElemName("packetDelayBudget")

	err = PerEncodePacketDelayBudget(pctxt, pvalue.PacketDelayBudget)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode packetErrorRate

	pctxt.PushElemName("packetErrorRate")

	err = pvalue.PacketErrorRate.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode fiveQI

	if pvalue.FiveQI != nil {
		pctxt.PushElemName("fiveQI")

		err = PerEncodeFiveQI(pctxt, (*pvalue.FiveQI))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode delayCritical

	if pvalue.DelayCritical != nil {
		pctxt.PushElemName("delayCritical")

		err = PerEncodeDelayCritical(pctxt, (*pvalue.DelayCritical))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode averagingWindow

	if pvalue.AveragingWindow != nil {
		pctxt.PushElemName("averagingWindow")

		err = PerEncodeAveragingWindow(pctxt, (*pvalue.AveragingWindow))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode maximumDataBurstVolume

	if pvalue.MaximumDataBurstVolume != nil {
		pctxt.PushElemName("maximumDataBurstVolume")

		err = PerEncodeMaximumDataBurstVolume(pctxt, (*pvalue.MaximumDataBurstVolume))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *EmergencyFallbackIndicator) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode emergencyFallbackRequestIndicator

	pctxt.PushElemName("emergencyFallbackRequestIndicator")

	pvalue.EmergencyFallbackRequestIndicator, err = PerDecodeEmergencyFallbackRequestIndicator(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode emergencyServiceTargetCN

	if present[optx] {
		pctxt.PushElemName("emergencyServiceTargetCN")

		pvalue.EmergencyServiceTargetCN = new(EmergencyServiceTargetCN)
		(*pvalue.EmergencyServiceTargetCN), err = PerDecodeEmergencyServiceTargetCN(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.EmergencyServiceTargetCN = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *EmergencyFallbackIndicator) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("emergencyServiceTargetCN")
	pctxt.DiagNewBitField("present")

	present = pvalue.EmergencyServiceTargetCN != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode emergencyFallbackRequestIndicator

	pctxt.PushElemName("emergencyFallbackRequestIndicator")

	err = PerEncodeEmergencyFallbackRequestIndicator(pctxt, pvalue.EmergencyFallbackRequestIndicator)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode emergencyServiceTargetCN

	if pvalue.EmergencyServiceTargetCN != nil {
		pctxt.PushElemName("emergencyServiceTargetCN")

		err = PerEncodeEmergencyServiceTargetCN(pctxt, (*pvalue.EmergencyServiceTargetCN))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *GBRQosInformation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode maximumFlowBitRateDL

	pctxt.PushElemName("maximumFlowBitRateDL")

	pvalue.MaximumFlowBitRateDL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode maximumFlowBitRateUL

	pctxt.PushElemName("maximumFlowBitRateUL")

	pvalue.MaximumFlowBitRateUL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode guaranteedFlowBitRateDL

	pctxt.PushElemName("guaranteedFlowBitRateDL")

	pvalue.GuaranteedFlowBitRateDL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode guaranteedFlowBitRateUL

	pctxt.PushElemName("guaranteedFlowBitRateUL")

	pvalue.GuaranteedFlowBitRateUL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode notificationControl

	if present[optx] {
		pctxt.PushElemName("notificationControl")

		pvalue.NotificationControl = new(NotificationControl)
		(*pvalue.NotificationControl), err = PerDecodeNotificationControl(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.NotificationControl = nil
	}
	optx++

	// decode maximumPacketLossRateDL

	if present[optx] {
		pctxt.PushElemName("maximumPacketLossRateDL")

		pvalue.MaximumPacketLossRateDL = new(PacketLossRate)
		(*pvalue.MaximumPacketLossRateDL), err = PerDecodePacketLossRate(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.MaximumPacketLossRateDL = nil
	}
	optx++

	// decode maximumPacketLossRateUL

	if present[optx] {
		pctxt.PushElemName("maximumPacketLossRateUL")

		pvalue.MaximumPacketLossRateUL = new(PacketLossRate)
		(*pvalue.MaximumPacketLossRateUL), err = PerDecodePacketLossRate(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.MaximumPacketLossRateUL = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *GBRQosInformation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("notificationControl")
	pctxt.DiagNewBitField("present")

	present = pvalue.NotificationControl != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("maximumPacketLossRateDL")
	pctxt.DiagNewBitField("present")

	present = pvalue.MaximumPacketLossRateDL != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("maximumPacketLossRateUL")
	pctxt.DiagNewBitField("present")

	present = pvalue.MaximumPacketLossRateUL != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode maximumFlowBitRateDL

	pctxt.PushElemName("maximumFlowBitRateDL")

	err = PerEncodeBitRate(pctxt, pvalue.MaximumFlowBitRateDL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode maximumFlowBitRateUL

	pctxt.PushElemName("maximumFlowBitRateUL")

	err = PerEncodeBitRate(pctxt, pvalue.MaximumFlowBitRateUL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode guaranteedFlowBitRateDL

	pctxt.PushElemName("guaranteedFlowBitRateDL")

	err = PerEncodeBitRate(pctxt, pvalue.GuaranteedFlowBitRateDL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode guaranteedFlowBitRateUL

	pctxt.PushElemName("guaranteedFlowBitRateUL")

	err = PerEncodeBitRate(pctxt, pvalue.GuaranteedFlowBitRateUL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode notificationControl

	if pvalue.NotificationControl != nil {
		pctxt.PushElemName("notificationControl")

		err = PerEncodeNotificationControl(pctxt, (*pvalue.NotificationControl))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode maximumPacketLossRateDL

	if pvalue.MaximumPacketLossRateDL != nil {
		pctxt.PushElemName("maximumPacketLossRateDL")

		err = PerEncodePacketLossRate(pctxt, (*pvalue.MaximumPacketLossRateDL))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode maximumPacketLossRateUL

	if pvalue.MaximumPacketLossRateUL != nil {
		pctxt.PushElemName("maximumPacketLossRateUL")

		err = PerEncodePacketLossRate(pctxt, (*pvalue.MaximumPacketLossRateUL))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *GTPTunnel) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode transportLayerAddress

	pctxt.PushElemName("transportLayerAddress")

	pvalue.TransportLayerAddress, err = PerDecodeTransportLayerAddress(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode gTP_TEID

	pctxt.PushElemName("gTP-TEID")

	pvalue.GTPTEID, err = PerDecodeGTPTEID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *GTPTunnel) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode transportLayerAddress

	pctxt.PushElemName("transportLayerAddress")

	err = PerEncodeTransportLayerAddress(pctxt, pvalue.TransportLayerAddress)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode gTP_TEID

	pctxt.PushElemName("gTP-TEID")

	err = PerEncodeGTPTEID(pctxt, pvalue.GTPTEID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *NonDynamic5QIDescriptor) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode fiveQI

	pctxt.PushElemName("fiveQI")

	pvalue.FiveQI, err = PerDecodeFiveQI(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode priorityLevelQos

	if present[optx] {
		pctxt.PushElemName("priorityLevelQos")

		pvalue.PriorityLevelQos = new(PriorityLevelQos)
		(*pvalue.PriorityLevelQos), err = PerDecodePriorityLevelQos(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.PriorityLevelQos = nil
	}
	optx++

	// decode averagingWindow

	if present[optx] {
		pctxt.PushElemName("averagingWindow")

		pvalue.AveragingWindow = new(AveragingWindow)
		(*pvalue.AveragingWindow), err = PerDecodeAveragingWindow(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.AveragingWindow = nil
	}
	optx++

	// decode maximumDataBurstVolume

	if present[optx] {
		pctxt.PushElemName("maximumDataBurstVolume")

		pvalue.MaximumDataBurstVolume = new(MaximumDataBurstVolume)
		(*pvalue.MaximumDataBurstVolume), err = PerDecodeMaximumDataBurstVolume(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.MaximumDataBurstVolume = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *NonDynamic5QIDescriptor) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("priorityLevelQos")
	pctxt.DiagNewBitField("present")

	present = pvalue.PriorityLevelQos != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("averagingWindow")
	pctxt.DiagNewBitField("present")

	present = pvalue.AveragingWindow != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("maximumDataBurstVolume")
	pctxt.DiagNewBitField("present")

	present = pvalue.MaximumDataBurstVolume != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode fiveQI

	pctxt.PushElemName("fiveQI")

	err = PerEncodeFiveQI(pctxt, pvalue.FiveQI)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode priorityLevelQos

	if pvalue.PriorityLevelQos != nil {
		pctxt.PushElemName("priorityLevelQos")

		err = PerEncodePriorityLevelQos(pctxt, (*pvalue.PriorityLevelQos))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode averagingWindow

	if pvalue.AveragingWindow != nil {
		pctxt.PushElemName("averagingWindow")

		err = PerEncodeAveragingWindow(pctxt, (*pvalue.AveragingWindow))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode maximumDataBurstVolume

	if pvalue.MaximumDataBurstVolume != nil {
		pctxt.PushElemName("maximumDataBurstVolume")

		err = PerEncodeMaximumDataBurstVolume(pctxt, (*pvalue.MaximumDataBurstVolume))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupUnsuccessfulTransfer) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode cause

	pctxt.PushElemName("cause")

	err = pvalue.Cause.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode criticalityDiagnostics

	if present[optx] {
		pctxt.PushElemName("criticalityDiagnostics")

		pvalue.CriticalityDiagnostics = new(CriticalityDiagnostics)
		err = pvalue.CriticalityDiagnostics.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.CriticalityDiagnostics = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupUnsuccessfulTransfer) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("criticalityDiagnostics")
	pctxt.DiagNewBitField("present")

	present = pvalue.CriticalityDiagnostics != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode cause

	pctxt.PushElemName("cause")

	err = pvalue.Cause.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode criticalityDiagnostics

	if pvalue.CriticalityDiagnostics != nil {
		pctxt.PushElemName("criticalityDiagnostics")

		err = (*pvalue.CriticalityDiagnostics).PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceFailedToSetupItemCxtFail) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceSetupUnsuccessfulTransfer

	pctxt.PushElemName("pDUSessionResourceSetupUnsuccessfulTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceSetupUnsuccessfulTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceFailedToSetupItemCxtFail) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceSetupUnsuccessfulTransfer

	pctxt.PushElemName("pDUSessionResourceSetupUnsuccessfulTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceSetupUnsuccessfulTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceFailedToSetupListCxtFail) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceFailedToSetupItemCxtFail", i)

			var elem1 PDUSessionResourceFailedToSetupItemCxtFail
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceFailedToSetupListCxtFail) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceFailedToSetupItemCxtFail", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceFailedToSetupItemCxtRes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceSetupUnsuccessfulTransfer

	pctxt.PushElemName("pDUSessionResourceSetupUnsuccessfulTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceSetupUnsuccessfulTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceFailedToSetupItemCxtRes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceSetupUnsuccessfulTransfer

	pctxt.PushElemName("pDUSessionResourceSetupUnsuccessfulTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceSetupUnsuccessfulTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceFailedToSetupListCxtRes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceFailedToSetupItemCxtRes", i)

			var elem1 PDUSessionResourceFailedToSetupItemCxtRes
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceFailedToSetupListCxtRes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceFailedToSetupItemCxtRes", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceFailedToSetupItemSURes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceSetupUnsuccessfulTransfer

	pctxt.PushElemName("pDUSessionResourceSetupUnsuccessfulTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceSetupUnsuccessfulTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceFailedToSetupItemSURes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceSetupUnsuccessfulTransfer

	pctxt.PushElemName("pDUSessionResourceSetupUnsuccessfulTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceSetupUnsuccessfulTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceFailedToSetupListSURes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceFailedToSetupItemSURes", i)

			var elem1 PDUSessionResourceFailedToSetupItemSURes
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceFailedToSetupListSURes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceFailedToSetupItemSURes", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupRequestTransfer) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	// decode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupRequestTransfer) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	// encode protocolIEs

	pctxt.PushElemName("protocolIEs")

	err = pvalue.ProtocolIEs.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupItemSUReq) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionNAS_PDU

	if present[optx] {
		pctxt.PushElemName("pDUSessionNAS-PDU")

		pvalue.PDUSessionNASPDU = new(NASPDU)
		(*pvalue.PDUSessionNASPDU), err = PerDecodeNASPDU(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.PDUSessionNASPDU = nil
	}
	optx++

	// decode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceSetupRequestTransfer

	pctxt.PushElemName("pDUSessionResourceSetupRequestTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceSetupRequestTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupItemSUReq) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("pDUSessionNAS-PDU")
	pctxt.DiagNewBitField("present")

	present = pvalue.PDUSessionNASPDU != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionNAS_PDU

	if pvalue.PDUSessionNASPDU != nil {
		pctxt.PushElemName("pDUSessionNAS-PDU")

		err = PerEncodeNASPDU(pctxt, (*pvalue.PDUSessionNASPDU))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceSetupRequestTransfer

	pctxt.PushElemName("pDUSessionResourceSetupRequestTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceSetupRequestTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupListSUReq) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceSetupItemSUReq", i)

			var elem1 PDUSessionResourceSetupItemSUReq
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupListSUReq) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceSetupItemSUReq", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupItemCxtReq) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode nAS_PDU

	if present[optx] {
		pctxt.PushElemName("nAS-PDU")

		pvalue.NASPDU = new(NASPDU)
		(*pvalue.NASPDU), err = PerDecodeNASPDU(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.NASPDU = nil
	}
	optx++

	// decode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceSetupRequestTransfer

	pctxt.PushElemName("pDUSessionResourceSetupRequestTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceSetupRequestTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupItemCxtReq) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("nAS-PDU")
	pctxt.DiagNewBitField("present")

	present = pvalue.NASPDU != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode nAS_PDU

	if pvalue.NASPDU != nil {
		pctxt.PushElemName("nAS-PDU")

		err = PerEncodeNASPDU(pctxt, (*pvalue.NASPDU))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode s_NSSAI

	pctxt.PushElemName("s-NSSAI")

	err = pvalue.SNSSAI.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceSetupRequestTransfer

	pctxt.PushElemName("pDUSessionResourceSetupRequestTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceSetupRequestTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupListCxtReq) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceSetupItemCxtReq", i)

			var elem1 PDUSessionResourceSetupItemCxtReq
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupListCxtReq) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceSetupItemCxtReq", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *UPTransportLayerInformation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	pctxt.DiagNewBitField("<choice-index>")

	idx, err = pctxt.PerDecBitsToUInt(1)
	pctxt.DiagSetBitFieldCount()

	switch idx {
	/* gTPTunnel */
	case 0:
		(*pvalue).T = UPTransportLayerInformationGTPTunnelTAG
		pctxt.PushElemName("gTPTunnel")

		pvalue.U.GTPTunnel = new(GTPTunnel)
		err = pvalue.U.GTPTunnel.PerDecode(pctxt)
		pctxt.PopElemName()

	/* choice_Extensions */
	case 1:
		(*pvalue).T = UPTransportLayerInformationChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *UPTransportLayerInformation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case UPTransportLayerInformationGTPTunnelTAG:
		idx = 0
	case UPTransportLayerInformationChoiceExtensionsTAG:
		idx = 1
	}
	/* Encode choice index value */

	pctxt.DiagNewBitField("<choice-index>")

	err = pctxt.PerEncBitsFromUInt(idx, 1)
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode gTPTunnel

		if pvalue.U.GTPTunnel == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("gTPTunnel")

		alt := GTPTunnel((*pvalue.U.GTPTunnel))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 1:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowPerTNLInformation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode uPTransportLayerInformation

	pctxt.PushElemName("uPTransportLayerInformation")

	err = pvalue.UPTransportLayerInformation.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode associatedQosFlowList

	pctxt.PushElemName("associatedQosFlowList")

	err = pvalue.AssociatedQosFlowList.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *QosFlowPerTNLInformation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode uPTransportLayerInformation

	pctxt.PushElemName("uPTransportLayerInformation")

	err = pvalue.UPTransportLayerInformation.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode associatedQosFlowList

	pctxt.PushElemName("associatedQosFlowList")

	err = pvalue.AssociatedQosFlowList.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowPerTNLInformationItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode qosFlowPerTNLInformation

	pctxt.PushElemName("qosFlowPerTNLInformation")

	err = pvalue.QosFlowPerTNLInformation.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *QosFlowPerTNLInformationItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode qosFlowPerTNLInformation

	pctxt.PushElemName("qosFlowPerTNLInformation")

	err = pvalue.QosFlowPerTNLInformation.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowPerTNLInformationList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(2, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("QosFlowPerTNLInformationItem", i)

			var elem1 QosFlowPerTNLInformationItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *QosFlowPerTNLInformationList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 3 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 2)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("QosFlowPerTNLInformationItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *SecurityResult) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode integrityProtectionResult

	pctxt.PushElemName("integrityProtectionResult")

	pvalue.IntegrityProtectionResult, err = PerDecodeIntegrityProtectionResult(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode confidentialityProtectionResult

	pctxt.PushElemName("confidentialityProtectionResult")

	pvalue.ConfidentialityProtectionResult, err = PerDecodeConfidentialityProtectionResult(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *SecurityResult) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode integrityProtectionResult

	pctxt.PushElemName("integrityProtectionResult")

	err = PerEncodeIntegrityProtectionResult(pctxt, pvalue.IntegrityProtectionResult)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode confidentialityProtectionResult

	pctxt.PushElemName("confidentialityProtectionResult")

	err = PerEncodeConfidentialityProtectionResult(pctxt, pvalue.ConfidentialityProtectionResult)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowWithCauseItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode qosFlowIdentifier

	pctxt.PushElemName("qosFlowIdentifier")

	pvalue.QosFlowIdentifier, err = PerDecodeQosFlowIdentifier(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode cause

	pctxt.PushElemName("cause")

	err = pvalue.Cause.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *QosFlowWithCauseItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode qosFlowIdentifier

	pctxt.PushElemName("qosFlowIdentifier")

	err = PerEncodeQosFlowIdentifier(pctxt, pvalue.QosFlowIdentifier)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode cause

	pctxt.PushElemName("cause")

	err = pvalue.Cause.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowListWithCause) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(6, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("QosFlowWithCauseItem", i)

			var elem1 QosFlowWithCauseItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *QosFlowListWithCause) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 64 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 6)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("QosFlowWithCauseItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupResponseTransfer) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode dLQosFlowPerTNLInformation

	pctxt.PushElemName("dLQosFlowPerTNLInformation")

	err = pvalue.DLQosFlowPerTNLInformation.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode additionalDLQosFlowPerTNLInformation

	if present[optx] {
		pctxt.PushElemName("additionalDLQosFlowPerTNLInformation")

		err = pvalue.AdditionalDLQosFlowPerTNLInformation.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode securityResult

	if present[optx] {
		pctxt.PushElemName("securityResult")

		pvalue.SecurityResult = new(SecurityResult)
		err = pvalue.SecurityResult.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.SecurityResult = nil
	}
	optx++

	// decode qosFlowFailedToSetupList

	if present[optx] {
		pctxt.PushElemName("qosFlowFailedToSetupList")

		err = pvalue.QosFlowFailedToSetupList.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupResponseTransfer) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("additionalDLQosFlowPerTNLInformation")
	pctxt.DiagNewBitField("present")

	present = pvalue.AdditionalDLQosFlowPerTNLInformation != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("securityResult")
	pctxt.DiagNewBitField("present")

	present = pvalue.SecurityResult != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("qosFlowFailedToSetupList")
	pctxt.DiagNewBitField("present")

	present = pvalue.QosFlowFailedToSetupList != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode dLQosFlowPerTNLInformation

	pctxt.PushElemName("dLQosFlowPerTNLInformation")

	err = pvalue.DLQosFlowPerTNLInformation.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode additionalDLQosFlowPerTNLInformation

	if pvalue.AdditionalDLQosFlowPerTNLInformation != nil {
		pctxt.PushElemName("additionalDLQosFlowPerTNLInformation")

		err = pvalue.AdditionalDLQosFlowPerTNLInformation.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode securityResult

	if pvalue.SecurityResult != nil {
		pctxt.PushElemName("securityResult")

		err = (*pvalue.SecurityResult).PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode qosFlowFailedToSetupList

	if pvalue.QosFlowFailedToSetupList != nil {
		pctxt.PushElemName("qosFlowFailedToSetupList")

		err = pvalue.QosFlowFailedToSetupList.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupItemCxtRes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceSetupResponseTransfer

	pctxt.PushElemName("pDUSessionResourceSetupResponseTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceSetupResponseTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupItemCxtRes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceSetupResponseTransfer

	pctxt.PushElemName("pDUSessionResourceSetupResponseTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceSetupResponseTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupListCxtRes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceSetupItemCxtRes", i)

			var elem1 PDUSessionResourceSetupItemCxtRes
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupListCxtRes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceSetupItemCxtRes", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupItemSURes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceSetupResponseTransfer

	pctxt.PushElemName("pDUSessionResourceSetupResponseTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceSetupResponseTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupItemSURes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceSetupResponseTransfer

	pctxt.PushElemName("pDUSessionResourceSetupResponseTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceSetupResponseTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceSetupListSURes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceSetupItemSURes", i)

			var elem1 PDUSessionResourceSetupItemSURes
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceSetupListSURes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceSetupItemSURes", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionAggregateMaximumBitRate) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionAggregateMaximumBitRateDL

	pctxt.PushElemName("pDUSessionAggregateMaximumBitRateDL")

	pvalue.PDUSessionAggregateMaximumBitRateDL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionAggregateMaximumBitRateUL

	pctxt.PushElemName("pDUSessionAggregateMaximumBitRateUL")

	pvalue.PDUSessionAggregateMaximumBitRateUL, err = PerDecodeBitRate(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionAggregateMaximumBitRate) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionAggregateMaximumBitRateDL

	pctxt.PushElemName("pDUSessionAggregateMaximumBitRateDL")

	err = PerEncodeBitRate(pctxt, pvalue.PDUSessionAggregateMaximumBitRateDL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionAggregateMaximumBitRateUL

	pctxt.PushElemName("pDUSessionAggregateMaximumBitRateUL")

	err = PerEncodeBitRate(pctxt, pvalue.PDUSessionAggregateMaximumBitRateUL)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *QosCharacteristics) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	pctxt.DiagNewBitField("<choice-index>")

	idx, err = pctxt.PerDecBitsToUInt(2)
	pctxt.DiagSetBitFieldCount()

	switch idx {
	/* nonDynamic5QI */
	case 0:
		(*pvalue).T = QosCharacteristicsNonDynamic5QITAG
		pctxt.PushElemName("nonDynamic5QI")

		pvalue.U.NonDynamic5QI = new(NonDynamic5QIDescriptor)
		err = pvalue.U.NonDynamic5QI.PerDecode(pctxt)
		pctxt.PopElemName()

	/* dynamic5QI */
	case 1:
		(*pvalue).T = QosCharacteristicsDynamic5QITAG
		pctxt.PushElemName("dynamic5QI")

		pvalue.U.Dynamic5QI = new(Dynamic5QIDescriptor)
		err = pvalue.U.Dynamic5QI.PerDecode(pctxt)
		pctxt.PopElemName()

	/* choice_Extensions */
	case 2:
		(*pvalue).T = QosCharacteristicsChoiceExtensionsTAG
		pctxt.PushElemName("choice-Extensions")

		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerEncode method implementation
func (pvalue *QosCharacteristics) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var idx uint64
	switch (*pvalue).T {
	case QosCharacteristicsNonDynamic5QITAG:
		idx = 0
	case QosCharacteristicsDynamic5QITAG:
		idx = 1
	case QosCharacteristicsChoiceExtensionsTAG:
		idx = 2
	}
	/* Encode choice index value */

	pctxt.DiagNewBitField("<choice-index>")

	err = pctxt.PerEncBitsFromUInt(idx, 2)
	if err != nil {
		return
	}

	pctxt.DiagSetBitFieldCount()

	/* Encode alternative data value */

	switch idx {
	case 0:
		// encode nonDynamic5QI

		if pvalue.U.NonDynamic5QI == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("nonDynamic5QI")

		alt := NonDynamic5QIDescriptor((*pvalue.U.NonDynamic5QI))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 1:
		// encode dynamic5QI

		if pvalue.U.Dynamic5QI == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("dynamic5QI")

		alt := Dynamic5QIDescriptor((*pvalue.U.Dynamic5QI))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	case 2:
		// encode choice_Extensions

		if pvalue.U.ChoiceExtensions == nil {
			return pctxt.ErrWithNoParam("unexpected nil pointer")
		}
		pctxt.PushElemName("choice-Extensions")

		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
		err = alt.PerEncode(pctxt)

		pctxt.PopElemName()

	default:
		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
		return
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowLevelQosParameters) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [4]bool
	var optx int
	for optx = 0; optx < 4; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode qosCharacteristics

	pctxt.PushElemName("qosCharacteristics")

	err = pvalue.QosCharacteristics.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode allocationAndRetentionPriority

	pctxt.PushElemName("allocationAndRetentionPriority")

	err = pvalue.AllocationAndRetentionPriority.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode gBR_QosInformation

	if present[optx] {
		pctxt.PushElemName("gBR-QosInformation")

		pvalue.GBRQosInformation = new(GBRQosInformation)
		err = pvalue.GBRQosInformation.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.GBRQosInformation = nil
	}
	optx++

	// decode reflectiveQosAttribute

	if present[optx] {
		pctxt.PushElemName("reflectiveQosAttribute")

		pvalue.ReflectiveQosAttribute = new(ReflectiveQosAttribute)
		(*pvalue.ReflectiveQosAttribute), err = PerDecodeReflectiveQosAttribute(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ReflectiveQosAttribute = nil
	}
	optx++

	// decode additionalQosFlowInformation

	if present[optx] {
		pctxt.PushElemName("additionalQosFlowInformation")

		pvalue.AdditionalQosFlowInformation = new(AdditionalQosFlowInformation)
		(*pvalue.AdditionalQosFlowInformation), err = PerDecodeAdditionalQosFlowInformation(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.AdditionalQosFlowInformation = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *QosFlowLevelQosParameters) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("gBR-QosInformation")
	pctxt.DiagNewBitField("present")

	present = pvalue.GBRQosInformation != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("reflectiveQosAttribute")
	pctxt.DiagNewBitField("present")

	present = pvalue.ReflectiveQosAttribute != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("additionalQosFlowInformation")
	pctxt.DiagNewBitField("present")

	present = pvalue.AdditionalQosFlowInformation != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode qosCharacteristics

	pctxt.PushElemName("qosCharacteristics")

	err = pvalue.QosCharacteristics.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode allocationAndRetentionPriority

	pctxt.PushElemName("allocationAndRetentionPriority")

	err = pvalue.AllocationAndRetentionPriority.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode gBR_QosInformation

	if pvalue.GBRQosInformation != nil {
		pctxt.PushElemName("gBR-QosInformation")

		err = (*pvalue.GBRQosInformation).PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode reflectiveQosAttribute

	if pvalue.ReflectiveQosAttribute != nil {
		pctxt.PushElemName("reflectiveQosAttribute")

		err = PerEncodeReflectiveQosAttribute(pctxt, (*pvalue.ReflectiveQosAttribute))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode additionalQosFlowInformation

	if pvalue.AdditionalQosFlowInformation != nil {
		pctxt.PushElemName("additionalQosFlowInformation")

		err = PerEncodeAdditionalQosFlowInformation(pctxt, (*pvalue.AdditionalQosFlowInformation))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowSetupRequestItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode qosFlowIdentifier

	pctxt.PushElemName("qosFlowIdentifier")

	pvalue.QosFlowIdentifier, err = PerDecodeQosFlowIdentifier(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode qosFlowLevelQosParameters

	pctxt.PushElemName("qosFlowLevelQosParameters")

	err = pvalue.QosFlowLevelQosParameters.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode e_RAB_ID

	if present[optx] {
		pctxt.PushElemName("e-RAB-ID")

		pvalue.ERABID = new(ERABID)
		(*pvalue.ERABID), err = PerDecodeERABID(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.ERABID = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *QosFlowSetupRequestItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("e-RAB-ID")
	pctxt.DiagNewBitField("present")

	present = pvalue.ERABID != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode qosFlowIdentifier

	pctxt.PushElemName("qosFlowIdentifier")

	err = PerEncodeQosFlowIdentifier(pctxt, pvalue.QosFlowIdentifier)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode qosFlowLevelQosParameters

	pctxt.PushElemName("qosFlowLevelQosParameters")

	err = pvalue.QosFlowLevelQosParameters.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode e_RAB_ID

	if pvalue.ERABID != nil {
		pctxt.PushElemName("e-RAB-ID")

		err = PerEncodeERABID(pctxt, (*pvalue.ERABID))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *QosFlowSetupRequestList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(6, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("QosFlowSetupRequestItem", i)

			var elem1 QosFlowSetupRequestItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *QosFlowSetupRequestList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 64 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 6)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("QosFlowSetupRequestItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *SecurityIndication) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [2]bool
	var optx int
	for optx = 0; optx < 2; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode integrityProtectionIndication

	pctxt.PushElemName("integrityProtectionIndication")

	pvalue.IntegrityProtectionIndication, err = PerDecodeIntegrityProtectionIndication(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode confidentialityProtectionIndication

	pctxt.PushElemName("confidentialityProtectionIndication")

	pvalue.ConfidentialityProtectionIndication, err = PerDecodeConfidentialityProtectionIndication(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode maximumIntegrityProtectedDataRate_UL

	if present[optx] {
		pctxt.PushElemName("maximumIntegrityProtectedDataRate-UL")

		pvalue.MaximumIntegrityProtectedDataRateUL = new(MaximumIntegrityProtectedDataRate)
		(*pvalue.MaximumIntegrityProtectedDataRateUL), err = PerDecodeMaximumIntegrityProtectedDataRate(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	} else {
		pvalue.MaximumIntegrityProtectedDataRateUL = nil
	}
	optx++

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *SecurityIndication) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("maximumIntegrityProtectedDataRate-UL")
	pctxt.DiagNewBitField("present")

	present = pvalue.MaximumIntegrityProtectedDataRateUL != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode integrityProtectionIndication

	pctxt.PushElemName("integrityProtectionIndication")

	err = PerEncodeIntegrityProtectionIndication(pctxt, pvalue.IntegrityProtectionIndication)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode confidentialityProtectionIndication

	pctxt.PushElemName("confidentialityProtectionIndication")

	err = PerEncodeConfidentialityProtectionIndication(pctxt, pvalue.ConfidentialityProtectionIndication)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode maximumIntegrityProtectedDataRate_UL

	if pvalue.MaximumIntegrityProtectedDataRateUL != nil {
		pctxt.PushElemName("maximumIntegrityProtectedDataRate-UL")

		err = PerEncodeMaximumIntegrityProtectedDataRate(pctxt, (*pvalue.MaximumIntegrityProtectedDataRateUL))

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *TraceActivation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode nGRANTraceID

	pctxt.PushElemName("nGRANTraceID")

	pvalue.NGRANTraceID, err = PerDecodeNGRANTraceID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode interfacesToTrace

	pctxt.PushElemName("interfacesToTrace")

	pvalue.InterfacesToTrace, err = PerDecodeInterfacesToTrace(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode traceDepth

	pctxt.PushElemName("traceDepth")

	pvalue.TraceDepth, err = PerDecodeTraceDepth(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode traceCollectionEntityIPAddress

	pctxt.PushElemName("traceCollectionEntityIPAddress")

	pvalue.TraceCollectionEntityIPAddress, err = PerDecodeTransportLayerAddress(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *TraceActivation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode nGRANTraceID

	pctxt.PushElemName("nGRANTraceID")

	err = PerEncodeNGRANTraceID(pctxt, pvalue.NGRANTraceID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode interfacesToTrace

	pctxt.PushElemName("interfacesToTrace")

	err = PerEncodeInterfacesToTrace(pctxt, pvalue.InterfacesToTrace)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode traceDepth

	pctxt.PushElemName("traceDepth")

	err = PerEncodeTraceDepth(pctxt, pvalue.TraceDepth)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode traceCollectionEntityIPAddress

	pctxt.PushElemName("traceCollectionEntityIPAddress")

	err = PerEncodeTransportLayerAddress(pctxt, pvalue.TraceCollectionEntityIPAddress)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UPTransportLayerInformationItem) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode nGU_UP_TNLInformation

	pctxt.PushElemName("nGU-UP-TNLInformation")

	err = pvalue.NGUUPTNLInformation.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *UPTransportLayerInformationItem) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode nGU_UP_TNLInformation

	pctxt.PushElemName("nGU-UP-TNLInformation")

	err = pvalue.NGUUPTNLInformation.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *UPTransportLayerInformationList) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(2, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("UPTransportLayerInformationItem", i)

			var elem1 UPTransportLayerInformationItem
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *UPTransportLayerInformationList) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 3 {
		pctxt.DiagNewBitField("length")

		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 2)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("UPTransportLayerInformationItem", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceToReleaseItemRelCmd) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceReleaseCommandTransfer

	pctxt.PushElemName("pDUSessionResourceReleaseCommandTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceReleaseCommandTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceToReleaseItemRelCmd) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceReleaseCommandTransfer

	pctxt.PushElemName("pDUSessionResourceReleaseCommandTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceReleaseCommandTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceToReleaseListRelCmd) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceToReleaseItemRelCmd", i)

			var elem1 PDUSessionResourceToReleaseItemRelCmd
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceToReleaseListRelCmd) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceToReleaseItemRelCmd", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceReleaseResponseTransfer) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceReleaseResponseTransfer) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceReleasedItemRelRes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	pvalue.PDUSessionID, err = PerDecodePDUSessionID(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode pDUSessionResourceReleaseResponseTransfer

	pctxt.PushElemName("pDUSessionResourceReleaseResponseTransfer")

	{
		var decodedLen uint64
		var databuf []byte
		var frag bool
		var pctxt2 *asn1rt.OSRTContext
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		otbitidx := pctxt.BitOffset()

		decodedLen, frag, err = pctxt.PerDecUnconsLen()
		if err != nil {
			return
		}

		if frag {
			pctxt.SetBitOffset(otbitidx)
			databuf, err = pctxt.PerDecUnconsOctStr()
			if err != nil {
				return
			}
			pctxt2 = pctxt
			pctxt = new(asn1rt.OSRTContext)
			pctxt.InitDecodeBytes(databuf)
		} else {
			otbitidx = pctxt.BitOffset()
		}

		bitidx := pctxt.BitOffset()
		err = pvalue.PDUSessionResourceReleaseResponseTransfer.PerDecode(pctxt)
		if err != nil {
			return
		}
		pctxt.PerDecByteAlign()
		decodedLen *= 8 // get length in bits
		if decodedLen != pctxt.BitOffset()-bitidx {
			return pctxt.ErrWithNoParam(
				"Invalid containing type length")
		}
		if frag {
			pctxt = pctxt2
		} else {
			pctxt.SetBitOffset(otbitidx + decodedLen)
		}
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceReleasedItemRelRes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode pDUSessionID

	pctxt.PushElemName("pDUSessionID")

	err = PerEncodePDUSessionID(pctxt, pvalue.PDUSessionID)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode pDUSessionResourceReleaseResponseTransfer

	pctxt.PushElemName("pDUSessionResourceReleaseResponseTransfer")

	{
		var bitidx uint64
		bitidx, err = pctxt.PerEncEmbeddedLenStart(true)
		if err != nil {
			return
		}

		err = pvalue.PDUSessionResourceReleaseResponseTransfer.PerEncode(pctxt)

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncEmbeddedLenEnd(bitidx, false)
	}

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceReleasedListRelRes) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	{
		var nitems uint64
		if pctxt.AlignBuffer() {
			pctxt.DiagSetBitFieldOffset()
		}
		pctxt.DiagNewBitField("length")

		nitems, err = pctxt.PerDecConsLength(8, 1)
		if err != nil {
			return
		}
		pctxt.DiagSetBitFieldCount()

		for i := uint64(0); i < nitems; i++ {
			pctxt.PushArrayElemName("PDUSessionResourceReleasedItemRelRes", i)

			var elem1 PDUSessionResourceReleasedItemRelRes
			err = elem1.PerDecode(pctxt)
			if err != nil {
				return
			}
			(*pvalue) = append((*pvalue), elem1)

			pctxt.PopElemName()
		}
	}

	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceReleasedListRelRes) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	var nitems uint64
	nitems = uint64(len((*pvalue)))
	if nitems >= 1 && nitems <= 256 {
		pctxt.DiagNewBitField("length")

		pctxt.PerEncBufAlign()
		err = pctxt.PerEncBitsFromUInt(uint64((nitems - 1)), 8)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

	} else {
		err = pctxt.ErrSizeConsVio(nitems)
		return
	}
	// Encode elements
	var xx1 uint64
	for xx1 = 0; xx1 < nitems; xx1++ {
		pctxt.PushArrayElemName("PDUSessionResourceReleasedItemRelRes", xx1)

		err = (*pvalue)[xx1].PerEncode(pctxt)

		pctxt.PopElemName()
		if err != nil {
			return
		}
	}

	return
}

// PerDecode method implementation
func (pvalue *PDUSessionResourceReleaseCommandTransfer) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
	var extbit bool
	/* extension bit */

	pctxt.DiagNewBitField("extension bit")

	extbit, err = pctxt.DecBit()

	pctxt.DiagSetBitFieldCount()

	pctxt.DiagNewBitField("opt elem bits")

	var present [1]bool
	var optx int
	for optx = 0; optx < 1; optx++ {
		present[optx], err = pctxt.DecBit()
		if err != nil {
			return
		}
	}
	optx = 0
	pctxt.DiagSetBitFieldCount()

	// decode cause

	pctxt.PushElemName("cause")

	err = pvalue.Cause.PerDecode(pctxt)
	if err != nil {
		return
	}

	pctxt.PopElemName()
	// decode iE_Extensions

	if present[optx] {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerDecode(pctxt)
		if err != nil {
			return
		}

		pctxt.PopElemName()
	}
	optx++

	if extbit {
		/* decode extension optional bits */

		pctxt.DiagNewBitField("ext opt bits len")

		var bitcnt uint64
		bitcnt, err = pctxt.PerDecSmallLength()
		if err != nil {
			return
		}

		pctxt.DiagNewBitField("ext opt bit mask")
		optbits := make([]bool, bitcnt)
		for i := uint64(0); i < bitcnt; i++ {
			optbits[i], err = pctxt.DecBit()
			if err != nil {
				return
			}
		}
		pctxt.DiagSetBitFieldCount()
		for i := uint64(0); i < bitcnt; i++ {
			if optbits[i] {
			}
		}
	}
	return
}

// PerEncode method implementation
func (pvalue *PDUSessionResourceReleaseCommandTransfer) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
	extbit := len(pvalue.ExtElem1) > 0 /* extension bit */

	pctxt.DiagNewBitField("extension bit")

	err = pctxt.EncBit(extbit)

	pctxt.DiagSetBitFieldCount()

	var present bool
	pctxt.PushElemName("iE-Extensions")
	pctxt.DiagNewBitField("present")

	present = pvalue.IEExtensions != nil
	err = pctxt.EncBit(present)
	if err != nil {
		return
	}
	pctxt.PopElemName()

	// encode cause

	pctxt.PushElemName("cause")

	err = pvalue.Cause.PerEncode(pctxt)

	pctxt.PopElemName()

	if err != nil {
		return
	}

	// encode iE_Extensions

	if pvalue.IEExtensions != nil {
		pctxt.PushElemName("iE-Extensions")

		err = pvalue.IEExtensions.PerEncode(pctxt)

		pctxt.PopElemName()
	}

	if err != nil {
		return
	}
	if extbit {

		/* encode extension optional bits length */

		pctxt.DiagNewBitField("ext opt bits len")

		err = pctxt.PerEncSmallLength(uint64(len(pvalue.ExtElem1)))
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode optional bits */

		pctxt.DiagNewBitField("unknown opt bits")

		err = pctxt.PerEncOpenTypeExtBits(pvalue.ExtElem1)
		if err != nil {
			return
		}

		pctxt.DiagSetBitFieldCount()

		/* encode extension elements */

		if uint64(len(pvalue.ExtElem1)) > 0 {
			err = pctxt.PerEncOpenTypeExt(pvalue.ExtElem1)
			if err != nil {
				return
			}
		}
	}
	return
}

// // PerDecode method implementation
// func (pvalue *UPTransportLayerInformation) PerDecode(pctxt *asn1rt.OSRTContext) (err error) {
// 	var idx uint64
// 	pctxt.DiagNewBitField("<choice-index>")
// 	idx, err = pctxt.PerDecBitsToUInt(1)
// 	pctxt.DiagSetBitFieldCount()
// 	switch idx {
// 	/* gTPTunnel */
// 	case 0:
// 		(*pvalue).T = UPTransportLayerInformationGTPTunnelTAG
// 		pctxt.PushElemName("gTPTunnel")

// 		pvalue.U.GTPTunnel = new(GTPTunnel)
// 		err = pvalue.U.GTPTunnel.PerDecode(pctxt)
// 		pctxt.PopElemName()

// 	/* choice_Extensions */
// 	case 1:
// 		(*pvalue).T = UPTransportLayerInformationChoiceExtensionsTAG
// 		pctxt.PushElemName("choice-Extensions")

// 		pvalue.U.ChoiceExtensions = new(ProtocolIESingleContainer)
// 		err = pvalue.U.ChoiceExtensions.PerDecode(pctxt)
// 		pctxt.PopElemName()

// 	default:
// 		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
// 		return
// 	}
// 	return
// }

// // PerEncode method implementation
// func (pvalue *UPTransportLayerInformation) PerEncode(pctxt *asn1rt.OSRTContext) (err error) {
// 	var idx uint64
// 	switch (*pvalue).T {
// 	case UPTransportLayerInformationGTPTunnelTAG:
// 		idx = 0
// 	case UPTransportLayerInformationChoiceExtensionsTAG:
// 		idx = 1
// 	}
// 	/* Encode choice index value */

// 	pctxt.DiagNewBitField("<choice-index>")

// 	err = pctxt.PerEncBitsFromUInt(idx, 1)
// 	if err != nil {
// 		return
// 	}

// 	pctxt.DiagSetBitFieldCount()

// 	/* Encode alternative data value */

// 	switch idx {
// 	case 0:
// 		// encode gTPTunnel

// 		if pvalue.U.GTPTunnel == nil {
// 			return pctxt.ErrWithNoParam("unexpected nil pointer")
// 		}
// 		pctxt.PushElemName("gTPTunnel")

// 		alt := GTPTunnel((*pvalue.U.GTPTunnel))
// 		err = alt.PerEncode(pctxt)

// 		pctxt.PopElemName()

// 	case 1:
// 		// encode choice_Extensions

// 		if pvalue.U.ChoiceExtensions == nil {
// 			return pctxt.ErrWithNoParam("unexpected nil pointer")
// 		}
// 		pctxt.PushElemName("choice-Extensions")

// 		alt := ProtocolIESingleContainer((*pvalue.U.ChoiceExtensions))
// 		err = alt.PerEncode(pctxt)

// 		pctxt.PopElemName()

// 	default:
// 		err = pctxt.ErrWithNoParam("Invalid option in CHOICE")
// 		return
// 	}
// 	return
// }
